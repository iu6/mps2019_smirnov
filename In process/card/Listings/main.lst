L 1 "Source\main.c"
N#include "main.h"
L 1 "Source\main.h" 1
N#ifndef main_h
N#define main_h
N
N#include <MDR32Fx.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32Fx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    22/06/2011
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the Milandr MDR32Fx microcontroller.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32Fx.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32FX_H
N#define __MDR32FX_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32Fx_Peripheral MDR32F9Qx Peripheral
N  * @{
N  */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N/* MDR32Fx Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/
N  NonMaskableInt_IRQn     = -14,  /*!<  2 Non Maskable Interrupt              *///!< NonMaskableInt_IRQn
N  HardFault_IRQn          = -13,  /*!<  3 Hard Fault Interrupt                *///!< HardFault_IRQn
N  MemoryManagement_IRQn   = -12,  /*!<  4 Memory Management Interrupt         *///!< MemoryManagement_IRQn
N  BusFault_IRQn           = -11,  /*!<  5 Bus Fault Interrupt                 *///!< BusFault_IRQn
N  UsageFault_IRQn         = -10,  /*!<  6 Usage Fault Interrupt               *///!< UsageFault_IRQn
N  SVCall_IRQn             = -5,   /*!< 11 SV Call Interrupt                   *///!< SVCall_IRQn
N  PendSV_IRQn             = -2,   /*!< 14 Pend SV Interrupt                   *///!< PendSV_IRQn
N  SysTick_IRQn            = -1,   /*!< 15 System Tick Timer Interrupt         *///!< SysTick_IRQn
N
N/*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/
N  CAN1_IRQn               =  0,   /*!< CAN1 Interrupt                         *///!< CAN1_IRQn
N  CAN2_IRQn               =  1,   /*!< CAN1 Interrupt                         *///!< CAN2_IRQn
N  USB_IRQn                =  2,   /*!< USB Host Interrupt                     *///!< USB_IRQn
N  DMA_IRQn                =  5,   /*!< DMA Interrupt                          *///!< DMA_IRQn
N  UART1_IRQn              =  6,   /*!< UART1 Interrupt                        *///!< UART1_IRQn
N  UART2_IRQn              =  7,   /*!< UART2 Interrupt                        *///!< UART2_IRQn
N  SSP1_IRQn               =  8,   /*!< SSP1 Interrupt                         *///!< SSP1_IRQn
N  I2C_IRQn                =  10,  /*!< I2C Interrupt                          *///!< I2C_IRQn
N  POWER_IRQn              =  11,  /*!< POWER Detecor Interrupt                *///!< POWER_IRQn
N  WWDG_IRQn               =  12,  /*!< Window Watchdog Interrupt              *///!< WWDG_IRQn
N  Timer1_IRQn             =  14,  /*!< Timer1 Interrupt                       *///!< Timer1_IRQn
N  Timer2_IRQn             =  15,  /*!< Timer2 Interrupt                       *///!< Timer2_IRQn
N  Timer3_IRQn             =  16,  /*!< Timer3 Interrupt                       *///!< Timer3_IRQn
N  ADC_IRQn                =  17,  /*!< ADC Interrupt                          *///!< ADC_IRQn
N  COMPARATOR_IRQn         =  19,  /*!< COMPARATOR Interrupt                   *///!< COMPARATOR_IRQn
N  SSP2_IRQn               =  20,  /*!< SSP2 Interrupt                         *///!< SSP2_IRQn
N  BACKUP_IRQn             =  27,  /*!< BACKUP Interrupt                       *///!< BACKUP_IRQn
N  EXT_INT1_IRQn           =  28,  /*!< EXT_INT1 Interrupt                     *///!< EXT_INT1_IRQn
N  EXT_INT2_IRQn           =  29,  /*!< EXT_INT2 Interrupt                     *///!< EXT_INT2_IRQn
N  EXT_INT3_IRQn           =  30,  /*!< EXT_INT3 Interrupt                     *///!< EXT_INT3_IRQn
N  EXT_INT4_IRQn           =  31   /*!< EXT_INT4 Interrupt                     *///!< EXT_INT4_IRQn
N}IRQn_Type;
N
N/** @addtogroup __Configuration_of_CMSIS Configuration of CMSIS
N  * @{
N  */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __CM3_REV              0x0102   /*!< Cortex-M3 Core Revision                      */
N#define __MPU_PRESENT             1     /*!< MPU present or not                           */
N#define __NVIC_PRIO_BITS          3     /*!< Number of Bits used for Priority Levels      */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N
N/** @} */ /* End of group __Configuration_of_CMSIS */
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm3.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060001
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 148 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm3.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060020 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S  return(result);
S}
N#endif
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function executes a exclusive LDR instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function executes a exclusive LDR instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function executes a exclusive LDR instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function executes a exclusive STR instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function executes a exclusive STR instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function executes a exclusive STR instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Rotate Right with Extend (32 bit)
N
N    This function moves each bit of a bitstring right by one bit.
N    The carry input is shifted in at the left end of the bitstring.
N
N    \param [in]    value  Value to rotate
N    \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  LDRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged LDRT instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged LDRT instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged LDRT instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/** \brief  STRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged STRT instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged STRT instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged STRT instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb 0xF":::"memory");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb 0xF":::"memory");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb 0xF":::"memory");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2));
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S#else
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S#endif
S  return(result);
S}
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ             __builtin_clz
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__((always_inline)) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit.
S    The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 149 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060020 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Set Base Priority with condition
N
N    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N    or the new value increases the BASEPRI priority level.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x03) == 0x04) || ((0x03) == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Set Base Priority with condition
S
S    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S	or the new value increases the BASEPRI priority level.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
S{
S  __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 150 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm3.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31                                             /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30                                             /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29                                             /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28                                             /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27                                             /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0                                             /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31                                             /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30                                             /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29                                             /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28                                             /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27                                             /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25                                             /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24                                             /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0                                             /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1                                             /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0                                             /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
X#if (0x0102 < 0x0201)                    
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((1L) && (0x0102 >= 0x200))
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16) | (7UL << 8)));              
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16) |
N                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8));
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if((int32_t)IRQn < 0) {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - 3)) & (uint32_t)0xFFUL);
N  }
N  else {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if((int32_t)IRQn < 0) {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - 3)));
N  }
N  else {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - 3)));
N  }
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                           
N  while(1) { __NOP(); }                                             /* wait until reset */
X  while(1) { __nop(); }                                              
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
X  if ((ticks - 1UL) > (0xFFFFFFUL )) { return (1UL); }     
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0].u32 == 0UL) { __NOP(); }
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0UL) { __nop(); }
N    ITM->PORT[0].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 99 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N#include "system_MDR32F9Qx.h"
L 1 "D:\Keil555\1986VE9X\card\RTE\Device\MDR1986BE93\system_MDR32F9Qx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_MDR32F9Qx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    11/06/2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE system_MDR32F9Qx.h
N  */
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32F9QX MDR32F9QX System
N  * @{
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MDR32F9Qx_H
N#define __SYSTEM_MDR32F9Qx_H
N
N/** @addtogroup __MDR32F9QX_System_Exported_Variables MDR32F9QX System Exported Variables
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock)
N                                           *   default value */
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Variables */
N
N/** @addtogroup __MDR32F9QX_System_Exported_Functions MDR32F9QX System Exported Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Functions */
N
N#endif /*__SYSTEM_MDR32F9Qx_H */
N
N/** @} */ /* End of group __MDR32F9QX */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE system_MDR32F9Qx.h */
L 100 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N
N/** @defgroup __Exported_types Exported types
N  * @{
N  */
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus;
N
N#define IS_BIT_STATUS(STATUS)	(((STATUS) == RESET) || ((STATE) == SET))
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** @} */ /* End of group __Exported_types */
N
N/** @addtogroup __MDR32Fx_Peripheral_Units MDR32F9Qx Peripheral Units
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN CAN
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_CAN_BUF_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N}MDR_CAN_BUF_TypeDef;
N
N/* MDR_CAN_BUF_FILTER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N}MDR_CAN_BUF_FILTER_TypeDef;
N
N/* MDR_CAN_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_CON[32];
X  volatile uint32_t BUF_CON[32];
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N    MDR_CAN_BUF_TypeDef CAN_BUF[32];
N       uint32_t RESERVED3[64];
N    MDR_CAN_BUF_FILTER_TypeDef CAN_BUF_FILTER[32];
N}MDR_CAN_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CONTROL	CAN CONTROL
N  * @{
N  */ 
N
N/*-- CAN_CONTROL: CAN Control Register -----------------------------*/
N/* Bit field positions: */
N#define CAN_CONTROL_CAN_EN_Pos                  0
N#define CAN_CONTROL_ROM_Pos                     1
N#define CAN_CONTROL_STM_Pos                     2
N#define CAN_CONTROL_SAP_Pos                     3
N#define CAN_CONTROL_ROP_Pos                     4
N
N/* Bit field masks: */
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_CONTROL */
N
N/** @defgroup Periph_CAN_STATUS	CAN STATUS
N  * @{
N  */ 
N
N/*-- CAN_STATUS: CAN Status Register -------------------------------*/
N/* Bit field positions: */
N#define CAN_STATUS_RX_READY_Pos                 0
N#define CAN_STATUS_TX_READY_Pos                 1
N#define CAN_STATUS_ERROR_OVER_Pos               2
N#define CAN_STATUS_BIT_ERR_Pos                  3
N#define CAN_STATUS_BIT_STUFF_ERR_Pos            4
N#define CAN_STATUS_CRC_ERR_Pos                  5
N#define CAN_STATUS_FRAME_ERR_Pos                6
N#define CAN_STATUS_ACK_ERR_Pos                  7
N#define CAN_STATUS_IDLOWER_Pos                  8
N#define CAN_STATUS_ERR_STATUS_Pos               9
N#define CAN_STATUS_RX_ERR_CNT8_Pos              11
N#define CAN_STATUS_TX_ERR_CNT8_Pos              12
N#define CAN_STATUS_RX_ERR_CNT_Pos               16
N#define CAN_STATUS_TX_ERR_CNT_Pos               24
N
N/* Bit field masks: */
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N#define CAN_STATUS_ERR_STATUS_Msk               ((uint32_t)0x00000600)
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N#define CAN_STATUS_RX_ERR_CNT_Msk               ((uint32_t)0x00FF0000)
N#define CAN_STATUS_TX_ERR_CNT_Msk               ((uint32_t)0xFF000000)
N
N/* ERR STATUS Modes */
N#define CAN_STATUS_ERR_STATUS_ERROR_ACTIVE			0x00
N#define CAN_STATUS_ERR_STATUS_ERROR_PASSIVE			0x01
N#define CAN_STATUS_ERR_STATUS_ERROR_BUS_OFF_Pos	10
N
N/** @} */ /* End of group CAN_STATUS */
N
N/** @defgroup Periph_CAN_BITTMNG	CAN BITTMNG
N  * @{
N  */ 
N
N/*-- CAN_BITTMNG: CAN Bittiming Register ---------------------------*/
N/* Bit field positions: */
N#define CAN_BITTMNG_BRP_Pos                     0
N#define CAN_BITTMNG_PSEG_Pos                    16
N#define CAN_BITTMNG_SEG1_Pos                    19
N#define CAN_BITTMNG_SEG2_Pos                    22
N#define CAN_BITTMNG_SJW_Pos                     25
N#define CAN_BITTMNG_SB_Pos                      27
N
N/* Bit field masks: */
N#define CAN_BITTMNG_BRP_Msk                     ((uint32_t)0x0000FFFF)
N#define CAN_BITTMNG_PSEG_Msk                    ((uint32_t)0x00070000)
N#define CAN_BITTMNG_SEG1_Msk                    ((uint32_t)0x00380000)
N#define CAN_BITTMNG_SEG2_Msk                    ((uint32_t)0x01C00000)
N#define CAN_BITTMNG_SJW_Msk                     ((uint32_t)0x06000000)
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N/* PSEG Modes */
N#define CAN_BITTMNG_PSEG_1_TQ										0x00
N#define CAN_BITTMNG_PSEG_2_TQ										0x01
N#define CAN_BITTMNG_PSEG_3_TQ										0x02
N#define CAN_BITTMNG_PSEG_4_TQ										0x03
N#define CAN_BITTMNG_PSEG_5_TQ										0x04
N#define CAN_BITTMNG_PSEG_6_TQ										0x05
N#define CAN_BITTMNG_PSEG_7_TQ										0x06
N#define CAN_BITTMNG_PSEG_8_TQ										0x07
N
N/* SEG1 Modes */
N#define CAN_BITTMNG_SEG1_1_TQ										0x00
N#define CAN_BITTMNG_SEG1_2_TQ										0x01
N#define CAN_BITTMNG_SEG1_3_TQ										0x02
N#define CAN_BITTMNG_SEG1_4_TQ										0x03
N#define CAN_BITTMNG_SEG1_5_TQ										0x04
N#define CAN_BITTMNG_SEG1_6_TQ										0x05
N#define CAN_BITTMNG_SEG1_7_TQ										0x06
N#define CAN_BITTMNG_SEG1_8_TQ										0x07
N
N/* SEG2 Modes */
N#define CAN_BITTMNG_SEG2_1_TQ										0x00
N#define CAN_BITTMNG_SEG2_2_TQ										0x01
N#define CAN_BITTMNG_SEG2_3_TQ										0x02
N#define CAN_BITTMNG_SEG2_4_TQ										0x03
N#define CAN_BITTMNG_SEG2_5_TQ										0x04
N#define CAN_BITTMNG_SEG2_6_TQ										0x05
N#define CAN_BITTMNG_SEG2_7_TQ										0x06
N#define CAN_BITTMNG_SEG2_8_TQ										0x07
N
N/* SJW Modes */
N#define CAN_BITTMNG_SJW_1_TQ										0x00
N#define CAN_BITTMNG_SJW_2_TQ										0x01
N#define CAN_BITTMNG_SJW_3_TQ										0x02
N#define CAN_BITTMNG_SJW_4_TQ										0x03
N
N/** @} */ /* End of group CAN_BITTMNG */
N
N/** @defgroup Periph_CAN_INT_EN	CAN INT EN
N  * @{
N  */ 
N
N/*-- CAN_INT_EN: CAN Interrupt enable Register ---------------------*/
N/* Bit field positions: */
N#define CAN_INT_EN_GLB_INT_EN_Pos               0
N#define CAN_INT_EN_RX_INT_EN_Pos                1
N#define CAN_INT_EN_TX_INT_EN_Pos                2
N#define CAN_INT_EN_ERR_INT_EN_Pos               3
N#define CAN_INT_EN_ERR_OVER_INT_EN_Pos          4
N
N/* Bit field masks: */
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_INT_EN */
N
N/** @defgroup Periph_CAN_RXID	CAN RXID
N  * @{
N  */ 
N
N/*-- CAN_RXID:   CAN Receive ID Register ---------------------------*/
N/*-- CAN_TXID:   CAN Transmit ID Register --------------------------*/
N/*-- CAN_BUF_ID: CAN Buffer ID Register ----------------------------*/
N/* Bit field positions: */
N#define CAN_ID_EID_Pos                          0
N#define CAN_ID_SID_Pos                          18
N
N/* Bit field masks: */
N#define CAN_ID_EID_Msk                          ((uint32_t)0x0003FFFF)
N#define CAN_ID_SID_Msk                          ((uint32_t)0x1FFC0000)
N
N/** @} */ /* End of group CAN_RXID */
N
N/** @defgroup Periph_CAN_RXDLC	CAN RXDLC
N  * @{
N  */ 
N
N/*-- CAN_RXDLC:   CAN Receive DLC Register -------------------------*/
N/*-- CAN_TXDLC:   CAN Transmit DLC Register ------------------------*/
N/*-- CAN_BUF_DLC: CAN Buffer DLC Register --------------------------*/
N/* Bit field positions: */
N#define CAN_DLC_Pos                             0
N#define CAN_DLC_RTR_Pos                         8
N#define CAN_DLC_R1_Pos                          9
N#define CAN_DLC_R0_Pos                          10
N#define CAN_DLC_SSR_Pos                         11
N#define CAN_DLC_IDE_Pos                         12
N
N/* Bit field masks: */
N#define CAN_DLC_Msk                             ((uint32_t)0x0000000F)
N#define CAN_DLC_RTR                             ((uint32_t)0x00000100)
N#define CAN_DLC_R1                              ((uint32_t)0x00000200)
N#define CAN_DLC_R0                              ((uint32_t)0x00000400)
N#define CAN_DLC_SSR                             ((uint32_t)0x00000800)
N#define CAN_DLC_IDE                             ((uint32_t)0x00001000)
N
N/* DLC Modes */
N#define CAN_DLC_NO_DATA													0x00
N#define CAN_DLC_1_BYTE													0x01
N#define CAN_DLC_2_BYTES													0x02
N#define CAN_DLC_3_BYTES													0x03
N#define CAN_DLC_4_BYTES													0x04
N#define CAN_DLC_5_BYTES													0x05
N#define CAN_DLC_6_BYTES													0x06
N#define CAN_DLC_7_BYTES													0x07
N#define CAN_DLC_8_BYTES													0x08
N
N/** @} */ /* End of group CAN_RXDLC */
N
N/** @defgroup Periph_CAN_RXDATAL	CAN RXDATAL
N  * @{
N  */ 
N
N/*-- CAN_RXDATAL:   CAN Receive Data low Register ------------------*/
N/*-- CAN_DATAL:     CAN Transmit Data low Register -----------------*/
N/*-- CAN_BUF_DATAL: CAN Buffer Data low Register -------------------*/
N/* Bit field positions: */
N#define CAN_DATAL_DB0_Pos                       0
N#define CAN_DATAL_DB1_Pos                       8
N#define CAN_DATAL_DB2_Pos                       16
N#define CAN_DATAL_DB3_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAL_DB0_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAL_DB1_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAL_DB2_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAL_DB3_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAL */
N
N/** @defgroup Periph_CAN_RXDATAH	CAN RXDATAH
N  * @{
N  */ 
N
N/*-- CAN_RXDATAH:   CAN Receive Data high Register -----------------*/
N/*-- CAN_DATAH:     CAN Transmit Data high Register ----------------*/
N/*-- CAN_BUF_DATAH: CAN Buffer Data high Register ------------------*/
N/* Bit field positions: */
N#define CAN_DATAH_DB4_Pos                       0
N#define CAN_DATAH_DB5_Pos                       8
N#define CAN_DATAH_DB6_Pos                       16
N#define CAN_DATAH_DB7_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAH_DB4_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAH_DB5_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAH_DB6_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAH_DB7_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAH */
N
N/** @defgroup Periph_CAN_BUF_CON	CAN BUF CON
N  * @{
N  */ 
N
N/*-- CAN_BUF_CON: CAN Buffer Connection Register -------------------*/
N/* Bit field positions: */
N#define CAN_BUF_CON_EN_Pos                      0
N#define CAN_BUF_CON_RX_TXN_Pos                  1
N#define CAN_BUF_CON_OVER_EN_Pos                 2
N#define CAN_BUF_CON_RTR_EN_Pos                  3
N#define CAN_BUF_CON_PRIOR_0_Pos                 4
N#define CAN_BUF_CON_TX_REQ_Pos                  5
N#define CAN_BUF_CON_RX_FULL_Pos                 6
N#define CAN_BUF_CON_OVER_WR_Pos                 7
N
N/* Bit field masks: */
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N#define CAN_BUF_CON_RX_TXN                      ((uint32_t)0x00000002)
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N/** @} */ /* End of group CAN_BUF_CON */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN */
N
N/** @defgroup MDR32Fx_Periph_USB USB
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_USB_SEP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N}MDR_USB_SEP_TypeDef;
N
N/* MDR_USB_SEP_FIFO_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N       uint32_t RESERVED3[11];
N}MDR_USB_SEP_FIFO_TypeDef;
N
N/* MDR_USB_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFC;
X  volatile uint32_t HTXFC;
N       uint32_t RESERVED4[11];
N    MDR_USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N    MDR_USB_SEP_FIFO_TypeDef USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N}MDR_USB_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_HTXC	USB HTXC
N  * @{
N  */ 
N
N/*-- USB_HTXC: USB HTXC Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HTXC_TREQ_Pos                       0
N#define USB_HTXC_SOFS_Pos                       1
N#define USB_HTXC_PREEN_Pos                      2
N#define USB_HTXC_ISOEN_Pos                      3
N
N/* Bit field masks: */
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HTXC */
N
N/** @defgroup Periph_USB_HTXLC	USB HTXLC
N  * @{
N  */ 
N
N/*-- USB_HTXLC: USB HTXLC Register ---------------------------------*/
N/* Bit field positions: */
N#define USB_HTXLC_Pos                           0
N#define USB_HTXLC_DC_Pos                        2
N#define USB_HTXLC_FSPL_Pos                      3
N#define USB_HTXLC_FSLR_Pos                      4
N
N/* Bit field masks: */
N#define USB_HTXLC_Msk                           ((uint32_t)0x00000003)
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_HTXLC */
N
N/** @defgroup Periph_USB_HIS	USB HIS
N  * @{
N  */ 
N
N/*-- USB_HIS: USB_HIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIS_TDONE_Pos                       0
N#define USB_HIS_RESUME_Pos                      1
N#define USB_HIS_CONEV_Pos                       2
N#define USB_HIS_SOFS_Pos                        3
N
N/* Bit field masks: */
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIS */
N
N/** @defgroup Periph_USB_HIM	USB HIM
N  * @{
N  */ 
N
N/*-- USB_HIM: USB_HIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIM_TDONEIE_Pos                     0
N#define USB_HIM_RESUMEIE_Pos                    1
N#define USB_HIM_CONEVIE_Pos                     2
N#define USB_HIM_SOFIE_Pos                       3
N
N/* Bit field masks: */
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIM */
N
N/** @defgroup Periph_USB_HRXS	USB HRXS
N  * @{
N  */ 
N
N/*-- USB_HRXS: USB_HRXS Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HRXS_CRCERR_Pos                     0
N#define USB_HRXS_BSERR_Pos                      1
N#define USB_HRXS_RXOF_Pos                       2
N#define USB_HRXS_RXTO_Pos                       3
N#define USB_HRXS_NAKRXED_Pos                    4
N#define USB_HRXS_STALLRXED_Pos                  5
N#define USB_HRXS_ACKRXED_Pos                    6
N#define USB_HRXS_DATASEQ_Pos                    7
N
N/* Bit field masks: */
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HRXS */
N
N/** @defgroup Periph_USB_SEP_CTRL	USB SEP CTRL
N  * @{
N  */ 
N
N/*-- USB_SEP_CTRL: USB_SEP Control Register ------------------------*/
N/* Bit field positions: */
N#define USB_SEP_CTRL_EPEN_Pos                   0
N#define USB_SEP_CTRL_EPRDY_Pos                  1
N#define USB_SEP_CTRL_EPDATASEQ_Pos              2
N#define USB_SEP_CTRL_EPSSTALL_Pos               3
N#define USB_SEP_CTRL_EPISOEN_Pos                4
N
N/* Bit field masks: */
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SEP_CTRL */
N
N/** @defgroup Periph_USB_SEP_STS	USB SEP STS
N  * @{
N  */ 
N
N/*-- USB_SEP_STS: USB_SEP Status Register --------------------------*/
N/* Bit field positions: */
N#define USB_SEP_STS_SCCRCERR_Pos                0
N#define USB_SEP_STS_SCBSERR_Pos                 1
N#define USB_SEP_STS_SCRXOF_Pos                  2
N#define USB_SEP_STS_SCRXTO_Pos                  3
N#define USB_SEP_STS_SCNAKSENT_Pos               4
N#define USB_SEP_STS_SCSTALLSENT_Pos             5
N#define USB_SEP_STS_SCACKRXED_Pos               6
N#define USB_SEP_STS_SCDATASEQ_Pos               7
N
N/* Bit field masks: */
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_SEP_STS */
N
N/** @defgroup Periph_USB_SC	USB SC
N  * @{
N  */ 
N
N/*-- USB_SC: USB_SC Register ---------------------------------------*/
N/* Bit field positions: */
N#define USB_SCGEN_Pos                           0
N#define USB_SCTXLS_Pos                          1
N#define USB_SCDC_Pos                            3
N#define USB_SCFSP_Pos                           4
N#define USB_SCFSR_Pos                           5
N
N/* Bit field masks: */
N#define USB_SCGEN                               ((uint32_t)0x00000001)
N#define USB_SCTXLS_Msk                          ((uint32_t)0x00000006)
N#define USB_SCDC                                ((uint32_t)0x00000008)
N#define USB_SCFSP                               ((uint32_t)0x00000010)
N#define USB_SCFSR                               ((uint32_t)0x00000020)
N
N/** @} */ /* End of group USB_SC */
N
N/** @defgroup Periph_USB_SIS	USB SIS
N  * @{
N  */ 
N
N/*-- USB_SIS: USB_SIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIS_SCTDONE_Pos                     0
N#define USB_SIS_SCRESUME_Pos                    1
N#define USB_SIS_SCRESETEV_Pos                   2
N#define USB_SIS_SCSOFREC_Pos                    3
N#define USB_SIS_SCNAKSENT_Pos                   4
N
N/* Bit field masks: */
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIS */
N
N/** @defgroup Periph_USB_SIM	USB SIM
N  * @{
N  */ 
N
N/*-- USB_SIM: USB_SIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIM_SCTDONEIE_Pos                   0
N#define USB_SIM_SCRESUMEIE_Pos                  1
N#define USB_SIM_SCRESETEVIE_Pos                 2
N#define USB_SIM_SCSOFRECIE_Pos                  3
N#define USB_SIM_SCNAKSENTIE_Pos                 4
N
N/* Bit field masks: */
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIM */
N
N/** @defgroup Periph_USB_HSCR	USB HSCR
N  * @{
N  */ 
N
N/*-- USB_HSCR: USB_HSCR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSCR_HOST_MODE_Pos                  0
N#define USB_HSCR_RESET_CORE_Pos                 1
N#define USB_HSCR_EN_TX_Pos                      2
N#define USB_HSCR_EN_RX_Pos                      3
N#define USB_HSCR_DP_PULLUP_Pos                  4
N#define USB_HSCR_DP_PULLDOWN_Pos                5
N#define USB_HSCR_DM_PULLUP_Pos                  6
N#define USB_HSCR_DM_PULLDOWN_Pos                7
N
N/* Bit field masks: */
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HSCR */
N
N/** @defgroup Periph_USB_HSVR	USB HSVR
N  * @{
N  */ 
N
N/*-- USB_HSVR: USB_HSVR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSVR_VERSION_Pos                    0
N#define USB_HSVR_REVISION_Pos                   4
N
N/* Bit field masks: */
N#define USB_HSVR_VERSION_Msk                    ((uint32_t)0x0000000F)
N#define USB_HSVR_REVISION_Msk                   ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group USB_HSVR */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB */
N
N/** @defgroup MDR32Fx_Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EEPROM_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N}MDR_EEPROM_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_CMD	EEPROM CMD
N  * @{
N  */ 
N
N/*-- EEPROM_CMD: EEPROM Command Register ---------------------------*/
N/* Bit field positions: */
N#define EEPROM_CMD_CON_Pos                      0
N#define EEPROM_CMD_WR_Pos                       1
N#define EEPROM_CMD_RD_Pos                       2
N#define EEPROM_CMD_DELAY_Pos                    3
N#define EEPROM_CMD_XE_Pos                       6
N#define EEPROM_CMD_YE_Pos                       7
N#define EEPROM_CMD_SE_Pos                       8
N#define EEPROM_CMD_IFREN_Pos                    9
N#define EEPROM_CMD_ERASE_Pos                    10
N#define EEPROM_CMD_MAS1_Pos                     11
N#define EEPROM_CMD_PROG_Pos                     12
N#define EEPROM_CMD_NVSTR_Pos                    13
N
N/* Bit field masks: */
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N#define EEPROM_CMD_DELAY_Msk                    ((uint32_t)0x00000038)
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N/* EEPROM Key */
N#define EEPROM_KEY															0x8AAA5551
N
N#define EEPROM_ADDRESS													0x08000000
N
N#define EEPROM_SECTOR_A_SHIFT										0x00
N#define EEPROM_SECTOR_B_SHIFT										0x04
N#define EEPROM_SECTOR_C_SHIFT										0x08
N#define EEPROM_SECTOR_D_SHIFT										0x0C
N
N#define EEPROM_WORD_SIZE												4
N#define EEPROM_PAGE_SIZE												4096
N
N/** @} */ /* End of group EEPROM_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_RST_CLK_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N}MDR_RST_CLK_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_CLOCK_STATUS	RST CLK CLOCK STATUS
N  * @{
N  */ 
N
N/*-- RST_CLK_CLOCK_STATUS: Clock Status Register -------------------*/
N/* Bit field positions: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_Pos    0
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos    1
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_Pos        2
N
N/* Bit field masks: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N/** @} */ /* End of group RST_CLK_CLOCK_STATUS */
N
N/** @defgroup Periph_RST_CLK_PLL_CONTROL	RST CLK PLL CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_PLL_CONTROL: PLL Control Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos      0
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos     1
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos      2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos     3
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos     4
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos     8
N
N/* Bit field masks: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Msk     ((uint32_t)0x000000F0)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Msk     ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group RST_CLK_PLL_CONTROL */
N
N/** @defgroup Periph_RST_CLK_HS_CONTROL	RST CLK HS CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_HS_CONTROL: HS Control Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_HS_CONTROL_HSE_ON_Pos           0
N#define RST_CLK_HS_CONTROL_HSE_BYP_Pos          1
N
N/* Bit field masks: */
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N/** @} */ /* End of group RST_CLK_HS_CONTROL */
N
N/** @defgroup Periph_RST_CLK_CPU_CLOCK	RST CLK CPU CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CPU_CLOCK: CPU Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos        0
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos        2
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos        4
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Pos          8
N
N/* Bit field masks: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk        ((uint32_t)0x000000F0)
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Msk          ((uint32_t)0x00000300)
N
N/* CPU C1 SEL Modes */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSI							0x00
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSI_DIV_2				0x01
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSE							0x02
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSE_DIV_2				0x03
N
N/* CPU C2 SEL Modes */
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_CPU_C1						0x00
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_PLL_CPU					0x01
N
N/* CPU C3 SEL Modes */
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2						0x00
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_2			0x08
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_4			0x09
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_8			0x0A
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_16		0x0B
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_32		0x0C
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_64		0x0D
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_128		0x0E
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2_DIV_256		0x0F
N
N/* HCLK SEL Modes */
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_HSI								0x00
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_CPU_C3							0x01
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_LSE								0x02
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_LSI								0x03
N
N/** @} */ /* End of group RST_CLK_CPU_CLOCK */
N
N/** @defgroup Periph_RST_CLK_USB_CLOCK	RST CLK USB CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_USB_CLOCK: USB Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Pos        0
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_Pos        2
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_Pos        4
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_Pos        8
N
N/* Bit field masks: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_USB_CLOCK_USB_C3_SEL	        	((uint32_t)0x00000010)
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N/* USB C1 SEL Modes */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_HSI						0x00
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_HSI_DIV_2			0x01
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_HSE						0x02
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_HSE_DIV_2			0x03
N
N/* USB C2 SEL Modes */
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_USB_C1					0x00
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_PLL_USB				0x01
N
N/* USB C3 SEL Modes */
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_USB_C2					0x00
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_USB_C2_DIV_2		0x01
N
N/** @} */ /* End of group RST_CLK_USB_CLOCK */
N
N/** @defgroup Periph_RST_CLK_ADC_MCO_CLOCK	RST CLK ADC MCO CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_ADC_MCO_CLOCK: ADC Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos    0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos    4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos    8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_Pos    13
N
N/* Bit field masks: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Msk    ((uint32_t)0x00000003)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Msk    ((uint32_t)0x00000030)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Msk    ((uint32_t)0x00000F00)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N/* ADC C1 SEL Modes */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_CPU_C1						0x00
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_USB_C1						0x01
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_CPU_C2						0x02
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_USB_C2						0x03
N
N/* ADC C2 SEL Modes */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_LSE							0x00
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_LSI							0x01
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_ADC_C1						0x02
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_HSI_C1						0x03
N
N/* ADC C3 SEL Modes */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2						0x00
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_2			0x08
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_4			0x09
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_8			0x0A
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_16		0x0B
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_32		0x0C
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_64		0x0D
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_128		0x0E
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_ADC_C2_DIV_256		0x0F
N
N/** @} */ /* End of group RST_CLK_ADC_MCO_CLOCK */
N
N/** @defgroup Periph_RST_CLK_RTC_CLOCK	RST CLK RTC CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_RTC_CLOCK: RTC Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Pos           0
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Pos           4
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_Pos        8
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_Pos        9
N
N/* Bit field masks: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Msk           ((uint32_t)0x0000000F)
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Msk           ((uint32_t)0x000000F0)
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N/* HSE SEL Modes */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2					0x00
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_2		0x08
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_4		0x09
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_8		0x0A
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_16		0x0B
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_32		0x0C
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_64		0x0D
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_128	0x0E
N#define RST_CLK_RTC_CLOCK_HSE_SEL_HSE_C2_DIV_256	0x0F
N
N/* HSI SEL Modes */
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2					0x00
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_2		0x08
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_4		0x09
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_8		0x0A
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_16		0x0B
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_32		0x0C
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_64		0x0D
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_128	0x0E
N#define RST_CLK_RTC_CLOCK_HSI_SEL_HSI_C2_DIV_256	0x0F
N
N/** @} */ /* End of group RST_CLK_RTC_CLOCK */
N
N/** @defgroup Periph_RST_CLK_CAN_CLOCK	RST CLK CAN CLOCK
N  * @{
N  */ 
N	
N/*-- RST_CLK_PER_CLOCK: PER Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PER_CLOCK_PCLK_EN_CAN1_Pos						0
N#define RST_CLK_PER_CLOCK_PCLK_EN_CAN2_Pos						1
N#define RST_CLK_PER_CLOCK_PCLK_EN_USB_Pos							2
N#define RST_CLK_PER_CLOCK_PCLK_EN_EEPROM_CNTRL_Pos		3
N#define RST_CLK_PER_CLOCK_PCLK_EN_RST_CLK_Pos					4
N#define RST_CLK_PER_CLOCK_PCLK_EN_DMA_Pos							5
N#define RST_CLK_PER_CLOCK_PCLK_EN_UART1_Pos						6
N#define RST_CLK_PER_CLOCK_PCLK_EN_UART2_Pos						7
N#define RST_CLK_PER_CLOCK_PCLK_EN_SPI1_Pos						8
N#define RST_CLK_PER_CLOCK_PCLK_EN_I2C_Pos							10
N#define RST_CLK_PER_CLOCK_PCLK_EN_POWER_Pos						11
N#define RST_CLK_PER_CLOCK_PCLK_EN_WWDT_Pos						12
N#define RST_CLK_PER_CLOCK_PCLK_EN_IWDT_Pos						13
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER1_Pos					14
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER2_Pos					15
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER3_Pos					16
N#define RST_CLK_PER_CLOCK_PCLK_EN_ADC_Pos							17
N#define RST_CLK_PER_CLOCK_PCLK_EN_DAC_Pos							18
N#define RST_CLK_PER_CLOCK_PCLK_EN_COMP_Pos						19
N#define RST_CLK_PER_CLOCK_PCLK_EN_SPI2_Pos						20
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTA_Pos						21
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTB_Pos						22
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTC_Pos						23
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTD_Pos						24
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTE_Pos						25
N#define RST_CLK_PER_CLOCK_PCLK_EN_BKP_Pos							27
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTF_Pos						29
N#define RST_CLK_PER_CLOCK_PCLK_EN_EXT_BUS_CNTRL_Pos		30
N
N/* Bit field masks: */
N#define RST_CLK_PER_CLOCK_PCLK_EN_CAN1								((uint32_t)0x00000001)
N#define RST_CLK_PER_CLOCK_PCLK_EN_CAN2								((uint32_t)0x00000002)
N#define RST_CLK_PER_CLOCK_PCLK_EN_USB									((uint32_t)0x00000004)
N#define RST_CLK_PER_CLOCK_PCLK_EN_EEPROM_CNTRL				((uint32_t)0x00000008)
N#define RST_CLK_PER_CLOCK_PCLK_EN_RST_CLK							((uint32_t)0x00000010)
N#define RST_CLK_PER_CLOCK_PCLK_EN_DMA									((uint32_t)0x00000020)
N#define RST_CLK_PER_CLOCK_PCLK_EN_UART1								((uint32_t)0x00000040)
N#define RST_CLK_PER_CLOCK_PCLK_EN_UART2								((uint32_t)0x00000080)
N#define RST_CLK_PER_CLOCK_PCLK_EN_SPI1								((uint32_t)0x00000100)
N#define RST_CLK_PER_CLOCK_PCLK_EN_I2C									((uint32_t)0x00000400)
N#define RST_CLK_PER_CLOCK_PCLK_EN_POWER								((uint32_t)0x00000800)
N#define RST_CLK_PER_CLOCK_PCLK_EN_WWDT								((uint32_t)0x00001000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_IWDT								((uint32_t)0x00002000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER1							((uint32_t)0x00004000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER2							((uint32_t)0x00008000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_TIMER3							((uint32_t)0x00010000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_ADC									((uint32_t)0x00020000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_DAC									((uint32_t)0x00040000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_COMP								((uint32_t)0x00080000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_SPI2								((uint32_t)0x00100000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTA								((uint32_t)0x00200000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTB								((uint32_t)0x00400000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTC								((uint32_t)0x00800000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTD								((uint32_t)0x01000000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTE								((uint32_t)0x02000000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_BKP									((uint32_t)0x08000000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_PORTF								((uint32_t)0x20000000)
N#define RST_CLK_PER_CLOCK_PCLK_EN_EXT_BUS_CNTRL				((uint32_t)0x40000000)
N
N/** @} */ /* End of group RST_CLK_PER_CLOCK */
N
N/** @defgroup Periph_RST_CLK_PER_CLOCK	RST CLK PER CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CAN_CLOCK: CAN Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Pos          0
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Pos          8
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_Pos       24
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N/* CAN BRG Modes */
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK					0x00
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_2		0x01
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_4		0x02
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_8		0x03
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_16		0x04
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_32		0x05
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_64		0x06
N#define RST_CLK_CAN_CLOCK_CAN_BRG_HCLK_DIV_128	0x07
N
N/** @} */ /* End of group RST_CLK_CAN_CLOCK */
N
N/** @defgroup Periph_RST_CLK_TIM_CLOCK	RST CLK TIM CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_TIM_CLOCK: Timer Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Pos          0
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Pos          8
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Pos          16
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_Pos       24
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_Pos       25
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_Pos       26
N
N/* Bit field masks: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Msk          ((uint32_t)0x00FF0000)
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N/* TIM BRG Modes */
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK					0x00
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_2		0x01
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_4		0x02
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_8		0x03
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_16		0x04
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_32		0x05
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_64		0x06
N#define RST_CLK_TIM_CLOCK_TIM_BRG_HCLK_DIV_128	0x07
N
N/** @} */ /* End of group RST_CLK_TIM_CLOCK */
N
N/** @defgroup Periph_RST_CLK_UART_CLOCK	RST CLK UART CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_UART_CLOCK: UART Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Pos        0
N#define RST_CLK_UART_CLOCK_UART2_BRG_Pos        8
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_Pos     24
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_Pos     25
N
N/* Bit field masks: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Msk        ((uint32_t)0x000000FF)
N#define RST_CLK_UART_CLOCK_UART2_BRG_Msk        ((uint32_t)0x0000FF00)
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N/* UART BRG Modes */
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK						0x00
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_2			0x01
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_4			0x02
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_8			0x03
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_16			0x04
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_32			0x05
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_64			0x06
N#define RST_CLK_UART_CLOCK_UART_BRG_HCLK_DIV_128		0x07
N
N/** @} */ /* End of group RST_CLK_UART_CLOCK */
N
N/** @defgroup Periph_RST_CLK_SSP_CLOCK	RST CLK SSP CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_SSP_CLOCK: SSP Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Pos          0
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Pos          8
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_Pos       24
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N/* SSP BRG Modes */
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK					0x00
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_2		0x01
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_4		0x02
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_8		0x03
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_16		0x04
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_32		0x05
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_64		0x06
N#define RST_CLK_SSP_CLOCK_SSP_BRG_HCLK_DIV_128	0x07
N
N/** @} */ /* End of group RST_CLK_SSP_CLOCK */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK */
N
N/** @defgroup MDR32Fx_Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DMA_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N}MDR_DMA_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_STATUS	DMA STATUS
N  * @{
N  */ 
N
N/*-- DMA_STATUS: DMA Status Register -------------------------------*/
N/* Bit field positions: */
N#define DMA_STATUS_MASTER_ENABLE_Pos            0
N#define DMA_STATUS_STATE_Pos                    4
N#define DMA_STATUS_CHNLS_MINUS1_Pos             16
N#define DMA_STATUS_TEST_STATUS_Pos              28
N
N/* Bit field masks: */
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N#define DMA_STATUS_STATE_Msk                    ((uint32_t)0x000000F0)
N#define DMA_STATUS_CHNLS_MINUS1_Msk             ((uint32_t)0x001F0000)
N#define DMA_STATUS_TEST_STATUS_Msk              ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group DMA_STATUS */
N
N/** @defgroup Periph_DMA_CFG	DMA CFG
N  * @{
N  */ 
N
N/*-- DMA_CFG: DMA Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DMA_CFG_MASTER_ENABLE_Pos               0
N#define DMA_CFG_CHNL_PROT_CTRL_Pos              5
N
N/* Bit field masks: */
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N#define DMA_CFG_CHNL_PROT_CTRL_Msk              ((uint32_t)0x000000E0)
N
N/** @} */ /* End of group DMA_CFG */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA */
N
N/** @defgroup MDR32Fx_Periph_UART UART
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_UART_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_UART_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_DR	UART DR
N  * @{
N  */ 
N
N/*-- UART_DR: UART Data Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_DR_DATA_Pos                        0
N#define UART_DR_FE_Pos                          8
N#define UART_DR_PE_Pos                          9
N#define UART_DR_BE_Pos                          10
N#define UART_DR_OE_Pos                          11
N
N/* Bit field masks: */
N#define UART_DR_DATA_Msk                        ((uint32_t)0x000000FF)
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N/** @} */ /* End of group UART_DR */
N
N/** @defgroup Periph_UART_RSR_ECR	UART RSR ECR
N  * @{
N  */ 
N
N/*-- UART_RSR_ECR: UART RSR Register -------------------------------*/
N/* Bit field positions: */
N#define UART_RSR_ECR_FE_Pos                     0
N#define UART_RSR_ECR_PE_Pos                     1
N#define UART_RSR_ECR_BE_Pos                     2
N#define UART_RSR_ECR_OE_Pos                     3
N
N/* Bit field masks: */
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N/** @} */ /* End of group UART_RSR_ECR */
N
N/** @defgroup Periph_UART_FR	UART FR
N  * @{
N  */ 
N
N/*-- UART_FR: UART Flag Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_FR_CTS_Pos                         0
N#define UART_FR_DSR_Pos                         1
N#define UART_FR_DCD_Pos                         2
N#define UART_FR_BUSY_Pos                        3
N#define UART_FR_RXFE_Pos                        4
N#define UART_FR_TXFF_Pos                        5
N#define UART_FR_RXFF_Pos                        6
N#define UART_FR_TXFE_Pos                        7
N#define UART_FR_RI_Pos                          8
N
N/* Bit field masks: */
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N/** @} */ /* End of group UART_FR */
N
N/** @defgroup Periph_UART_LCR_H	UART LCR H
N  * @{
N  */ 
N
N/*-- UART_LCR_H: UART LCR_H Register -------------------------------*/
N/* Bit field positions: */
N#define UART_LCR_H_BRK_Pos                      0
N#define UART_LCR_H_PEN_Pos                      1
N#define UART_LCR_H_EPS_Pos                      2
N#define UART_LCR_H_STP2_Pos                     3
N#define UART_LCR_H_FEN_Pos                      4
N#define UART_LCR_H_WLEN_Pos                     5
N#define UART_LCR_H_SPS_Pos                      7
N
N/* Bit field masks: */
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N#define UART_LCR_H_WLEN_Msk                     ((uint32_t)0x00000060)
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N/* WLEN Modes */
N#define UART_LCR_H_WLEN_5_BITS									0x00
N#define UART_LCR_H_WLEN_6_BITS									0x01
N#define UART_LCR_H_WLEN_7_BITS									0x02
N#define UART_LCR_H_WLEN_8_BITS									0x03
N
N/** @} */ /* End of group UART_LCR_H */
N
N/** @defgroup Periph_UART_CR	UART CR
N  * @{
N  */ 
N
N/*-- UART_CR: UART Command Register --------------------------------*/
N/* Bit field positions: */
N#define UART_CR_UARTEN_Pos                      0
N#define UART_CR_SIREN_Pos                       1
N#define UART_CR_SIRLP_Pos                       2
N#define UART_CR_LBE_Pos                         7
N#define UART_CR_TXE_Pos                         8
N#define UART_CR_RXE_Pos                         9
N#define UART_CR_DTR_Pos                         10
N#define UART_CR_RTS_Pos                         11
N#define UART_CR_OUT1_Pos                        12
N#define UART_CR_OUT2_Pos                        13
N#define UART_CR_RTSEN_Pos                       14
N#define UART_CR_CTSEN_Pos                       15
N
N/* Bit field masks: */
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N#define UART_CR_OUT1                            ((uint32_t)0x00001000)
N#define UART_CR_OUT2                            ((uint32_t)0x00002000)
N#define UART_CR_RTSEN                           ((uint32_t)0x00004000)
N#define UART_CR_CTSEN                           ((uint32_t)0x00008000)
N
N/** @} */ /* End of group UART_CR */
N
N/** @defgroup Periph_UART_IFLS	UART IFLS
N  * @{
N  */ 
N
N/*-- UART_IFLS: UART IFLS Register ---------------------------------*/
N/* Bit field positions: */
N#define UART_IFLS_TXIFLSEL_Pos                  0
N#define UART_IFLS_RXIFLSEL_Pos                  3
N
N/* Bit field masks: */
N#define UART_IFLS_TXIFLSEL_Msk                  ((uint32_t)0x00000007)
N#define UART_IFLS_RXIFLSEL_Msk                  ((uint32_t)0x00000038)
N
N/* IFLSEL Modes */
N#define UART_IFLS_IFLSEL_1_DIV_8							0x00
N#define UART_IFLS_IFLSEL_1_DIV_4							0x01
N#define UART_IFLS_IFLSEL_1_DIV_2							0x02
N#define UART_IFLS_IFLSEL_3_DIV_4							0x03
N#define UART_IFLS_IFLSEL_7_DIV_8							0x04
N
N/** @} */ /* End of group UART_IFLS */
N
N/** @defgroup Periph_UART_IMSC	UART IMSC
N  * @{
N  */ 
N
N/*-- UART_IMSC: UART Interrupt Mask Register -----------------------*/
N/* Bit field positions: */
N#define UART_IMSC_RIMIM_Pos                     0
N#define UART_IMSC_CTSMIM_Pos                    1
N#define UART_IMSC_DCDMIM_Pos                    2
N#define UART_IMSC_DSRMIM_Pos                    3
N#define UART_IMSC_RXIM_Pos                      4
N#define UART_IMSC_TXIM_Pos                      5
N#define UART_IMSC_RTIM_Pos                      6
N#define UART_IMSC_FEIM_Pos                      7
N#define UART_IMSC_PEIM_Pos                      8
N#define UART_IMSC_BEIM_Pos                      9
N#define UART_IMSC_OEIM_Pos                      10
N
N/* Bit field masks: */
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_IMSC */
N
N/** @defgroup Periph_UART_RIS	UART RIS
N  * @{
N  */ 
N
N/*-- UART_RIS: UART Interrupt Pending Register ---------------------*/
N/* Bit field positions: */
N#define UART_RIS_RIRMIS_Pos                     0
N#define UART_RIS_CTSRMIS_Pos                    1
N#define UART_RIS_DCDRMIS_Pos                    2
N#define UART_RIS_DSRRMIS_Pos                    3
N#define UART_RIS_RXRIS_Pos                      4
N#define UART_RIS_TXRIS_Pos                      5
N#define UART_RIS_RTRIS_Pos                      6
N#define UART_RIS_FERIS_Pos                      7
N#define UART_RIS_PERIS_Pos                      8
N#define UART_RIS_BERIS_Pos                      9
N#define UART_RIS_OERIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_RIS */
N
N/** @defgroup Periph_UART_MIS	UART MIS
N  * @{
N  */ 
N
N/*-- UART_MIS: UART Masked Interrupt Pending Register --------------*/
N/* Bit field positions: */
N#define UART_MIS_RIMMIS_Pos                     0
N#define UART_MIS_CTSMMIS_Pos                    1
N#define UART_MIS_DCDMMIS_Pos                    2
N#define UART_MIS_DSRMMIS_Pos                    3
N#define UART_MIS_RXMIS_Pos                      4
N#define UART_MIS_TXMIS_Pos                      5
N#define UART_MIS_RTMIS_Pos                      6
N#define UART_MIS_FEMIS_Pos                      7
N#define UART_MIS_PEMIS_Pos                      8
N#define UART_MIS_BEMIS_Pos                      9
N#define UART_MIS_OEMIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_MIS */
N
N/** @defgroup Periph_UART_ICR	UART ICR
N  * @{
N  */ 
N
N/*-- UART_ICR: UART Interrupt Clear Register -----------------------*/
N/* Bit field positions: */
N#define UART_ICR_RIMIC_Pos                      0
N#define UART_ICR_CTSMIC_Pos                     1
N#define UART_ICR_DCDMIC_Pos                     2
N#define UART_ICR_DSRMIC_Pos                     3
N#define UART_ICR_RXIC_Pos                       4
N#define UART_ICR_TXIC_Pos                       5
N#define UART_ICR_RTIC_Pos                       6
N#define UART_ICR_FEIC_Pos                       7
N#define UART_ICR_PEIC_Pos                       8
N#define UART_ICR_BEIC_Pos                       9
N#define UART_ICR_OEIC_Pos                       10
N
N/* Bit field masks: */
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_ICR */
N
N/** @defgroup Periph_UART_DMACR	UART DMACR
N  * @{
N  */ 
N
N/*-- UART_DMACR: UART DMA Control Register -------------------------*/
N/* Bit field positions: */
N#define UART_DMACR_RXDMAE_Pos                   0
N#define UART_DMACR_TXDMAE_Pos                   1
N#define UART_DMACR_DMAONERR_Pos                 2
N
N/* Bit field masks: */
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group UART_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART */
N
N/** @defgroup MDR32Fx_Periph_SSP SSP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_SSP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_SSP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_SSP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_SSP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SSP_CR0	SSP CR0
N  * @{
N  */ 
N
N/*-- SSP_CR0: SSP Control0 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR0_DSS_Pos                         0
N#define SSP_CR0_FRF_Pos                         4
N#define SSP_CR0_SPO_Pos                         6
N#define SSP_CR0_SPH_Pos                         7
N#define SSP_CR0_SCR_Pos                         8
N
N/* Bit field masks: */
N#define SSP_CR0_DSS_Msk                         ((uint32_t)0x0000000F)
N#define SSP_CR0_FRF_Msk                         ((uint32_t)0x00000030)
N#define SSP_CR0_SPO                             ((uint32_t)0x00000040)
N#define SSP_CR0_SPH                             ((uint32_t)0x00000080)
N#define SSP_CR0_SCR_Msk                         ((uint32_t)0x0000FF00)
N
N/* DSS Modes */
N#define SSP_CR0_DSS_4_BITS											0x03
N#define SSP_CR0_DSS_5_BITS											0x04
N#define SSP_CR0_DSS_6_BITS											0x05
N#define SSP_CR0_DSS_7_BITS											0x06
N#define SSP_CR0_DSS_8_BITS											0x07
N#define SSP_CR0_DSS_9_BITS											0x08
N#define SSP_CR0_DSS_10_BITS											0x09
N#define SSP_CR0_DSS_11_BITS											0x0A
N#define SSP_CR0_DSS_12_BITS											0x0B
N#define SSP_CR0_DSS_13_BITS											0x0C
N#define SSP_CR0_DSS_14_BITS											0x0D
N#define SSP_CR0_DSS_15_BITS											0x0E
N#define SSP_CR0_DSS_16_BITS											0x0F
N
N/* FRF Modes */
N#define SSP_CR0_FRF_SPI_MOT											0x00
N#define SSP_CR0_FRF_SSI_TI											0x01
N#define SSP_CR0_FRF_MW_NS												0x02
N
N/** @} */ /* End of group SSP_CR0 */
N
N/** @defgroup Periph_SSP_CR1	SSP CR1
N  * @{
N  */ 
N
N/*-- SSP_CR1: SSP Control1 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR1_LBM_Pos                         0
N#define SSP_CR1_SSE_Pos                         1
N#define SSP_CR1_MS_Pos                          2
N#define SSP_CR1_SOD_Pos                         3
N
N/* Bit field masks: */
N#define SSP_CR1_LBM                             ((uint32_t)0x00000001)
N#define SSP_CR1_SSE                             ((uint32_t)0x00000002)
N#define SSP_CR1_MS                              ((uint32_t)0x00000004)
N#define SSP_CR1_SOD                             ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_CR1 */
N
N/** @defgroup Periph_SSP_SR	SSP SR
N  * @{
N  */ 
N
N/*-- SSP_SR: SSP Status Register -----------------------------------*/
N/* Bit field positions: */
N#define SSP_SR_TFE_Pos                          0
N#define SSP_SR_TNF_Pos                          1
N#define SSP_SR_RNE_Pos                          2
N#define SSP_SR_RFF_Pos                          3
N#define SSP_SR_BSY_Pos                          4
N
N/* Bit field masks: */
N#define SSP_SR_TFE                              ((uint32_t)0x00000001)
N#define SSP_SR_TNF                              ((uint32_t)0x00000002)
N#define SSP_SR_RNE                              ((uint32_t)0x00000004)
N#define SSP_SR_RFF                              ((uint32_t)0x00000008)
N#define SSP_SR_BSY                              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group SSP_SR */
N
N/** @defgroup Periph_SSP_CPSR	SSP CPSR
N  * @{
N  */ 
N
N/*-- SSP_CPSR: SSP Clock Prescale Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CPSR_CPSDVSR_Pos										0
N
N/* Bit field masks: */
N#define SSP_CPSR_CPSDVSR_Msk										((uint32_t)0x0000000F)
N
N/** @} */ /* End of group SSP_CPSR */
N
N/** @defgroup Periph_SSP_IMSC	SSP IMSC
N  * @{
N  */ 
N
N/*-- SSP_IMSC: SSP Interrupt Mask Register -------------------------*/
N/* Bit field positions: */
N#define SSP_IMSC_RORIM_Pos                      0
N#define SSP_IMSC_RTIM_Pos                       1
N#define SSP_IMSC_RXIM_Pos                       2
N#define SSP_IMSC_TXIM_Pos                       3
N
N/* Bit field masks: */
N#define SSP_IMSC_RORIM                          ((uint32_t)0x00000001)
N#define SSP_IMSC_RTIM                           ((uint32_t)0x00000002)
N#define SSP_IMSC_RXIM                           ((uint32_t)0x00000004)
N#define SSP_IMSC_TXIM                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_IMSC */
N
N/** @defgroup Periph_SSP_RIS	SSP RIS
N  * @{
N  */ 
N
N/*-- SSP_RIS: SSP Interrupt Pending Register -----------------------*/
N/* Bit field positions: */
N#define SSP_RIS_RORRIS_Pos                      0
N#define SSP_RIS_RTRIS_Pos                       1
N#define SSP_RIS_RXRIS_Pos                       2
N#define SSP_RIS_TXRIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_RIS_RORRIS                          ((uint32_t)0x00000001)
N#define SSP_RIS_RTRIS                           ((uint32_t)0x00000002)
N#define SSP_RIS_RXRIS                           ((uint32_t)0x00000004)
N#define SSP_RIS_TXRIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_RIS */
N
N/** @defgroup Periph_SSP_MIS	SSP MIS
N  * @{
N  */ 
N
N/*-- SSP_MIS: SSP Masked Interrupt Pending Register ----------------*/
N/* Bit field positions: */
N#define SSP_MIS_RORMIS_Pos                      0
N#define SSP_MIS_RTMIS_Pos                       1
N#define SSP_MIS_RXMIS_Pos                       2
N#define SSP_MIS_TXMIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_MIS_RORMIS                          ((uint32_t)0x00000001)
N#define SSP_MIS_RTMIS                           ((uint32_t)0x00000002)
N#define SSP_MIS_RXMIS                           ((uint32_t)0x00000004)
N#define SSP_MIS_TXMIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_MIS */
N
N/** @defgroup Periph_SSP_ICR	SSP ICR
N  * @{
N  */ 
N
N/*-- SSP_ICR: SSP Interrupt Clear Register -------------------------*/
N/* Bit field positions: */
N#define SSP_ICR_RORIC_Pos                       0
N#define SSP_ICR_RTIC_Pos                        1
N
N/* Bit field masks: */
N#define SSP_ICR_RORIC                           ((uint32_t)0x00000001)
N#define SSP_ICR_RTIC                            ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_ICR */
N
N/** @defgroup Periph_SSP_DMACR	SSP DMACR
N  * @{
N  */ 
N
N/*-- SSP_DMACR: SSP DMA Control Register ---------------------------*/
N/* Bit field positions: */
N#define SSP_DMACR_RXDMAE_Pos                    0
N#define SSP_DMACR_TXDMAE_Pos                    1
N
N/* Bit field masks: */
N#define SSP_DMACR_RXDMAE                        ((uint32_t)0x00000001)
N#define SSP_DMACR_TXDMAE                        ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP */
N
N/** @defgroup MDR32Fx_Periph_I2C I2C
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_I2C_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_I2C_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t PRH;
X  volatile uint32_t PRH;
N  __IO uint32_t CTR;
X  volatile uint32_t CTR;
N  __IO uint32_t RXD;
X  volatile uint32_t RXD;
N  __IO uint32_t STA;
X  volatile uint32_t STA;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N}MDR_I2C_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_I2C_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_I2C_CTR	I2C CTR
N  * @{
N  */ 
N
N/*-- I2C_CTR: I2C Control Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CTR_S_I2C_Pos                       5
N#define I2C_CTR_EN_INT_Pos                      6
N#define I2C_CTR_EN_I2C_Pos                      7
N
N/* Bit field masks: */
N#define I2C_CTR_S_I2C                           ((uint32_t)0x00000020)
N#define I2C_CTR_EN_INT                          ((uint32_t)0x00000040)
N#define I2C_CTR_EN_I2C                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CTR */
N
N/** @defgroup Periph_I2C_STA	I2C STA
N  * @{
N  */ 
N
N/*-- I2C_STA: I2C Status Register ----------------------------------*/
N/* Bit field positions: */
N#define I2C_STA_INT_Pos                         0
N#define I2C_STA_TR_PROG_Pos                     1
N#define I2C_STA_LOST_ARB_Pos                    5
N#define I2C_STA_BUSY_Pos                        6
N#define I2C_STA_RX_ACK_Pos                      7
N
N/* Bit field masks: */
N#define I2C_STA_INT                             ((uint32_t)0x00000001)
N#define I2C_STA_TR_PROG                         ((uint32_t)0x00000002)
N#define I2C_STA_LOST_ARB                        ((uint32_t)0x00000020)
N#define I2C_STA_BUSY                            ((uint32_t)0x00000040)
N#define I2C_STA_RX_ACK                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_STA */
N
N/** @defgroup Periph_I2C_CMD	I2C CMD
N  * @{
N  */ 
N
N/*-- I2C_CMD: I2C Command Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CMD_CLRINT_Pos                      0
N#define I2C_CMD_ACK_Pos                         3
N#define I2C_CMD_WR_Pos                          4
N#define I2C_CMD_RD_Pos                          5
N#define I2C_CMD_STOP_Pos                        6
N#define I2C_CMD_START_Pos                       7
N
N/* Bit field masks: */
N#define I2C_CMD_CLRINT                          ((uint32_t)0x00000001)
N#define I2C_CMD_ACK                             ((uint32_t)0x00000008)
N#define I2C_CMD_WR                              ((uint32_t)0x00000010)
N#define I2C_CMD_RD                              ((uint32_t)0x00000020)
N#define I2C_CMD_STOP                            ((uint32_t)0x00000040)
N#define I2C_CMD_START                           ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C */
N
N/** @defgroup MDR32Fx_Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_POWER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N}MDR_POWER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_PVDCS	POWER PVDCS
N  * @{
N  */ 
N
N/*-- POWER_PVDCS: POWER Power Detector Control/Status Register -----*/
N/* Bit field positions: */
N#define POWER_PVDCS_PVDEN_Pos                   0
N#define POWER_PVDCS_PBLS_Pos                    1
N#define POWER_PVDCS_PLS_Pos                     3
N#define POWER_PVDCS_PVBD_Pos                    6
N#define POWER_PVDCS_PVD_Pos                     7
N#define POWER_PVDCS_IEPVBD_Pos                  8
N#define POWER_PVDCS_IEPVD_Pos                   9
N#define POWER_PVDCS_INVB_Pos                    10
N#define POWER_PVDCS_INV_Pos                     11
N
N/* Bit field masks: */
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N#define POWER_PVDCS_PBLS_Msk                    ((uint32_t)0x00000006)
N#define POWER_PVDCS_PLS_Msk                     ((uint32_t)0x00000038)
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N/** @} */ /* End of group POWER_PVDCS */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER */
N
N/** @defgroup MDR32Fx_Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_WWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_WWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_CR	WWDG CR
N  * @{
N  */ 
N
N/*-- WWDG_CR: WWDG Command Register --------------------------------*/
N/* Bit field positions: */
N#define WWDG_CR_T_Pos                           0
N#define WWDG_CR_WDGA_Pos                        7
N
N/* Bit field masks: */
N#define WWDG_CR_T_Msk                           ((uint32_t)0x0000007F)
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N/** @} */ /* End of group WWDG_CR */
N
N/** @defgroup Periph_WWDG_CFR	WWDG CFR
N  * @{
N  */ 
N
N/*-- WWDG_CFR: WWDG Configuration Register -------------------------*/
N/* Bit field positions: */
N#define WWDG_CFR_W_Pos                          0
N#define WWDG_CFR_WGTB_Pos                       7
N#define WWDG_CFR_EWI_Pos                        9
N
N/* Bit field masks: */
N#define WWDG_CFR_W_Msk                          ((uint32_t)0x0000007F)
N#define WWDG_CFR_WGTB_Msk                       ((uint32_t)0x00000180)
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N/* WGTB Modes */
N#define WWDG_CFR_WGTB_NO_DIV										0x00
N#define WWDG_CFR_WGTB_DIV_2											0x01
N#define WWDG_CFR_WGTB_DIV_4											0x02
N#define WWDG_CFR_WGTB_DIV_8											0x03
N
N/** @} */ /* End of group WWDG_CFR */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG */
N
N/** @defgroup MDR32Fx_Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_IWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_IWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_SR	IWDG SR
N  * @{
N  */ 
N
N/*-- IWDG_SR: IWDG Status Register ---------------------------------*/
N/* Bit field positions: */
N#define IWDG_SR_PVU_Pos                         0
N#define IWDG_SR_RVU_Pos                         1
N
N/* Bit field masks: */
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N/* PR Modes */
N#define IWDG_PR_DIV_4														0x00
N#define IWDG_PR_DIV_8														0x01
N#define IWDG_PR_DIV_16													0x02
N#define IWDG_PR_DIV_32													0x03
N#define IWDG_PR_DIV_64													0x04
N#define IWDG_PR_DIV_128													0x05
N#define IWDG_PR_DIV_256													0x06
N
N/* KR Keys */
N#define IWDG_KR_KEY_REG_EN											0x00005555
N#define IWDG_KR_KEY_REWRITE											0x0000AAAA
N#define IWDG_KR_KEY_WORK_EN											0x0000CCCC
N
N/** @} */ /* End of group IWDG_SR */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG */
N
N/** @defgroup MDR32Fx_Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_TIMER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N}MDR_TIMER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_CNTRL	TIMER CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CNTRL: Timer Control Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_CNTRL_CNT_EN_Pos                  0
N#define TIMER_CNTRL_ARRB_EN_Pos                 1
N#define TIMER_CNTRL_WR_CMPL_Pos                 2
N#define TIMER_CNTRL_DIR_Pos                     3
N#define TIMER_CNTRL_FDTS_Pos                    4
N#define TIMER_CNTRL_CNT_MODE_Pos                6
N#define TIMER_CNTRL_EVENT_SEL_Pos               8
N
N/* Bit field masks: */
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N#define TIMER_CNTRL_FDTS_Msk                    ((uint32_t)0x00000030)
N#define TIMER_CNTRL_CNT_MODE_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CNTRL_EVENT_SEL_Msk               ((uint32_t)0x00000F00)
N
N/* FDTS Modes */
N#define TIMER_CNTRL_FDTS_TIM_CLK								0x00
N#define TIMER_CNTRL_FDTS_SECOND_TIM_CLK					0x01
N#define TIMER_CNTRL_FDTS_THIRD_TIM_CLK					0x02
N#define TIMER_CNTRL_FDTS_FOURTH_TIM_CLK					0x03
N
N/* CNT Modes*/
N#define TIMER_CNTRL_CNT_MODE_UP_DIR_0_PSG_0							0x00
N#define TIMER_CNTRL_CNT_MODE_DOWN_DIR_1_PSG_0						0x00
N#define TIMER_CNTRL_CNT_MODE_UP_DOWN_DIR_AUTO_PSG_0			0x01
N#define TIMER_CNTRL_CNT_MODE_UP_DIR_0_EVENT_1						0x02
N#define TIMER_CNTRL_CNT_MODE_DOWN_DIR_1_EVENT_1					0x02
N#define TIMER_CNTRL_CNT_MODE_UP_DOWN_DIR_AUTO_EVENT_1		0x03
N
N/* EVENT SEL Modes */
N#define TIMER_CNTRL_EVENT_SEL_TIM_CLK						0x00
N#define TIMER_CNTRL_EVENT_SEL_CNT_ARR_TIM1			0x01
N#define TIMER_CNTRL_EVENT_SEL_CNT_ARR_TIM2			0x02
N#define TIMER_CNTRL_EVENT_SEL_CNT_ARR_TIM3			0x03
N#define TIMER_CNTRL_EVENT_SEL_CH1_MODE1					0x04
N#define TIMER_CNTRL_EVENT_SEL_CH2_MODE1					0x05
N#define TIMER_CNTRL_EVENT_SEL_CH3_MODE1					0x06
N#define TIMER_CNTRL_EVENT_SEL_CH4_MODE1					0x07
N#define TIMER_CNTRL_EVENT_SEL_ETR_MODE2					0x08
N
N/** @} */ /* End of group TIMER_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL	TIMER CH CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL: Timer Channel Control Register ----------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL_CHFLTR_Pos               0
N#define TIMER_CH_CNTRL_CHSEL_Pos                4
N#define TIMER_CH_CNTRL_CHPSC_Pos                6
N#define TIMER_CH_CNTRL_OCCE_Pos                 8
N#define TIMER_CH_CNTRL_OCCM_Pos                 9
N#define TIMER_CH_CNTRL_BRKEN_Pos                12
N#define TIMER_CH_CNTRL_ETREN_Pos                13
N#define TIMER_CH_CNTRL_WR_CMPL_Pos              14
N#define TIMER_CH_CNTRL_CAP_NPWM_Pos             15
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL_CHFLTR_Msk               ((uint32_t)0x0000000F)
N#define TIMER_CH_CNTRL_CHSEL_Msk                ((uint32_t)0x00000030)
N#define TIMER_CH_CNTRL_CHPSC_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N#define TIMER_CH_CNTRL_OCCM_Msk                 ((uint32_t)0x00000E00)
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N#define TIMER_CH_CNTRL_CAP_NPWM                 ((uint32_t)0x00008000)
N
N/* CHFLTR Modes */
N#define TIMER_CH_CNTRL_CHFLTR_1_TRG_TIM_CLK							0x00
N#define TIMER_CH_CNTRL_CHFLTR_2_TRG_TIM_CLK							0x01
N#define TIMER_CH_CNTRL_CHFLTR_4_TRG_TIM_CLK							0x02
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_TIM_CLK							0x03
N#define TIMER_CH_CNTRL_CHFLTR_6_TRG_FDTS_DIV_2					0x04
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_FDTS_DIV_2					0x05
N#define TIMER_CH_CNTRL_CHFLTR_6_TRG_FDTS_DIV_4					0x06
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_FDTS_DIV_4					0x07
N#define TIMER_CH_CNTRL_CHFLTR_6_TRG_FDTS_DIV_8					0x08
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_FDTS_DIV_8					0x09
N#define TIMER_CH_CNTRL_CHFLTR_5_TRG_FDTS_DIV_16					0x0A
N#define TIMER_CH_CNTRL_CHFLTR_6_TRG_FDTS_DIV_16					0x0B
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_FDTS_DIV_16					0x0C
N#define TIMER_CH_CNTRL_CHFLTR_5_TRG_FDTS_DIV_32					0x0D
N#define TIMER_CH_CNTRL_CHFLTR_6_TRG_FDTS_DIV_32					0x0E
N#define TIMER_CH_CNTRL_CHFLTR_8_TRG_FDTS_DIV_32					0x0F
N
N/* CHSEL Modes */
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE										0x00
N#define TIMER_CH_CNTRL_CHSEL_NEG_EDGE										0x01
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH1_FROM_CH2			0x02
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH2_FROM_CH3			0x02
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH3_FROM_CH4			0x02
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH4_FROM_CH1			0x02
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH1_FROM_CH3			0x03
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH2_FROM_CH4			0x03
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH3_FROM_CH1			0x03
N#define TIMER_CH_CNTRL_CHSEL_POS_EDGE_CH4_FROM_CH2			0x03
N
N/* CHPSC Modes */
N#define TIMER_CH_CNTRL_CHPSC_NO_DIV											0x00
N#define TIMER_CH_CNTRL_CHPSC_DIV_2											0x01
N#define TIMER_CH_CNTRL_CHPSC_DIV_4											0x02
N#define TIMER_CH_CNTRL_CHPSC_DIV_8											0x03
N
N/* OCCM Modes */
N// CCR1 EN = 0
N#define TIMER_CH_CNTRL_OCCM_REF_0												0x00
N#define TIMER_CH_CNTRL_OCCM_REF_1_CNT_CCR								0x01
N#define TIMER_CH_CNTRL_OCCM_REF_0_CNT_CCR								0x02
N#define TIMER_CH_CNTRL_OCCM_SW_REF_CNT_CCR							0x03
N#define TIMER_CH_CNTRL_OCCM_REF_1												0x05
N#define TIMER_CH_CNTRL_OCCM_REF_1_DIR_0_CNT_CCR					0x06
N#define TIMER_CH_CNTRL_OCCM_REF_0_DIR_1_CNT_CCR					0x06
N#define TIMER_CH_CNTRL_OCCM_REF_0_DIR_0_CNT_CCR					0x07
N#define TIMER_CH_CNTRL_OCCM_REF_1_DIR_1_CNT_CCR					0x07
N// CCR1 EN = 1
N#define TIMER_CH_CNTRL_OCCM_REF_0												0x00
N#define TIMER_CH_CNTRL_OCCM_REF_1_CNT_CCR_OR_CNT_CCR1		0x01
N#define TIMER_CH_CNTRL_OCCM_REF_0_CNT_CCR_OR_CNT_CCR1		0x02
N#define TIMER_CH_CNTRL_OCCM_SW_REF_CNT_CCR							0x03
N#define TIMER_CH_CNTRL_OCCM_REF_1												0x05
N#define TIMER_CH_CNTRL_OCCM_REF_1_DIR_0_CCR1_CNT_CCR		0x06
N#define TIMER_CH_CNTRL_OCCM_REF_0_DIR_1_CCR_CNT_CCR1		0x06
N#define TIMER_CH_CNTRL_OCCM_REF_0_DIR_0_CCR1_CNT_CCR		0x07
N#define TIMER_CH_CNTRL_OCCM_REF_1_DIR_1_CCR_CNT_CCR1		0x07
N
N/** @} */ /* End of group TIMER_CH_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL1	TIMER CH CNTRL1
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL1: Timer Channel Control1 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL1_SELOE_Pos               0
N#define TIMER_CH_CNTRL1_SELO_Pos                2
N#define TIMER_CH_CNTRL1_INV_Pos                 4
N#define TIMER_CH_CNTRL1_NSELOE_Pos              8
N#define TIMER_CH_CNTRL1_NSELO_Pos               10
N#define TIMER_CH_CNTRL1_NINV_Pos                12
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL1_SELOE_Msk               ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL1_SELO_Msk                ((uint32_t)0x0000000C)
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N#define TIMER_CH_CNTRL1_NSELOE_Msk              ((uint32_t)0x00000300)
N#define TIMER_CH_CNTRL1_NSELO_Msk               ((uint32_t)0x00000C00)
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N/* SELOE Modes */
N#define TIMER_CH_CNTRL1_SELOE_OUT_DIS						0x00
N#define TIMER_CH_CNTRL1_SELOE_OUT_EN						0x01
N#define TIMER_CH_CNTRL1_SELOE_OUT_REF_Z_OUT			0x02
N#define TIMER_CH_CNTRL1_SELOE_OUT_DTG_Z_OUT			0x03
N
N/* SELO Modes */
N#define TIMER_CH_CNTRL1_SELO_OUT_0							0x00
N#define TIMER_CH_CNTRL1_SELO_OUT_1							0x01
N#define TIMER_CH_CNTRL1_SELO_OUT_REF						0x02
N#define TIMER_CH_CNTRL1_SELO_OUT_DTG						0x03
N
N/** @} */ /* End of group TIMER_CH_CNTRL1 */
N
N/** @defgroup Periph_TIMER_CH_DTG	TIMER CH DTG
N  * @{
N  */ 
N
N/*-- TIMER_CH_DTG: Timer Channel DTG Register ----------------------*/
N/* Bit field positions: */
N#define TIMER_CH_DTGX_Pos                       0
N#define TIMER_CH_DTG_EDTS_Pos                   4
N#define TIMER_CH_DTG_Pos                        8
N
N/* Bit field masks: */
N#define TIMER_CH_DTGX_Msk                       ((uint32_t)0x0000000F)
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N#define TIMER_CH_DTG_Msk                        ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group TIMER_CH_DTG */
N
N/** @defgroup Periph_TIMER_BRKETR_CNTRL	TIMER BRKETR CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_BRKETR_CNTRL: Timer BRK/ETR Control Register ------------*/
N/* Bit field positions: */
N#define TIMER_BRKETR_CNTRL_BRK_INV_Pos          0
N#define TIMER_BRKETR_CNTRL_ETR_INV_Pos          1
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Pos          2
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Pos       4
N
N/* Bit field masks: */
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Msk          ((uint32_t)0x0000000C)
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Msk       ((uint32_t)0x000000F0)
N
N/* ETR PSC Modes */
N#define TIMER_BRKETR_CNTRL_ETR_PSC_NO_DIV				0x00
N#define TIMER_BRKETR_CNTRL_ETR_PSC_DIV_2				0x01
N#define TIMER_BRKETR_CNTRL_ETR_PSC_DIV_4				0x02
N#define TIMER_BRKETR_CNTRL_ETR_PSC_DIV_8				0x03
N
N/* ETR FILTER Modes */
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_1_TRG_TIM_CLK							0x00
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_2_TRG_TIM_CLK							0x01
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_4_TRG_TIM_CLK							0x02
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_TIM_CLK							0x03
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_6_TRG_FDTS_DIV_2					0x04
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_FDTS_DIV_2					0x05
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_6_TRG_FDTS_DIV_4					0x06
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_FDTS_DIV_4					0x07
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_6_TRG_FDTS_DIV_8					0x08
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_FDTS_DIV_8					0x09
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_5_TRG_FDTS_DIV_16					0x0A
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_6_TRG_FDTS_DIV_16					0x0B
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_FDTS_DIV_16					0x0C
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_5_TRG_FDTS_DIV_32					0x0D
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_6_TRG_FDTS_DIV_32					0x0E
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_8_TRG_FDTS_DIV_32					0x0F
N
N/** @} */ /* End of group TIMER_BRKETR_CNTRL */
N
N/** @defgroup Periph_TIMER_STATUS	TIMER STATUS
N  * @{
N  */ 
N
N/*-- TIMER_STATUS: Timer Status Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_STATUS_CNT_ZERO_EVENT_Pos         0
N#define TIMER_STATUS_CNT_ARR_EVENT_Pos          1
N#define TIMER_STATUS_ETR_RE_EVENT_Pos           2
N#define TIMER_STATUS_ETR_FE_EVENT_Pos           3
N#define TIMER_STATUS_BRK_EVENT_Pos              4
N#define TIMER_STATUS_CCR_CAP_EVENT_Pos          5
N#define TIMER_STATUS_CCR_REF_EVENT_Pos          9
N#define TIMER_STATUS_CCR1_CAP_EVENT_Pos         13
N
N/* Bit field masks: */
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N#define TIMER_STATUS_CCR_CAP_EVENT_Msk          ((uint32_t)0x000001E0)
N#define TIMER_STATUS_CCR_REF_EVENT_Msk          ((uint32_t)0x00001E00)
N#define TIMER_STATUS_CCR1_CAP_EVENT_Msk         ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_STATUS */
N
N/** @defgroup Periph_TIMER_IE	TIMER IE
N  * @{
N  */ 
N
N/*-- TIMER_IE: Timer Interrupt Enable Register ---------------------*/
N/* Bit field positions: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE_Pos          0
N#define TIMER_IE_CNT_ARR_EVENT_IE_Pos           1
N#define TIMER_IE_ETR_RE_EVENT_IE_Pos            2
N#define TIMER_IE_ETR_FE_EVENT_IE_Pos            3
N#define TIMER_IE_BRK_EVENT_IE_Pos               4
N#define TIMER_IE_CCR_CAP_EVENT_IE_Pos           5
N#define TIMER_IE_CCR_REF_EVENT_IE_Pos           9
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Pos          13
N
N/* Bit field masks: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N#define TIMER_IE_CCR_CAP_EVENT_IE_Msk           ((uint32_t)0x000001E0)
N#define TIMER_IE_CCR_REF_EVENT_IE_Msk           ((uint32_t)0x00001E00)
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Msk          ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_IE */
N
N/** @defgroup Periph_TIMER_DMA_RE	TIMER DMA RE
N  * @{
N  */ 
N
N/*-- TIMER_DMA_RE: Timer DMA Request Enable Register ---------------*/
N/* Bit field positions: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_Pos      0
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_Pos       1
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_Pos        2
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_Pos        3
N#define TIMER_DMA_RE_BRK_EVENT_RE_Pos           4
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Pos       5
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Pos       9
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Pos      13
N
N/* Bit field masks: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Msk       ((uint32_t)0x000001E0)
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Msk       ((uint32_t)0x00001E00)
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Msk      ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_DMA_RE */
N
N/** @defgroup Periph_TIMER_CH_CNTRL2	TIMER CH CNTRL2
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL2: Timer Channel Control2 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL2_CHSEL1_Pos              0
N#define TIMER_CH_CNTRL2_CCR1_EN_Pos             2
N#define TIMER_CH_CNTRL2_CCRRLD_Pos              3
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL2_CHSEL1_Msk              ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N/* CHSEL1 Modes */
N#define TIMER_CH_CNTRL2_CHSEL1_POS_EDGE										0x00
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE										0x01
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH1_FROM_CH2			0x02
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH2_FROM_CH3			0x02
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH3_FROM_CH4			0x02
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH4_FROM_CH1			0x02
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH1_FROM_CH3			0x03
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH2_FROM_CH4			0x03
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH3_FROM_CH1			0x03
N#define TIMER_CH_CNTRL2_CHSEL1_NEG_EDGE_CH4_FROM_CH2			0x03
N
N/** @} */ /* End of group TIMER_CH_CNTRL2 */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER */
N
N/** @defgroup MDR32Fx_Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_ADC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N}MDR_ADC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC1_CFG	ADC1 CFG
N  * @{
N  */
N
N/*-- ADC1_CFG: ADC1 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC1_CFG_REG_ADON_Pos                   0
N#define ADC1_CFG_REG_GO_Pos                     1
N#define ADC1_CFG_REG_CLKS_Pos                   2
N#define ADC1_CFG_REG_SAMPLE_Pos                 3
N#define ADC1_CFG_REG_CHS_Pos                    4
N#define ADC1_CFG_REG_CHCH_Pos                   9
N#define ADC1_CFG_REG_RNGC_Pos                   10
N#define ADC1_CFG_M_REF_Pos                      11
N#define ADC1_CFG_REG_DIVCLK_Pos                 12
N#define ADC1_CFG_SYNC_CONVER_Pos                16
N#define ADC1_CFG_TS_EN_Pos                      17
N#define ADC1_CFG_TS_BUF_EN_Pos                  18
N#define ADC1_CFG_SEL_TS_Pos                     19
N#define ADC1_CFG_SEL_VREF_Pos                   20
N#define ADC1_CFG_TR_Pos                         21
N#define ADC1_CFG_DELAY_GO_Pos                   25
N#define ADC1_CFG_DELAY_ADC_Pos                  28
N
N/* Bit field masks: */
N#define ADC1_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC1_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC1_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC1_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC1_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC1_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC1_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC1_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC1_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC1_CFG_SYNC_CONVER                    ((uint32_t)0x00010000)
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N#define ADC1_CFG_TR_Msk                         ((uint32_t)0x01E00000)
N#define ADC1_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N#define ADC1_CFG_DELAY_ADC_Msk                  ((uint32_t)0xF0000000)
N
N/* Delay Go Modes */
N#define ADC1_CFG_DELAY_GO_1_CPU_CLK							0x00
N#define ADC1_CFG_DELAY_GO_2_CPU_CLK							0x01
N#define ADC1_CFG_DELAY_GO_3_CPU_CLK							0x02
N#define ADC1_CFG_DELAY_GO_4_CPU_CLK							0x03
N#define ADC1_CFG_DELAY_GO_5_CPU_CLK							0x04
N#define ADC1_CFG_DELAY_GO_6_CPU_CLK							0x05
N#define ADC1_CFG_DELAY_GO_7_CPU_CLK							0x06
N#define ADC1_CFG_DELAY_GO_8_CPU_CLK							0x07
N
N/* Delay ADC Modes */
N#define ADC1_CFG_DELAY_ADC_1_CPU_CLK						0x00
N#define ADC1_CFG_DELAY_ADC_2_CPU_CLK						0x01
N#define ADC1_CFG_DELAY_ADC_3_CPU_CLK						0x02
N#define ADC1_CFG_DELAY_ADC_4_CPU_CLK						0x03
N#define ADC1_CFG_DELAY_ADC_5_CPU_CLK						0x04
N#define ADC1_CFG_DELAY_ADC_6_CPU_CLK						0x05
N#define ADC1_CFG_DELAY_ADC_7_CPU_CLK						0x06
N#define ADC1_CFG_DELAY_ADC_8_CPU_CLK						0x07
N#define ADC1_CFG_DELAY_ADC_9_CPU_CLK						0x08
N#define ADC1_CFG_DELAY_ADC_10_CPU_CLK						0x09
N#define ADC1_CFG_DELAY_ADC_11_CPU_CLK						0x0A
N#define ADC1_CFG_DELAY_ADC_12_CPU_CLK						0x0B
N#define ADC1_CFG_DELAY_ADC_13_CPU_CLK						0x0C
N#define ADC1_CFG_DELAY_ADC_14_CPU_CLK						0x0D
N#define ADC1_CFG_DELAY_ADC_15_CPU_CLK						0x0E
N#define ADC1_CFG_DELAY_ADC_16_CPU_CLK						0x0F
N
N/** @} */ /* End of group ADC1_CFG */
N
N/** @defgroup Periph_ADC2_CFG	ADC2 CFG
N  * @{
N  */ 
N
N/*-- ADC2_CFG: ADC2 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC2_CFG_REG_ADON_Pos                   0
N#define ADC2_CFG_REG_GO_Pos                     1
N#define ADC2_CFG_REG_CLKS_Pos                   2
N#define ADC2_CFG_REG_SAMPLE_Pos                 3
N#define ADC2_CFG_REG_CHS_Pos                    4
N#define ADC2_CFG_REG_CHCH_Pos                   9
N#define ADC2_CFG_REG_RNGC_Pos                   10
N#define ADC2_CFG_M_REF_Pos                      11
N#define ADC2_CFG_REG_DIVCLK_Pos                 12
N#define ADC2_CFG_ADC1_OP_Pos                    17
N#define ADC2_CFG_ADC2_OP_Pos                    18
N#define ADC2_CFG_DELAY_GO_Pos                   25
N
N/* Bit field masks: */
N#define ADC2_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC2_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC2_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC2_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC2_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC2_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC2_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC2_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC2_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N#define ADC2_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N
N/* Delay Go Modes */
N#define ADC2_CFG_DELAY_GO_0_CPU_CLK							0x00
N#define ADC2_CFG_DELAY_GO_1_CPU_CLK							0x01
N#define ADC2_CFG_DELAY_GO_2_CPU_CLK							0x02
N#define ADC2_CFG_DELAY_GO_3_CPU_CLK							0x03
N#define ADC2_CFG_DELAY_GO_4_CPU_CLK							0x04
N#define ADC2_CFG_DELAY_GO_5_CPU_CLK							0x05
N#define ADC2_CFG_DELAY_GO_6_CPU_CLK							0x06
N#define ADC2_CFG_DELAY_GO_7_CPU_CLK							0x07
N
N/** @} */ /* End of group ADC2_CFG */
N
N/* CFG REG CHS Modes */
N#define ADC_CFG_REG_CHS_VREF										30
N#define ADC_CFG_REG_CHS_TS											31
N
N/* CFG REG DIVCLK Modes*/
N#define ADC_CFG_REG_DIVCLK_HCLK									0x00
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_2						0x01
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_4						0x02
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_8						0x03
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_16					0x04
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_32					0x05
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_64					0x06
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_128					0x07
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_256					0x08
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_512					0x09
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_1024				0x0A
N#define ADC_CFG_REG_DIVCLK_HCLK_DIV_2048				0x0B
N
N/** @defgroup Periph_ADC1_RESULT	ADC1 RESULT
N  * @{
N  */
N
N/*-- ADC1_RESULT: ADC1 Result Register -----------------------------*/
N/*-- ADC2_RESULT: ADC2 Result Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_RESULT_Pos                          0
N#define ADC_RESULT_CHANNEL_Pos                  16
N
N/* Bit field masks: */
N#define ADC_RESULT_Msk                          ((uint32_t)0x00000FFF)
N#define ADC_RESULT_CHANNEL_Msk                  ((uint32_t)0x001F0000)
N
N/** @} */ /* End of group ADC1_RESULT */
N
N/** @defgroup Periph_ADC1_STATUS	ADC1 STATUS
N  * @{
N  */ 
N
N/*-- ADC1_STATUS: ADC1 Status Register -----------------------------*/
N/*-- ADC2_STATUS: ADC2 Status Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_STATUS_FLG_REG_OVERWRITE_Pos        0
N#define ADC_STATUS_FLG_REG_AWOIFEN_Pos          1
N#define ADC_STATUS_FLG_REG_EOCIF_Pos            2
N#define ADC_STATUS_AWOIF_IE_Pos                 3
N#define ADC_STATUS_ECOIF_IE_Pos                 4
N
N/* Bit field masks: */
N#define ADC_STATUS_FLG_REG_OVERWRITE            ((uint32_t)0x00000001)
N#define ADC_STATUS_FLG_REG_AWOIFEN              ((uint32_t)0x00000002)
N#define ADC_STATUS_FLG_REG_EOCIF                ((uint32_t)0x00000004)
N#define ADC_STATUS_AWOIF_IE                     ((uint32_t)0x00000008)
N#define ADC_STATUS_ECOIF_IE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group ADC1_STATUS */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC */
N
N/** @defgroup MDR32Fx_Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DAC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N}MDR_DAC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_CFG	DAC CFG
N  * @{
N  */ 
N
N/*-- DAC_CFG: DAC Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DAC_CFG_M_REF0_Pos                      0
N#define DAC_CFG_M_REF1_Pos                      1
N#define DAC_CFG_ON_DAC0_Pos                     2
N#define DAC_CFG_ON_DAC1_Pos                     3
N#define DAC_CFG_SYNC_A_Pos                      4
N
N/* Bit field masks: */
N#define DAC_CFG_M_REF0                          ((uint32_t)0x00000001)
N#define DAC_CFG_M_REF1                          ((uint32_t)0x00000002)
N#define DAC_CFG_ON_DAC0                         ((uint32_t)0x00000004)
N#define DAC_CFG_ON_DAC1                         ((uint32_t)0x00000008)
N#define DAC_CFG_SYNC_A                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group DAC_CFG */
N
N/** @defgroup Periph_DAC1_DATA	DAC1 DATA
N  * @{
N  */ 
N
N/*-- DAC1_DATA: DAC1 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC1_DATA_DAC0DATA_Pos                  0
N#define DAC1_DATA_DAC1DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC1_DATA_DAC0DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC1_DATA_DAC1DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC1_DATA */
N
N/** @defgroup Periph_DAC2_DATA	DAC2 DATA
N  * @{
N  */ 
N
N/*-- DAC2_DATA: DAC2 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC2_DATA_DAC1DATA_Pos                  0
N#define DAC2_DATA_DAC0DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC2_DATA_DAC1DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC2_DATA_DAC0DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC2_DATA */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC */
N
N/** @defgroup MDR32Fx_Periph_COMP COMP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_COMP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_COMP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t RESULT;
X  volatile uint32_t RESULT;
N  __IO uint32_t RESULT_LATCH;
X  volatile uint32_t RESULT_LATCH;
N}MDR_COMP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_COMP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_COMP_CFG	COMP CFG
N  * @{
N  */ 
N
N/*-- COMP_CFG: COMP Configuration Register -------------------------*/
N/* Bit field positions: */
N#define COMP_CFG_ON_Pos                         0
N#define COMP_CFG_CVRR_Pos                       1
N#define COMP_CFG_CVRSS_Pos                      2
N#define COMP_CFG_CVREN_Pos                      3
N#define COMP_CFG_CVR_Pos                        4
N#define COMP_CFG_CREF_Pos                       8
N#define COMP_CFG_CCH_Pos                        9
N#define COMP_CFG_INV_Pos                        11
N#define COMP_CFG_READY_Pos                      12
N#define COMP_CFG_CMPIE_Pos                      13
N
N/* Bit field masks: */
N#define COMP_CFG_ON                             ((uint32_t)0x00000001)
N#define COMP_CFG_CVRR                           ((uint32_t)0x00000002)
N#define COMP_CFG_CVRSS                          ((uint32_t)0x00000004)
N#define COMP_CFG_CVREN                          ((uint32_t)0x00000008)
N#define COMP_CFG_CVR_Msk                        ((uint32_t)0x000000F0)
N#define COMP_CFG_CREF                           ((uint32_t)0x00000100)
N#define COMP_CFG_CCH_Msk                        ((uint32_t)0x00000600)
N#define COMP_CFG_INV                            ((uint32_t)0x00000800)
N#define COMP_CFG_READY                          ((uint32_t)0x00001000)
N#define COMP_CFG_CMPIE                          ((uint32_t)0x00002000)
N
N/* COMP CFG CCH Modes */
N#define COMP_CFG_CCH_NEG_IN_2										0x00
N#define COMP_CFG_CCH_NEG_IN_1										0x01
N#define COMP_CFG_CCH_NEG_IN_3										0x02
N#define COMP_CFG_CCH_NEG_IVREF									0x03
N
N/** @} */ /* End of group COMP_CFG */
N
N/** @defgroup Periph_COMP_RESULT	COMP RESULT
N  * @{
N  */ 
N
N/*-- COMP_RESULT: COMP Result Register -----------------------------*/
N/* Bit field positions: */
N#define COMP_RESULT_RSLT_SY_Pos                 0
N#define COMP_RESULT_RSLT_AS_Pos                 1
N#define COMP_RESULT_RST_LCH_Pos                 2
N
N/* Bit field masks: */
N#define COMP_RESULT_RSLT_SY                     ((uint32_t)0x00000001)
N#define COMP_RESULT_RSLT_AS                     ((uint32_t)0x00000002)
N#define COMP_RESULT_RST_LCH                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group COMP_RESULT */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP */
N
N/** @defgroup MDR32Fx_Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_PORT_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N}MDR_PORT_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_FUNC	PORT FUNC
N  * @{
N  */ 
N
N/*-- PORT_FUNC: PORT Function Register -----------------------------*/
N/* Bit field positions: */
N#define PORT_FUNC_MODE0_Pos                     0
N#define PORT_FUNC_MODE1_Pos                     2
N#define PORT_FUNC_MODE2_Pos                     4
N#define PORT_FUNC_MODE3_Pos                     6
N#define PORT_FUNC_MODE4_Pos                     8
N#define PORT_FUNC_MODE5_Pos                     10
N#define PORT_FUNC_MODE6_Pos                     12
N#define PORT_FUNC_MODE7_Pos                     14
N#define PORT_FUNC_MODE8_Pos                     16
N#define PORT_FUNC_MODE9_Pos                     18
N#define PORT_FUNC_MODE10_Pos                    20
N#define PORT_FUNC_MODE11_Pos                    22
N#define PORT_FUNC_MODE12_Pos                    24
N#define PORT_FUNC_MODE13_Pos                    26
N#define PORT_FUNC_MODE14_Pos                    28
N#define PORT_FUNC_MODE15_Pos                    30
N
N/* Bit field masks: */
N#define PORT_FUNC_MODE_Msk											3U
N#define PORT_FUNC_MODE0_Msk                     ((uint32_t)0x00000003)
N#define PORT_FUNC_MODE1_Msk                     ((uint32_t)0x0000000C)
N#define PORT_FUNC_MODE2_Msk                     ((uint32_t)0x00000030)
N#define PORT_FUNC_MODE3_Msk                     ((uint32_t)0x000000C0)
N#define PORT_FUNC_MODE4_Msk                     ((uint32_t)0x00000300)
N#define PORT_FUNC_MODE5_Msk                     ((uint32_t)0x00000C00)
N#define PORT_FUNC_MODE6_Msk                     ((uint32_t)0x00003000)
N#define PORT_FUNC_MODE7_Msk                     ((uint32_t)0x0000C000)
N#define PORT_FUNC_MODE8_Msk                     ((uint32_t)0x00030000)
N#define PORT_FUNC_MODE9_Msk                     ((uint32_t)0x000C0000)
N#define PORT_FUNC_MODE10_Msk                    ((uint32_t)0x00300000)
N#define PORT_FUNC_MODE11_Msk                    ((uint32_t)0x00C00000)
N#define PORT_FUNC_MODE12_Msk                    ((uint32_t)0x03000000)
N#define PORT_FUNC_MODE13_Msk                    ((uint32_t)0x0C000000)
N#define PORT_FUNC_MODE14_Msk                    ((uint32_t)0x30000000)
N#define PORT_FUNC_MODE15_Msk                    ((uint32_t)0xC0000000)
N
N/* PORT FUNC Modes */
N#define PORT_FUNC_MODE_PORT		0U
N#define PORT_FUNC_MODE_MAIN		1U
N#define PORT_FUNC_MODE_ALT		2U
N#define PORT_FUNC_MODE_OVER		3U
N
N/** @} */ /* End of group PORT_FUNC */
N
N/** @defgroup Periph_PORT_PULL	PORT PULL
N  * @{
N  */ 
N
N/*-- PORT_PULL: PORT Pull Up/Down Register -------------------------*/
N/* Bit field positions: */
N#define PORT_PULL_DOWN_Pos                      0
N#define PORT_PULL_UP_Pos                        16
N
N/* Bit field masks: */
N#define PORT_PULL_DOWN_Msk                      ((uint32_t)0x0000FFFF)
N#define PORT_PULL_UP_Msk                        ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PULL */
N
N/** @defgroup Periph_PORT_PD	PORT PD
N  * @{
N  */ 
N
N/*-- PORT_PD: PORT Driver Mode Register ----------------------------*/
N/* Bit field positions: */
N#define PORT_PD_Pos                             0
N#define PORT_PD_SHM_Pos                         16
N
N/* Bit field masks: */
N#define PORT_PD_Msk                             ((uint32_t)0x0000FFFF)
N#define PORT_PD_SHM_Msk                         ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PD */
N
N/** @defgroup Periph_PORT_PWR	PORT PWR
N  * @{
N  */ 
N
N/*-- PORT_PWR: PORT Power Register ---------------------------------*/
N/* Bit field positions: */
N#define PORT_PWR0_Pos                           0
N#define PORT_PWR1_Pos                           2
N#define PORT_PWR2_Pos                           4
N#define PORT_PWR3_Pos                           6
N#define PORT_PWR4_Pos                           8
N#define PORT_PWR5_Pos                           10
N#define PORT_PWR6_Pos                           12
N#define PORT_PWR7_Pos                           14
N#define PORT_PWR8_Pos                           16
N#define PORT_PWR9_Pos                           18
N#define PORT_PWR10_Pos                          20
N#define PORT_PWR11_Pos                          22
N#define PORT_PWR12_Pos                          24
N#define PORT_PWR13_Pos                          26
N#define PORT_PWR14_Pos                          28
N#define PORT_PWR15_Pos                          30
N
N/* Bit field masks: */
N#define PORT_PWR_Msk														3U
N#define PORT_PWR0_Msk                           ((uint32_t)0x00000003)
N#define PORT_PWR1_Msk                           ((uint32_t)0x0000000C)
N#define PORT_PWR2_Msk                           ((uint32_t)0x00000030)
N#define PORT_PWR3_Msk                           ((uint32_t)0x000000C0)
N#define PORT_PWR4_Msk                           ((uint32_t)0x00000300)
N#define PORT_PWR5_Msk                           ((uint32_t)0x00000C00)
N#define PORT_PWR6_Msk                           ((uint32_t)0x00003000)
N#define PORT_PWR7_Msk                           ((uint32_t)0x0000C000)
N#define PORT_PWR8_Msk                           ((uint32_t)0x00030000)
N#define PORT_PWR9_Msk                           ((uint32_t)0x000C0000)
N#define PORT_PWR10_Msk                          ((uint32_t)0x00300000)
N#define PORT_PWR11_Msk                          ((uint32_t)0x00C00000)
N#define PORT_PWR12_Msk                          ((uint32_t)0x03000000)
N#define PORT_PWR13_Msk                          ((uint32_t)0x0C000000)
N#define PORT_PWR14_Msk                          ((uint32_t)0x30000000)
N#define PORT_PWR15_Msk                          ((uint32_t)0xC0000000)
N
N/* PORT PWR Modes */
N#define PORT_PWR_OFF				0U
N#define PORT_PWR_SLOW				1U
N#define PORT_PWR_FAST				2U
N#define PORT_PWR_MAX_FAST		3U
N
N/** @} */ /* End of group PORT_PWR */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT */
N
N/** @defgroup MDR32Fx_Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_BKP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N}MDR_BKP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_REG_0E	BKP REG 0E
N  * @{
N  */ 
N
N/*-- BKP_REG_0E: Backup Register 14 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0E_LOW_Pos                      0
N#define BKP_REG_0E_SELECTRI_Pos                 3
N#define BKP_REG_0E_JTAGA_Pos                    6
N#define BKP_REG_0E_JTAGB_Pos                    7
N#define BKP_REG_0E_TRIM_Pos                     8
N#define BKP_REG_0E_FPOR_Pos                     11
N#define BKP_REG_0E_BKP_REG_Pos                  12
N
N/* Bit field masks: */
N#define BKP_REG_0E_LOW_Msk                      ((uint32_t)0x00000007)
N#define BKP_REG_0E_SELECTRI_Msk                 ((uint32_t)0x00000038)
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N#define BKP_REG_0E_TRIM_Msk                     ((uint32_t)0x00000700)
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N#define BKP_REG_0E_BKP_REG_Msk                  ((uint32_t)0xFFFFF000)
N
N/** @} */ /* End of group BKP_REG_0E */
N
N/** @defgroup Periph_BKP_REG_0F	BKP REG 0F
N  * @{
N  */ 
N
N/*-- BKP_REG_0F: Backup Register 15 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0F_LSE_ON_Pos                   0
N#define BKP_REG_0F_LSE_BYP_Pos                  1
N#define BKP_REG_0F_RTC_SEL_Pos                  2
N#define BKP_REG_0F_RTC_EN_Pos                   4
N#define BKP_REG_0F_CAL_Pos                      5
N#define BKP_REG_0F_LSE_RDY_Pos                  13
N#define BKP_REG_0F_BKP_REG_Pos                  14
N#define BKP_REG_0F_LSI_ON_Pos                   15
N#define BKP_REG_0F_LSI_TRIM_Pos                 16
N#define BKP_REG_0F_LSI_RDY_Pos                  21
N#define BKP_REG_0F_HSI_ON_Pos                   22
N#define BKP_REG_0F_HSI_RDY_Pos                  23
N#define BKP_REG_0F_HSI_TRIM_Pos                 24
N#define BKP_REG_0F_STANDBY_Pos                  30
N#define BKP_REG_0F_RTC_RESET_Pos                31
N
N/* Bit field masks: */
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N#define BKP_REG_0F_RTC_SEL_Msk                  ((uint32_t)0x0000000C)
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N#define BKP_REG_0F_CAL_Msk                      ((uint32_t)0x00001FE0)
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N#define BKP_REG_0F_LSI_TRIM_Msk                 ((uint32_t)0x001F0000)
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N#define BKP_REG_0F_HSI_TRIM_Msk                 ((uint32_t)0x3F000000)
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N/** @} */ /* End of group BKP_REG_0F */
N
N/** @defgroup Periph_BKP_RTC_CS	BKP RTC CS
N  * @{
N  */ 
N
N/*-- BKP_RTC_CS: Backup Realtime clock Register --------------------*/
N/* Bit field positions: */
N#define BKP_RTC_CS_OWF_Pos                      0
N#define BKP_RTC_CS_SECF_Pos                     1
N#define BKP_RTC_CS_ALRF_Pos                     2
N#define BKP_RTC_CS_OWF_IE_Pos                   3
N#define BKP_RTC_CS_SECF_IE_Pos                  4
N#define BKP_RTC_CS_ALRF_IE_Pos                  5
N#define BKP_RTC_CS_WEC_Pos                      6
N
N/* Bit field masks: */
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N/** @} */ /* End of group BKP_RTC_CS */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP */
N
N/** @defgroup MDR32Fx_Periph_EBC EBC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EBC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EBC_TypeDef structure */
Ntypedef struct
N{
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N#if defined (USE_MDR1986VE94)
X#if 0L
S  __IO uint32_t MEM_REGION[4];
N#endif
N}MDR_EBC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EBC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EBC_NAND_CYCLES	EBC NAND CYCLES
N  * @{
N  */ 
N
N/*-- EBC_NAND_CYCLES: EBC NAND Timing Register ---------------------*/
N/* Bit field positions: */
N#define EBC_NAND_CYCLES_TRC_Pos                 0
N#define EBC_NAND_CYCLES_TWC_Pos                 4
N#define EBC_NAND_CYCLES_TREA_Pos                8
N#define EBC_NAND_CYCLES_TWP_Pos                 12
N#define EBC_NAND_CYCLES_TWHR_Pos                16
N#define EBC_NAND_CYCLES_TALEA_Pos               20
N#define EBC_NAND_CYCLES_TRR_Pos                 24
N
N/* Bit field masks: */
N#define EBC_NAND_CYCLES_TRC_Msk                 ((uint32_t)0x0000000F)
N#define EBC_NAND_CYCLES_TWC_Msk                 ((uint32_t)0x000000F0)
N#define EBC_NAND_CYCLES_TREA_Msk                ((uint32_t)0x00000F00)
N#define EBC_NAND_CYCLES_TWP_Msk                 ((uint32_t)0x0000F000)
N#define EBC_NAND_CYCLES_TWHR_Msk                ((uint32_t)0x000F0000)
N#define EBC_NAND_CYCLES_TALEA_Msk               ((uint32_t)0x00F00000)
N#define EBC_NAND_CYCLES_TRR_Msk                 ((uint32_t)0x0F000000)
N
N/** @} */ /* End of group EBC_NAND_CYCLES */
N
N/** @defgroup Periph_EBC_CONTROL	EBC CONTROL
N  * @{
N  */ 
N
N/*-- EBC_CONTROL: EBC Control Register -----------------------------*/
N/* Bit field positions: */
N#define EBC_CONTROL_ROM_Pos                     0
N#define EBC_CONTROL_RAM_Pos                     1
N#define EBC_CONTROL_NAND_Pos                    2
N#define EBC_CONTROL_CPOL_Pos                    3
N#define EBC_CONTROL_BUSY_Pos                    7
N#define EBC_CONTROL_WAIT_STATE_Pos              12
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY_Pos					16
S	#define EBC_CONTROL_FF_RDY_Pos					17
N#endif
N
N/* Bit field masks: */
N#define EBC_CONTROL_ROM                         ((uint32_t)0x00000001)
N#define EBC_CONTROL_RAM                         ((uint32_t)0x00000002)
N#define EBC_CONTROL_NAND                        ((uint32_t)0x00000004)
N#define EBC_CONTROL_CPOL                        ((uint32_t)0x00000008)
N#define EBC_CONTROL_BUSY                        ((uint32_t)0x00000080)
N#define EBC_CONTROL_WAIT_STATE_Msk              ((uint32_t)0x0000F000)
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY					((uint32_t)0x00010000)
S	#define EBC_CONTROL_FF_RDY					((uint32_t)0x00020000)
N#endif
N
N
N/** @} */ /* End of group EBC_CONTROL */
N
N#if defined (USE_MDR1986VE94)
X#if 0L
S
S/** @defgroup Periph_EBC_RAM_CYCLESx	EBC RAM CYCLESx
S  * @{
S  */
S
S/*-- EBC_RAM_CYCLESx: Register customization options exchange with RAM -------*/
S/* Bit field positions: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE_Pos			0
S#define EBC_RAM_CYCLES_WS_ACTIVE_Pos			1
S#define EBC_RAM_CYCLES_WS_SETUP_Pos				8
S#define EBC_RAM_CYCLES_WS_HOLD_Pos				11
S#define EBC_RAM_CYCLES_USE_READY_Pos			14
S
S/* Bit field masks: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE				((uint32_t)0x00000001)
S#define EBC_RAM_CYCLES_WS_ACTIVE_Msk			((uint32_t)0x000000FE)
S#define EBC_RAM_CYCLES_WS_SETUP_Msk				((uint32_t)0x00000700)
S#define EBC_RAM_CYCLES_WS_HOLD_Msk				((uint32_t)0x00003200)
S#define EBC_RAM_CYCLES_USE_READY				((uint32_t)0x00004000)
S
S/** @} */ /* End of group EBC_RAM_CYCLESx */
N#endif
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC */
N
N/** @} */ /* End of group __MDR32Fx_Peripheral_Units */
N
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define MDR_CAN1_BASE       (0x40000000)
N#define MDR_CAN2_BASE       (0x40008000)
N#define MDR_USB_BASE        (0x40010000)
N#define MDR_EEPROM_BASE     (0x40018000)
N#define MDR_RST_CLK_BASE    (0x40020000)
N#define MDR_DMA_BASE        (0x40028000)
N#define MDR_UART1_BASE      (0x40030000)
N#define MDR_UART2_BASE      (0x40038000)
N#define MDR_SSP1_BASE       (0x40040000)
N#define MDR_I2C_BASE        (0x40050000)
N#define MDR_POWER_BASE      (0x40058000)
N#define MDR_WWDG_BASE       (0x40060000)
N#define MDR_IWDG_BASE       (0x40068000)
N#define MDR_TIMER1_BASE     (0x40070000)
N#define MDR_TIMER2_BASE     (0x40078000)
N#define MDR_TIMER3_BASE     (0x40080000)
N#define MDR_ADC_BASE        (0x40088000)
N#define MDR_DAC_BASE        (0x40090000)
N#define MDR_COMP_BASE       (0x40098000)
N#define MDR_SSP2_BASE       (0x400A0000)
N#define MDR_PORTA_BASE      (0x400A8000)
N#define MDR_PORTB_BASE      (0x400B0000)
N#define MDR_PORTC_BASE      (0x400B8000)
N#define MDR_PORTD_BASE      (0x400C0000)
N#define MDR_PORTE_BASE      (0x400C8000)
N#define MDR_BKP_BASE        (0x400D8000)
N#define MDR_PORTF_BASE      (0x400E8000)
N#define MDR_EBC_BASE        (0x400F0000)
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define MDR_CAN1            ((MDR_CAN_TypeDef     *) MDR_CAN1_BASE)
N#define MDR_CAN2            ((MDR_CAN_TypeDef     *) MDR_CAN2_BASE)
N#define MDR_USB             ((MDR_USB_TypeDef     *) MDR_USB_BASE)
N#define MDR_EEPROM          ((MDR_EEPROM_TypeDef  *) MDR_EEPROM_BASE)
N#define MDR_RST_CLK         ((MDR_RST_CLK_TypeDef *) MDR_RST_CLK_BASE)
N#define MDR_DMA             ((MDR_DMA_TypeDef     *) MDR_DMA_BASE)
N#define MDR_UART1           ((MDR_UART_TypeDef    *) MDR_UART1_BASE)
N#define MDR_UART2           ((MDR_UART_TypeDef    *) MDR_UART2_BASE)
N#define MDR_SSP1            ((MDR_SSP_TypeDef     *) MDR_SSP1_BASE)
N#define MDR_I2C             ((MDR_I2C_TypeDef     *) MDR_I2C_BASE)
N#define MDR_POWER           ((MDR_POWER_TypeDef   *) MDR_POWER_BASE)
N#define MDR_WWDG            ((MDR_WWDG_TypeDef    *) MDR_WWDG_BASE)
N#define MDR_IWDG            ((MDR_IWDG_TypeDef    *) MDR_IWDG_BASE)
N#define MDR_TIMER1          ((MDR_TIMER_TypeDef   *) MDR_TIMER1_BASE)
N#define MDR_TIMER2          ((MDR_TIMER_TypeDef   *) MDR_TIMER2_BASE)
N#define MDR_TIMER3          ((MDR_TIMER_TypeDef   *) MDR_TIMER3_BASE)
N#define MDR_ADC             ((MDR_ADC_TypeDef     *) MDR_ADC_BASE)
N#define MDR_DAC             ((MDR_DAC_TypeDef     *) MDR_DAC_BASE)
N#define MDR_COMP            ((MDR_COMP_TypeDef    *) MDR_COMP_BASE)
N#define MDR_SSP2            ((MDR_SSP_TypeDef     *) MDR_SSP2_BASE)
N#define MDR_PORTA           ((MDR_PORT_TypeDef    *) MDR_PORTA_BASE)
N#define MDR_PORTB           ((MDR_PORT_TypeDef    *) MDR_PORTB_BASE)
N#define MDR_PORTC           ((MDR_PORT_TypeDef    *) MDR_PORTC_BASE)
N#define MDR_PORTD           ((MDR_PORT_TypeDef    *) MDR_PORTD_BASE)
N#define MDR_PORTE           ((MDR_PORT_TypeDef    *) MDR_PORTE_BASE)
N#define MDR_BKP             ((MDR_BKP_TypeDef     *) MDR_BKP_BASE)
N#define MDR_PORTF           ((MDR_PORT_TypeDef    *) MDR_PORTF_BASE)
N#define MDR_EBC             ((MDR_EBC_TypeDef     *) MDR_EBC_BASE)
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N#ifdef __cplusplus
S}
N#endif
N
N/** @} */ /* End of group __MDR32Fx_Peripheral */
N
N#define BITBAND_SRAM_REF		(0x20000000)
N#define BITBAND_SRAM_BASE		(0x22000000)
N#define BITBAND_PER_REF			(0x40000000)
N#define BITBAND_PER_BASE		(0x42000000)
N
N#define BIT_RAM(a,b) *((volatile uint32_t *)(BITBAND_SRAM_BASE+(a-BITBAND_SRAM_REF)*32+(b*4)))
N#define BIT_PER(a,b) *((volatile uint32_t *)(BITBAND_PER_BASE+((uint32_t)&a-BITBAND_PER_REF)*32+(b*4)))
N
N#define CLR_BIT_RAM(a,b) (BIT_RAM(a,b) = 0x00000000)
N#define CLR_BIT_PER(a,b) (BIT_PER(a,b) = 0x00000000)
N
N#define SET_BIT_RAM(a,b) (BIT_RAM(a,b) = 0x00000001)
N#define SET_BIT_PER(a,b) (BIT_PER(a,b) = 0x00000001)
N
N#define CHF_BIT_RAM(a,b) (BIT_RAM(a,b) == 0x00000000)
N#define CHF_BIT_PER(a,b) (BIT_PER(a,b) == 0x00000000)
N
N#define CHT_BIT_RAM(a,b) (BIT_RAM(a,b) == 0x00000001)
N#define CHT_BIT_PER(a,b) (BIT_PER(a,b) == 0x00000001)
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __MDR32FX_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32Fx.h */
L 5 "Source\main.h" 2
N
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060001
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 7 "Source\main.h" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060001
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 8 "Source\main.h" 2
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 192842 $
N * Checkin $Date: 2015-04-28 10:58:32 +0100 (Tue, 28 Apr 2015) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060001
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 9 "Source\main.h" 2
N
N#include <rl_fs.h>
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_fs.h
N * Purpose: File System API
N * Rev.:    V6.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_FS_H
N#define __RL_FS_H
N
N#include <stdint.h>
N#include <stdbool.h>
N
N// ==== Enumeration, structures, defines ====
N
N/// FAT File Attribute bit masks.
N#define FS_FAT_ATTR_READ_ONLY    0x01   ///< Read-only file attribute
N#define FS_FAT_ATTR_HIDDEN       0x02   ///< Hidden file attribute
N#define FS_FAT_ATTR_SYSTEM       0x04   ///< System file attribute
N#define FS_FAT_ATTR_VOLUME_ID    0x08   ///< Volume ID attribute
N#define FS_FAT_ATTR_DIRECTORY    0x10   ///< Directory file attribute
N#define FS_FAT_ATTR_ARCHIVE      0x20   ///< Archive file attribute
N
N/// IOC control code fsDevCtrlCodeCheckMedia return bit masks.
N#define FS_MEDIA_INSERTED        0x01   ///< Media Detected
N#define FS_MEDIA_PROTECTED       0x02   ///< Media Write Protected
N#define FS_MEDIA_INITIALIZED     0x04   ///< Media Initialized
N#define FS_MEDIA_NOCHKMEDIA      0x80   ///< Check Media Not implemented
N
N/// IOC control code fsDevCtrlCodeControlMedia argument values.
N#define FS_CONTROL_MEDIA_INIT    0x00   ///< Initialize media device
N#define FS_CONTROL_EMMC_SLEEP    0x01   ///< Switch eMMC device to Sleep State
N#define FS_CONTROL_EMMC_AWAKE    0x02   ///< Wake-up eMMC device from Sleep State
N
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// File System return codes.
Ntypedef enum {
N  fsOK = 0,                             ///< Operation succeeded
N  fsError,                              ///< Unspecified error
N  fsUnsupported,                        ///< Operation not supported
N  fsAccessDenied,                       ///< Resource access denied
N  fsInvalidParameter,                   ///< Invalid parameter specified
N  fsInvalidDrive,                       ///< Nonexistent drive
N  fsInvalidPath,                        ///< Invalid path specified
N  fsUninitializedDrive,                 ///< Drive is uninitialized
N  fsDriverError,                        ///< Read/write error
N  fsMediaError,                         ///< Media error
N  fsNoMedia,                            ///< No media, or not initialized
N  fsNoFileSystem,                       ///< File system is not formatted
N  fsNoFreeSpace,                        ///< No free space available
N  fsFileNotFound,                       ///< Requested file not found
N  fsDirNotEmpty,                        ///< The directory is not empty
N  fsTooManyOpenFiles                    ///< Too many open files
N} fsStatus;
N
N/// File System Type.
Ntypedef enum _fsType {
N  fsTypeNone = 0,                       ///< No file system (volume unformatted)
N  fsTypeUnknown,                        ///< File system type is unknown
N  fsTypeFAT12,                          ///< File system type is FAT12
N  fsTypeFAT16,                          ///< File system type is FAT16
N  fsTypeFAT32,                          ///< File system type is FAT32
N  fsTypeEFS                             ///< File system type is EFS
N} fsType;
N
N/// Driver DeviceCtrl parameter code.
Ntypedef enum _fsDevCtrlCode {
N  fsDevCtrlCodeCheckMedia = 0,          ///< Check Media Status
N  fsDevCtrlCodeControlMedia,            ///< Control Media Device
N  fsDevCtrlCodeFormat,                  ///< Format Media at low level
N  fsDevCtrlCodeSerial,                  ///< Return device serial number
N  fsDevCtrlCodeGetCID                   ///< Read Memory Card CID Register
N} fsDevCtrlCode;
N
N/// Media information.
Ntypedef struct _fsMediaInfo {
N  uint32_t  block_cnt;                  ///< Total number of blocks on the volume
N  uint16_t  read_blen;                  ///< Read block length
N  uint16_t  write_blen;                 ///< Write block length
N} fsMediaInfo;
N
N/// IO Control Cache information.
Ntypedef struct _fsIOC_Cache {
N  uint8_t *buffer;                      ///< Cache Buffer (4 byte aligned)
N  uint32_t size;                        ///< Cache Buffer size in bytes
N} fsIOC_Cache;
N
N/// Memory card CID register.
Ntypedef struct _fsCID_Register {
N  uint32_t   PSN;                       ///< Product serial number
N  uint16_t   OID;                       ///< OEM/Application ID
N  uint8_t    MID;                       ///< Manufacturer ID
N  uint8_t    PRV;                       ///< Product revision
N  uint16_t   MDT;                       ///< Manufacturing date
N  uint8_t    PNM[6];                    ///< Product name
N} fsCID_Register;
N
N/// File System Time structure.
Ntypedef struct _fsTime {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} fsTime;
N
N/// File information data.
Ntypedef struct _fsFileInfo {
N  char     name[256];                   ///< Filename path
N  uint32_t size;                        ///< File size in bytes
N  uint16_t fileID;                      ///< System Identification
N  uint8_t  attrib;                      ///< Attributes
N  fsTime   time;                        ///< Create/Modify Time
N} fsFileInfo;
N
N/// Drive information.
Ntypedef struct _fsDriveInfo {
N  fsType   fs_type;                     ///< Drives file system type
N  uint64_t capacity;                    ///< Drives capacity in bytes
N} fsDriveInfo;
N
N
N//  ==== System Routines ====
N
N/// \brief Initialize File System and drive related driver.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Failed to initialize the driver.
Nextern fsStatus finit (const char *drive);
N
N/// \brief Uninitialize File System.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funinit (const char *drive);
N
N/// \brief Mount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsUninitializedDrive = Media driver not initialized.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Media driver operation failed.
N///               - fsMediaError       = Failed to initialize the media.
N///               - fsNoMedia          = Media device is not insterted.
N///               - fsNoFileSystem     = No filesystem on the volume.
Nextern fsStatus fmount (const char *drive);
N
N/// \brief Unmount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funmount (const char *drive);
N
N
N//  ==== File Maintenance Routines ====
N
N/// \brief Delete one or multiple files.
N/// \param[in]  path                     a string specifying the file or directory.
N/// \param[in]  options                  a string specifying function options.
N/// \return     execution status \ref fsStatus
N#ifdef MW_FILESYSTEM_FDELETE_LEGACY
Sextern fsStatus fdelete (const char *path);
N#else
Nextern fsStatus fdelete (const char *path, const char *options);
N#endif
N
N
N/// \brief Find a file or directory matching search pattern.
N/// \param[in]  pattern                  string specifying the pattern.
N///                                      - May include drive prefix and the following wildcards:
N///                                      - "*" or "*.*" searches for all files in the directory.
N///                                      - "abc*"       searches for files that begin with abc.
N///                                      - "*.htm"      searches for files that end with .htm.
N///                                      - "abc*.text"  searches for files that begin with abc and that end with .text.
N/// \param[out] info                     structure storing information about matching files.
N/// \return     execution status \ref fsStatus
Nextern fsStatus ffind (const char *pattern, fsFileInfo *info);
N
N/// \brief Rename a file or directory with given path name to a new name.
N/// \param[in]  path                     string specifying the file or directory path.
N/// \param[in]  newname                  string specifying new file or directory name.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frename (const char *path, const char *newname);
N
N/// \brief Change file attributes.
N/// \param[in]  path                     string specifying file or directory path.
N/// \param[in]  attr                     string specifying file or directory attributes to be modified.
N///                                      The following characters are allowed within attr string:
N///                                      - + Sets an attribute.
N///                                      - - Clears an attribute.
N///                                      - R Read-only file attribute.
N///                                      - A Archive file attribute.
N///                                      - S System file attribute.
N///                                      - H Hidden file attribute.
N/// \return     execution status \ref fsStatus
N/// \note       This function supports FAT drives only.
Nextern fsStatus fattrib (const char *path, const char *attr);
N
N
N//  ==== Directory Maintenance Routines ====
N
N/// \brief Print working directory.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] buf                      pointer to string buffer.
N/// \param[in]  len                      string buffer length.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fpwd (const char *drive, char *buf, uint32_t len);
N
N/// \brief Change working directory.
N/// \param[in]  path                     string specifying the directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdir (const char *path);
N
N/// \brief Create a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fmkdir (const char *path);
N
N/// \brief Remove a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \param[in]  options                  string specifying function options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frmdir (const char *path, const char *options);
N
N
N//  ==== Utility Routines ====
N
N/// \brief Change current drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdrive (const char *drive);
N
N/// \brief Find free space on drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     free space or execution status
N///             - value >= 0: free space on drive in bytes.
N///             - value < 0:  error occurred, -value is execution status as defined with \ref fsStatus
Nextern int64_t ffree (const char *drive);
N
N/// \brief Format drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[in]  options                  string specifying formatting options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fformat (const char *drive, const char *options);
N
N/// \brief Analyse volume and check for file fragmentation.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     fragmentation factor or execution status
N///             - value >= 0 or <= 255: fragmentation factor
N///             - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
N/// \note       This function supports EFS drives only.
Nextern int32_t fanalyse (const char *drive);
N
N/// \brief Analyse volume and check for allocation errors.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful, no allocation errors
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Unsupported drive.
N///               - fsError            = Check failed due to allocation errors.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fcheck (const char *drive);
N
N/// \brief Defragment Embedded Flash drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Not all files are closed on specified drive or unsupported drive.
N///               - fsNoFreeSpace      = Not enough space to complete the defragmentation.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fdefrag (const char *drive);
N
N/// \brief Check if media present on removable drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = Tried to access non-removable drive.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fmedia (const char *drive);
N
N/// \brief Read drive information.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] info                     drive information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus finfo (const char *drive, fsDriveInfo *info);
N
N/// \brief Read volume label and serial number.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] label                    buffer for storing label as a null terminated string.
N///                                      When volume has no label an empty string is returned.
N///                                      This parameter can be NULL meaning label will not be read.
N/// \param[out] serial                   pointer to variable where serial number will be stored.
N///                                      This parameter can be NULL meaning serial number will not be read.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Trying to read label and serial from EFS drive.
N///               - fsDriverError      = Read/write error.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fvol (const char *drive, char *label, uint32_t *serial);
N
N
N//  ==== File Time Support Routines ====
N
N/// \brief Callback function used to provide the current date and time to the File System.
N/// \param[out] time                     Pointer to the \ref fsTime structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsError            = Failed to get the current time
N/// \note       This function supports FAT drives only.
Nextern fsStatus fs_get_time (fsTime *time);
N
N
N//  ==== Media Support Routines ====
N
N/// \brief   Callback function used to read Card Detect (CD) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:card detected, 0:card not detected, or error
Nextern int32_t fs_mc_read_cd (uint32_t drive_num);
N
N/// \brief   Callback function used to read Write Protect (WP) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:write protected, 0:not write protected, or error
Nextern int32_t fs_mc_read_wp (uint32_t drive_num);
N
N/// \brief   Callback function used to control Slave Select signal when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \param[in]  ss                       Slave select signal state
N/// \return     execution status
N///               - slave select signal state: 1:active, 0:inactive
N///               - -1: slave select signal control is not implemented
Nextern int32_t fs_mc_spi_control_ss (uint32_t drive_num, uint32_t ss);
N
N
N//  ==== I/O Control Interface Routines ====
N
N/// \brief Check if valid drive is specified and return its ID.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     drive ID or execution status
N///               - value >= 0: drive ID as an integer when specified drive exists and allows IOC access
N///               - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
Nextern int32_t fs_ioc_get_id (const char *drive);
N
N/// \brief Lock drive and block media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_lock (int32_t drv_id);
N
N/// \brief Unlock drive and allow media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_unlock (int32_t drv_id);
N
N/// \brief Return IOC cache buffer information.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] cache_info               IOC Cache information.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters are not valid.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_get_cache (int32_t drv_id, fsIOC_Cache *cache_info);
N
N/// \brief Read sector from media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_read_sector (int32_t drv_id, uint32_t sect, uint8_t *buf, uint32_t cnt);
N
N/// \brief Write sector to media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_write_sector (int32_t drv_id, uint32_t sect, const uint8_t *buf, uint32_t cnt);
N
N/// \brief Read media configuration info.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] info                     Media information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Media information read failed.
Nextern fsStatus fs_ioc_read_info (int32_t drv_id, fsMediaInfo *info);
N
N/// \brief IOC device control access; control code is sent directly to device driver.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  code                     Device control code.
N/// \param[in,out] p                     Generic pointer.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fs_ioc_device_ctrl (int32_t drv_id, fsDevCtrlCode code, void *p);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_FS_H */
L 11 "Source\main.h" 2
N
N//  8  * (9+1) = 80 
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL 9
N
Nextern const unsigned char Ver[2];
N
N#endif
L 2 "Source\main.c" 2
N
N/*
N	   Keil uVision ver. 5.16.
N	 6.09.2015.
N*/
N
N//   firmware,  - 2 ,  "001.000"
Nconst unsigned char Ver[2] = {1, 0};
N
Nvoid ClkSetup (void)
N{
N	MDR_RST_CLK->PER_CLOCK = RST_CLK_PER_CLOCK_PCLK_EN_RST_CLK;
X	((MDR_RST_CLK_TypeDef *) (0x40020000))->PER_CLOCK = ((uint32_t)0x00000010);
N	
N	MDR_RST_CLK->HS_CONTROL =
X	((MDR_RST_CLK_TypeDef *) (0x40020000))->HS_CONTROL =
N		(1 << RST_CLK_HS_CONTROL_HSE_ON_Pos) |
X		(1 << 0) |
N		(0 << RST_CLK_HS_CONTROL_HSE_BYP_Pos);
X		(0 << 1);
N	
N	while (CHF_BIT_PER (MDR_RST_CLK->CLOCK_STATUS, RST_CLK_CLOCK_STATUS_HSE_RDY_Pos));
X	while ((*((volatile uint32_t *)((0x42000000)+((uint32_t)&((MDR_RST_CLK_TypeDef *) (0x40020000))->CLOCK_STATUS-(0x40000000))*32+(2*4))) == 0x00000000));
N	
N	MDR_RST_CLK->CPU_CLOCK =
X	((MDR_RST_CLK_TypeDef *) (0x40020000))->CPU_CLOCK =
N		(RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSE << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) |
X		(0x02 << 0) |
N		(RST_CLK_CPU_CLOCK_CPU_C2_SEL_CPU_C1 << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos) |
X		(0x00 << 2) |
N		(RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2 << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos) |
X		(0x00 << 4) |
N		(RST_CLK_CPU_CLOCK_HCLK_SEL_HSI << RST_CLK_CPU_CLOCK_HCLK_SEL_Pos);
X		(0x00 << 8);
N	
N	MDR_RST_CLK->PLL_CONTROL =
X	((MDR_RST_CLK_TypeDef *) (0x40020000))->PLL_CONTROL =
N		(0 << RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos) |
X		(0 << 0) |
N		(0 << RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos) |
X		(0 << 1) |
N		(0 << RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos) |
X		(0 << 2) |
N		(0 << RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos) |
X		(0 << 3) |
N		(0 << RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) |
X		(0 << 4) |
N		(RST_CLK_PLL_CONTROL_PLL_CPU_MUL << RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos);
X		(9 << 8);
N	
N	SET_BIT_PER (MDR_RST_CLK->PLL_CONTROL, RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos);
X	(*((volatile uint32_t *)((0x42000000)+((uint32_t)&((MDR_RST_CLK_TypeDef *) (0x40020000))->PLL_CONTROL-(0x40000000))*32+(2*4))) = 0x00000001);
N	
N	SET_BIT_PER (MDR_RST_CLK->PLL_CONTROL, RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos);
X	(*((volatile uint32_t *)((0x42000000)+((uint32_t)&((MDR_RST_CLK_TypeDef *) (0x40020000))->PLL_CONTROL-(0x40000000))*32+(3*4))) = 0x00000001);
N	CLR_BIT_PER (MDR_RST_CLK->PLL_CONTROL, RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos);
X	(*((volatile uint32_t *)((0x42000000)+((uint32_t)&((MDR_RST_CLK_TypeDef *) (0x40020000))->PLL_CONTROL-(0x40000000))*32+(3*4))) = 0x00000000);
N	
N	while (CHF_BIT_PER(MDR_RST_CLK->CLOCK_STATUS, RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos));
X	while ((*((volatile uint32_t *)((0x42000000)+((uint32_t)&((MDR_RST_CLK_TypeDef *) (0x40020000))->CLOCK_STATUS-(0x40000000))*32+(1*4))) == 0x00000000));
N	
N	MDR_RST_CLK->CPU_CLOCK =
X	((MDR_RST_CLK_TypeDef *) (0x40020000))->CPU_CLOCK =
N		(RST_CLK_CPU_CLOCK_CPU_C1_SEL_HSE << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) |
X		(0x02 << 0) |
N		(RST_CLK_CPU_CLOCK_CPU_C2_SEL_PLL_CPU << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos) |
X		(0x01 << 2) |
N		(RST_CLK_CPU_CLOCK_CPU_C3_SEL_CPU_C2 << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos) |
X		(0x00 << 4) |
N		(RST_CLK_CPU_CLOCK_HCLK_SEL_CPU_C3 << RST_CLK_CPU_CLOCK_HCLK_SEL_Pos);
X		(0x01 << 8);
N}
N
NfsStatus fs;
N
Nchar label[12];
Nuint32_t ser_num;
N
Nint64_t FreeSize;
N
N#define StrBufSize 200
Nchar StrBuf[StrBufSize];
Xchar StrBuf[200];
N
N#define DirName "M0:\\Dir"
N#define FileName "FileDir\\File.txt"
N
NFILE *fin, *fout;
Nint Radius = 10;
Nint CircleRadius;
Nfloat CircleArea;
N
Nint main (void)
N{
N	ClkSetup ();
N	
N	// Initialize the M0: drive.
N  fs = finit ("M0:");
N	
N  // Mount the M0: drive.
N  fs = fmount ("M0:");
N  
N  fs = fvol ("M0:", label, &ser_num);
N	
N	FreeSize = ffree ("M0:");
N	
N	fs = fpwd ("M0:", StrBuf, StrBufSize);
X	fs = fpwd ("M0:", StrBuf, 200);
N	
N	fs = fmkdir (DirName);
X	fs = fmkdir ("M0:\\Dir");
N	
N  fout = fopen (FileName, "w"); /* Create a file in subfolder on SD card.*/
X  fout = fopen ("FileDir\\File.txt", "w");  
N	
N  if (fout != NULL)
X  if (fout != 0)
N	{
N    // Write data to file
N		fprintf (fout, "   %i  %f.\n", Radius, 3.1415926*Radius*Radius);
N    fclose (fout);
N	}
N	
N	fin = fopen (FileName, "r"); /* Open a file in subfolder on SD card.*/
X	fin = fopen ("FileDir\\File.txt", "r");  
N	
N  if (fin != NULL)
X  if (fin != 0)
N	{
N    // Read data from file
N		fscanf (fin, "   %i  %f.\n", &CircleRadius, &CircleArea);
N    fclose (fin);
N	}
N	
N	// The drive is no more needed.
N	// Unmount the M0: drive.
N  fs = funmount ("M0:");
N	
N	// Uninitialize the M0: drive.
N  fs = funinit ("M0:");
N	
N	while (true);
X	while (1);
N}
