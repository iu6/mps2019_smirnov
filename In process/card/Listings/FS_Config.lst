L 1 "RTE\File_System\FS_Config.c"
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2014 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    FS_Config.c
N * Purpose: File System Configuration
N * Rev.:    V6.2
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>FAT File System
N// <i>Define FAT File System parameters
N
N//   <o>Number of open files <1-16>
N//   <i>Define number of files that can be opened at the same time.
N//   <i>Default: 4
N#define FAT_MAX_OPEN_FILES      4
N
N// </h>
N
N// <h>Embedded File System
N// <i>Define Embedded File System parameters
N
N//   <o>Number of open files <1-16>
N//   <i>Define number of files that can be opened at the same time.
N//   <i>Default: 4
N#define EFS_MAX_OPEN_FILES      4
N
N// </h>
N
N// <o>Initial Current Drive <0=>F0: <1=>F1:
N//                          <2=>M0: <3=>M1:
N//                          <4=>N0: <5=>N1:
N//                          <6=>R0:
N//                          <7=>U0: <8=>U1:
N// <i>Set initial setting for current drive. Current drive is used for File System functions
N// <i>that are invoked with the "" string and can be altered anytime during run-time.
N#define FS_INITIAL_CDRIVE       2
N
N#include "RTE_Components.h"
L 1 "D:\Keil555\1986VE9X\card\RTE\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Component Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'card' 
N * Target:  'MDR1986VE93Y' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N#define CMSIS_Drivers_SPI0                /* Driver SPI0 */
N        #define CMSIS_Drivers_SPI1                /* Driver SPI1 */
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N#define RTE_Compiler_IO_File            /* Compiler I/O: File */
N        #define RTE_Compiler_IO_File_FS         /* Compiler I/O: File (File System) */
N#define RTE_FileSystem_Core             /* File System Core */
N          #define RTE_FileSystem_LFN              /* File System with Long Filename support */
N#define RTE_FileSystem_Drive_MC_0       /* File System Memory Card Drive 0 */
N
N#endif /* RTE_COMPONENTS_H */
L 42 "RTE\File_System\FS_Config.c" 2
N
N#ifdef  RTE_FileSystem_Drive_RAM
S#include "FS_Config_RAM.h"
N#endif
N
N#ifdef  RTE_FileSystem_Drive_NOR_0
S#include "FS_Config_NOR_0.h"
N#endif
N#ifdef  RTE_FileSystem_Drive_NOR_1
S#include "FS_Config_NOR_1.h"
N#endif
N
N#ifdef  RTE_FileSystem_Drive_NAND_0
S#include "FS_Config_NAND_0.h"
N#endif
N#ifdef  RTE_FileSystem_Drive_NAND_1
S#include "FS_Config_NAND_1.h"
N#endif
N
N#ifdef  RTE_FileSystem_Drive_MC_0
N#include "FS_Config_MC_0.h"
L 1 "RTE\File_System\FS_Config_MC_0.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System:Drive
N * Copyright (c) 2004-2014 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    FS_Config_MC_0.h
N * Purpose: File System Configuration for Memory Card Drive
N * Rev.:    V6.2
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>Memory Card Drive 0
N// <i>Configuration for SD/SDHC/MMC Memory Card assigned to drive letter "M0:"
N#define MC0_ENABLE              1
N
N//   <o>Connect to hardware via Driver_MCI# <0-255>
N//   <i>Select driver control block for hardware interface
N#define MC0_MCI_DRIVER          0
N
N//   <o>Connect to hardware via Driver_SPI# <0-255>
N//   <i>Select driver control block for hardware interface when in SPI mode
N#define MC0_SPI_DRIVER          0
N
N//   <o>Memory Card Interface Mode <0=>Native <1=>SPI
N//   <i>Native uses a SD Bus with up to 8 data lines, CLK, and CMD
N//   <i>SPI uses 2 data lines (MOSI and MISO), SCLK and CS
N//   <i>When using SPI both Driver_SPI# and Driver_MCI# must be specified
N//   <i>since the MCI driver provides the control interface lines.
N#define MC0_SPI                 1
N          
N//   <o>Drive Cache Size <0=>OFF <1=>1 KB <2=>2 KB <4=>4 KB
N//                       <8=>8 KB <16=>16 KB <32=>32 KB
N//   <i>Drive Cache stores data sectors and may be increased to speed-up
N//   <i>file read/write operations on this drive (default: 4 KB)
N#define MC0_CACHE_SIZE          4
N
N//   <e>Locate Drive Cache and Drive Buffer
N//   <i>Some microcontrollers support DMA only in specific memory areas and
N//   <i>require to locate the drive buffers at a fixed address.
N#define MC0_CACHE_RELOC         0
N
N//     <o>Base address <0x0000-0xFFFFFE00:0x200>
N//     <i>Set buffer base address to RAM areas that support DMA with the drive.
N#define MC0_CACHE_ADDR          0x7FD00000
N
N//   </e>
N//   <o>Filename Cache Size <0-1000000>
N//   <i>Define number of cached file or directory names.
N//   <i>48 bytes of RAM is required for each cached name.
N#define MC0_NAME_CACHE_SIZE     0
N
N//   <q>Use FAT Journal
N//   <i>Protect File Allocation Table and Directory Entries for
N//   <i>fail-safe operation.
N#define MC0_FAT_JOURNAL         1
N
N// </h>
L 63 "RTE\File_System\FS_Config.c" 2
N#endif
N#ifdef  RTE_FileSystem_Drive_MC_1
S#include "FS_Config_MC_1.h"
N#endif
N
N#ifdef  RTE_FileSystem_Drive_USB_0
S#include "FS_Config_USB_0.h"
N#endif
N#ifdef  RTE_FileSystem_Drive_USB_1
S#include "FS_Config_USB_1.h"
N#endif
N
N#include "fs_config.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\fs_config.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    fs_config.h
N * Purpose: File System Library Configuration
N * Rev.:    V6.3
N *----------------------------------------------------------------------------*/
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060001
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 11 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\fs_config.h" 2
N#include <rt_sys.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rt_sys.h" 1
N/* rt_sys.h: prototypes for _sys_* functions and types
N *
N * Copyright 1999 ARM Limited. All rights reserved.
N *
N * RCS $Revision: 178362 $
N * Checkin $Date: 2013-01-10 16:08:02 +0000 (Thu, 10 Jan 2013) $
N * Revising $Author: pwright $
N */
N
N#ifndef __RT_SYS_H
N#define __RT_SYS_H
N#define __ARMCLIB_VERSION 5060001
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N * This type is used by the _sys_ I/O functions to denote an open
N * file.
N */
Ntypedef int FILEHANDLE;
N
N/*
N * Open a file. May return -1 if the file failed to open.
N */
Nextern FILEHANDLE _sys_open(const char * /*name*/, int /*openmode*/);
N/*
N * openmode is a bitmap, whose bits are given below. They
N * correspond directly to the ANSI mode specification.
N */
N#define OPEN_R 0
N#define OPEN_W 4
N#define OPEN_A 8
N#define OPEN_B 1
N#define OPEN_PLUS 2
N
N/*
N * These names should be special strings which will be recognised
N * by _sys_open and will cause it to return the standard I/O
N * handles, instead of opening a real file.
N */
Nextern const char __stdin_name[];
Nextern const char __stdout_name[];
Nextern const char __stderr_name[];
N
N/*
N * Close a file. Should return 0 on success or a negative value on error.
N */
Nextern int _sys_close(FILEHANDLE /*fh*/);
N
N/*
N * Write to a file. Returns 0 on success, negative on error, and
N * the number of characters _not_ written on partial success.
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_write(FILEHANDLE /*fh*/, const unsigned char * /*buf*/,
N                      unsigned /*len*/, int /*mode*/);
N
N/*
N * Read from a file. Can return:
N *  - zero if the read was completely successful
N *  - the number of bytes _not_ read, if the read was partially successful
N *  - the number of bytes not read, plus the top bit set (0x80000000), if
N *    the read was partially successful due to end of file
N *  - -1 if some error other than EOF occurred
N *
N * It is also legal to signal EOF by returning no data but
N * signalling no error (i.e. the top-bit-set mechanism need never
N * be used).
N *
N * So if (for example) the user is trying to read 8 bytes at a time
N * from a file in which only 5 remain, this routine can do three
N * equally valid things:
N *
N *  - it can return 0x80000003 (3 bytes not read due to EOF)
N *  - OR it can return 3 (3 bytes not read), and then return
N *    0x80000008 (8 bytes not read due to EOF) on the next attempt
N *  - OR it can return 3 (3 bytes not read), and then return
N *    8 (8 bytes not read, meaning 0 read, meaning EOF) on the next
N *    attempt
N *
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_read(FILEHANDLE /*fh*/, unsigned char * /*buf*/,
N                     unsigned /*len*/, int /*mode*/);
N
N/*
N * Write a character to the output channel. This function is used
N * for last-resort error message output.
N */
Nextern void _ttywrch(int /*ch*/);
N
N/*
N * Return non-zero if the argument file is connected to a terminal.
N */
Nextern int _sys_istty(FILEHANDLE /*fh*/);
N
N/*
N * Move the file position to a given offset from the file start.
N * Returns >=0 on success, <0 on failure.
N */
Nextern int _sys_seek(FILEHANDLE /*fh*/, long /*pos*/);
N
N/*
N * Flush any OS buffers associated with fh, ensuring that the file
N * is up to date on disk. Result is >=0 if OK, negative for an
N * error.
N */
Nextern int _sys_ensure(FILEHANDLE /*fh*/);
N
N/*
N * Return the current length of a file, or <0 if an error occurred.
N * _sys_flen is allowed to reposition the file pointer (so Unix can
N * implement it with a single lseek, for example), since it is only
N * called when processing SEEK_END relative fseeks, and therefore a
N * call to _sys_flen is always followed by a call to _sys_seek.
N */
Nextern long _sys_flen(FILEHANDLE /*fh*/);
N
N/*
N * Return the name for temporary file number sig in the buffer
N * name. Returns 0 on failure. maxlen is the maximum name length
N * allowed.
N */
Nextern int _sys_tmpnam(char * /*name*/, int /*sig*/, unsigned /*maxlen*/);
N
N/*
N * Terminate the program, passing a return code back to the user.
N * This function may not return.
N */
Nextern void _sys_exit(int /*returncode*/);   /* never returns */
N
N/*
N * Return a pointer to the command line used to invoke the program.
N * The supplied buffer may be used to store the string, but need
N * not be.
N */
Nextern char *_sys_command_string(char * /*cmd*/, int /*len*/);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 12 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\fs_config.h" 2
N
N#include "rl_fs_lib.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_fs_lib.h
N * Purpose: File System Library Definitions
N * Rev.:    V6.5.0
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_FS_LIB_H
N#define __RL_FS_LIB_H
N
N#if defined(RTE_FileSystem_Drive_MC_0) || defined(RTE_FileSystem_Drive_MC_1)
X#if 1L || 0L
N  #include "Driver_MCI.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_MCI.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        16. May 2014
N * $Revision:    V2.02
N *
N * Project:      MCI (Memory Card Interface) Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.02
N *    Added timeout and error flags to ARM_MCI_STATUS
N *    Added support for controlling optional RST_n pin (eMMC)
N *    Removed explicit Clock Control (ARM_MCI_CONTROL_CLOCK)
N *    Removed event ARM_MCI_EVENT_BOOT_ACK_TIMEOUT
N *  Version 2.01
N *    Decoupled SPI mode from MCI driver
N *    Replaced function ARM_MCI_CardSwitchRead with ARM_MCI_ReadCD and ARM_MCI_ReadWP
N *  Version 2.00
N *    Added support for:
N *      SD UHS-I (Ultra High Speed)
N *      SD I/O Interrupt
N *      Read Wait (SD I/O)
N *      Suspend/Resume (SD I/O)
N *      MMC Interrupt
N *      MMC Boot
N *      Stream Data transfer (MMC)
N *      VCCQ Power Supply Control (eMMC)
N *      Command Completion Signal (CCS) for CE-ATA
N *    Added ARM_MCI_Control function
N *    Added ARM_MCI_GetStatus function
N *    Removed ARM_MCI_BusMode, ARM_MCI_BusDataWidth, ARM_MCI_BusSingaling functions
N *      (replaced by ARM_MCI_Control)
N *    Changed ARM_MCI_CardPower function (voltage parameter)
N *    Changed ARM_MCI_SendCommnad function (flags parameter)
N *    Changed ARM_MCI_SetupTransfer function (mode parameter)
N *    Removed ARM_MCI_ReadTransfer and ARM_MCI_WriteTransfer functions
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Changed return values of some functions to int32_t
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_MCI_H
N#define __DRIVER_MCI_H
N
N#include "Driver_Common.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        2. Jan 2014
N * $Revision:    V2.00
N *
N * Project:      Common Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.00
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_COMMON_H
N#define __DRIVER_COMMON_H
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060001
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 41 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060001
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 42 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060001
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 43 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 2
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* __DRIVER_COMMON_H */
L 67 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_MCI.h" 2
N
N#define ARM_MCI_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,02)  /* API version */
N
N
N/****** MCI Send Command Flags *****/
N#define ARM_MCI_RESPONSE_Pos             0
N#define ARM_MCI_RESPONSE_Msk            (3UL << ARM_MCI_RESPONSE_Pos)
N#define ARM_MCI_RESPONSE_NONE           (0UL << ARM_MCI_RESPONSE_Pos)   ///< No response expected (default)
N#define ARM_MCI_RESPONSE_SHORT          (1UL << ARM_MCI_RESPONSE_Pos)   ///< Short response (48-bit)
N#define ARM_MCI_RESPONSE_SHORT_BUSY     (2UL << ARM_MCI_RESPONSE_Pos)   ///< Short response with busy signal (48-bit)
N#define ARM_MCI_RESPONSE_LONG           (3UL << ARM_MCI_RESPONSE_Pos)   ///< Long response (136-bit)
N
N#define ARM_MCI_RESPONSE_INDEX          (1UL << 2)  ///< Check command index in response
N#define ARM_MCI_RESPONSE_CRC            (1UL << 3)  ///< Check CRC in response
N
N#define ARM_MCI_WAIT_BUSY               (1UL << 4)  ///< Wait until busy before sending the command
N
N#define ARM_MCI_TRANSFER_DATA           (1UL << 5)  ///< Activate Data transfer
N
N#define ARM_MCI_CARD_INITIALIZE         (1UL << 6)  ///< Execute Memory Card initialization sequence
N
N#define ARM_MCI_INTERRUPT_COMMAND       (1UL << 7)  ///< Send Interrupt command (CMD40 - MMC only)
N#define ARM_MCI_INTERRUPT_RESPONSE      (1UL << 8)  ///< Send Interrupt response (CMD40 - MMC only)
N
N#define ARM_MCI_BOOT_OPERATION          (1UL << 9)  ///< Execute Boot operation (MMC only)
N#define ARM_MCI_BOOT_ALTERNATIVE        (1UL << 10) ///< Execute Alternative Boot operation (MMC only)
N#define ARM_MCI_BOOT_ACK                (1UL << 11) ///< Expect Boot Acknowledge (MMC only)
N
N#define ARM_MCI_CCSD                    (1UL << 12) ///< Send Command Completion Signal Disable (CCSD) for CE-ATA device
N#define ARM_MCI_CCS                     (1UL << 13) ///< Expect Command Completion Signal (CCS) for CE-ATA device
N
N
N/****** MCI Setup Transfer Mode *****/
N#define ARM_MCI_TRANSFER_READ           (0UL << 0)  ///< Data Read Transfer (from MCI)
N#define ARM_MCI_TRANSFER_WRITE          (1UL << 0)  ///< Data Write Transfer (to MCI)
N#define ARM_MCI_TRANSFER_BLOCK          (0UL << 1)  ///< Block Data transfer (default)
N#define ARM_MCI_TRANSFER_STREAM         (1UL << 1)  ///< Stream Data transfer (MMC only)
N
N
N/****** MCI Control Codes *****/
N#define ARM_MCI_BUS_SPEED               (0x01)      ///< Set Bus Speed; arg = requested speed in bits/s; returns configured speed in bits/s
N#define ARM_MCI_BUS_SPEED_MODE          (0x02)      ///< Set Bus Speed Mode as specified with arg
N#define ARM_MCI_BUS_CMD_MODE            (0x03)      ///< Set CMD Line Mode as specified with arg
N#define ARM_MCI_BUS_DATA_WIDTH          (0x04)      ///< Set Bus Data Width as specified with arg
N#define ARM_MCI_DRIVER_STRENGTH         (0x05)      ///< Set SD UHS-I Driver Strength as specified with arg 
N#define ARM_MCI_CONTROL_RESET           (0x06)      ///< Control optional RST_n Pin (eMMC); arg: 0=inactive, 1=active 
N#define ARM_MCI_CONTROL_CLOCK_IDLE      (0x07)      ///< Control Clock generation on CLK Pin when idle; arg: 0=disabled, 1=enabled
N#define ARM_MCI_UHS_TUNING_OPERATION    (0x08)      ///< Sampling clock Tuning operation (SD UHS-I); arg: 0=reset, 1=execute
N#define ARM_MCI_UHS_TUNING_RESULT       (0x09)      ///< Sampling clock Tuning result (SD UHS-I); returns: 0=done, 1=in progress, -1=error
N#define ARM_MCI_DATA_TIMEOUT            (0x0A)      ///< Set Data timeout; arg = timeout in bus cycles
N#define ARM_MCI_CSS_TIMEOUT             (0x0B)      ///< Set Command Completion Signal (CCS) timeout; arg = timeout in bus cycles
N#define ARM_MCI_MONITOR_SDIO_INTERRUPT  (0x0C)      ///< Monitor SD I/O interrupt: arg: 0=disabled, 1=enabled
N#define ARM_MCI_CONTROL_READ_WAIT       (0x0D)      ///< Control Read/Wait for SD I/O; arg: 0=disabled, 1=enabled
N#define ARM_MCI_SUSPEND_TRANSFER        (0x0E)      ///< Suspend Data transfer (SD I/O); returns number of remaining bytes to transfer
N#define ARM_MCI_RESUME_TRANSFER         (0x0F)      ///< Resume Data transfer (SD I/O)
N
N/*----- MCI Bus Speed Mode -----*/
N#define ARM_MCI_BUS_DEFAULT_SPEED       (0x00)      ///< SD/MMC: Default Speed mode up to 25/26MHz
N#define ARM_MCI_BUS_HIGH_SPEED          (0x01)      ///< SD/MMC: High    Speed mode up to 50/52MHz
N#define ARM_MCI_BUS_UHS_SDR12           (0x02)      ///< SD: SDR12  (Single Data Rate) up to  25MHz,  12.5MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR25           (0x03)      ///< SD: SDR25  (Single Data Rate) up to  50MHz,  25  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR50           (0x04)      ///< SD: SDR50  (Single Data Rate) up to 100MHz,  50  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR104          (0x05)      ///< SD: SDR104 (Single Data Rate) up to 208MHz, 104  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_DDR50           (0x06)      ///< SD: DDR50  (Dual Data Rate)   up to  50MHz,  50  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N
N/*----- MCI CMD Line Mode -----*/
N#define ARM_MCI_BUS_CMD_PUSH_PULL       (0x00)      ///< Push-Pull CMD line (default)
N#define ARM_MCI_BUS_CMD_OPEN_DRAIN      (0x01)      ///< Open Drain CMD line (MMC only)
N
N/*----- MCI Bus Data Width -----*/
N#define ARM_MCI_BUS_DATA_WIDTH_1        (0x00)      ///< Bus data width: 1 bit (default)
N#define ARM_MCI_BUS_DATA_WIDTH_4        (0x01)      ///< Bus data width: 4 bits
N#define ARM_MCI_BUS_DATA_WIDTH_8        (0x02)      ///< Bus data width: 8 bits
N#define ARM_MCI_BUS_DATA_WIDTH_4_DDR    (0x03)      ///< Bus data width: 4 bits, DDR (Dual Data Rate) - MMC only
N#define ARM_MCI_BUS_DATA_WIDTH_8_DDR    (0x04)      ///< Bus data width: 8 bits, DDR (Dual Data Rate) - MMC only
N
N/*----- MCI Driver Strength -----*/
N#define ARM_MCI_DRIVER_TYPE_A           (0x01)      ///< SD UHS-I Driver Type A
N#define ARM_MCI_DRIVER_TYPE_B           (0x00)      ///< SD UHS-I Driver Type B (default)
N#define ARM_MCI_DRIVER_TYPE_C           (0x02)      ///< SD UHS-I Driver Type C
N#define ARM_MCI_DRIVER_TYPE_D           (0x03)      ///< SD UHS-I Driver Type D
N
N
N/****** MCI Card Power *****/
N#define ARM_MCI_POWER_VDD_Pos            0
N#define ARM_MCI_POWER_VDD_Msk           (0x0FUL << ARM_MCI_POWER_VDD_Pos)
N#define ARM_MCI_POWER_VDD_OFF           (0x01UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) turned off
N#define ARM_MCI_POWER_VDD_3V3           (0x02UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) = 3.3V
N#define ARM_MCI_POWER_VDD_1V8           (0x03UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) = 1.8V
N#define ARM_MCI_POWER_VCCQ_Pos           4
N#define ARM_MCI_POWER_VCCQ_Msk          (0x0FUL << ARM_MCI_POWER_VCCQ_Pos)
N#define ARM_MCI_POWER_VCCQ_OFF          (0x01UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ turned off
N#define ARM_MCI_POWER_VCCQ_3V3          (0x02UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 3.3V
N#define ARM_MCI_POWER_VCCQ_1V8          (0x03UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 1.8V
N#define ARM_MCI_POWER_VCCQ_1V2          (0x04UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 1.2V
N
N
N/**
N\brief MCI Status
N*/
Ntypedef struct _ARM_MCI_STATUS {
N  uint32_t command_active   : 1;        ///< Command active flag
N  uint32_t command_timeout  : 1;        ///< Command timeout flag (cleared on start of next command)
N  uint32_t command_error    : 1;        ///< Command error flag (cleared on start of next command)
N  uint32_t transfer_active  : 1;        ///< Transfer active flag
N  uint32_t transfer_timeout : 1;        ///< Transfer timeout flag (cleared on start of next command)
N  uint32_t transfer_error   : 1;        ///< Transfer error flag (cleared on start of next command)
N  uint32_t sdio_interrupt   : 1;        ///< SD I/O Interrupt flag (cleared on start of monitoring)
N  uint32_t ccs              : 1;        ///< CCS flag (cleared on start of next command)
N} ARM_MCI_STATUS;
N
N
N/****** MCI Card Event *****/
N#define ARM_MCI_EVENT_CARD_INSERTED     (1UL << 0)  ///< Memory Card inserted
N#define ARM_MCI_EVENT_CARD_REMOVED      (1UL << 1)  ///< Memory Card removed
N#define ARM_MCI_EVENT_COMMAND_COMPLETE  (1UL << 2)  ///< Command completed
N#define ARM_MCI_EVENT_COMMAND_TIMEOUT   (1UL << 3)  ///< Command timeout
N#define ARM_MCI_EVENT_COMMAND_ERROR     (1UL << 4)  ///< Command response error (CRC error or invalid response)
N#define ARM_MCI_EVENT_TRANSFER_COMPLETE (1UL << 5)  ///< Data transfer completed
N#define ARM_MCI_EVENT_TRANSFER_TIMEOUT  (1UL << 6)  ///< Data transfer timeout
N#define ARM_MCI_EVENT_TRANSFER_ERROR    (1UL << 7)  ///< Data transfer CRC failed
N#define ARM_MCI_EVENT_SDIO_INTERRUPT    (1UL << 8)  ///< SD I/O Interrupt
N#define ARM_MCI_EVENT_CCS               (1UL << 9)  ///< Command Completion Signal (CCS)
N#define ARM_MCI_EVENT_CCS_TIMEOUT       (1UL << 10) ///< Command Completion Signal (CCS) Timeout
N
N
N// Function documentation
N/**
N  \fn            ARM_DRIVER_VERSION ARM_MCI_GetVersion (void)
N  \brief         Get driver version.
N  \return        \ref ARM_DRIVER_VERSION
N*/
N/**
N  \fn            ARM_MCI_CAPABILITIES ARM_MCI_GetCapabilities (void)
N  \brief         Get driver capabilities.
N  \return        \ref ARM_MCI_CAPABILITIES
N*/
N/**
N  \fn            int32_t ARM_MCI_Initialize (ARM_MCI_SignalEvent_t cb_event)
N  \brief         Initialize the Memory Card Interface
N  \param[in]     cb_event  Pointer to \ref ARM_MCI_SignalEvent
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_Uninitialize (void)
N  \brief         De-initialize Memory Card Interface.
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_PowerControl (ARM_POWER_STATE state)
N  \brief         Control Memory Card Interface Power.
N  \param[in]     state   Power state \ref ARM_POWER_STATE
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_CardPower (uint32_t voltage)
N  \brief         Set Memory Card Power supply voltage.
N  \param[in]     voltage  Memory Card Power supply voltage
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_ReadCD (void)
N  \brief         Read Card Detect (CD) state.
N  \return        1:card detected, 0:card not detected, or error
N*/
N/**
N  \fn            int32_t ARM_MCI_ReadWP (void)
N  \brief         Read Write Protect (WP) state.
N  \return        1:write protected, 0:not write protected, or error
N*/
N/**
N  \fn            int32_t ARM_MCI_SendCommand (uint32_t  cmd,
N                                              uint32_t  arg,
N                                              uint32_t  flags,
N                                              uint32_t *response)
N  \brief         Send Command to card and get the response.
N  \param[in]     cmd       Memory Card command
N  \param[in]     arg       Command argument
N  \param[in]     flags     Command flags
N  \param[out]    response  Pointer to buffer for response
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_SetupTransfer (uint8_t *data,
N                                                uint32_t block_count,
N                                                uint32_t block_size,
N                                                uint32_t mode)
N  \brief         Setup read or write transfer operation.
N  \param[in,out] data         Pointer to data block(s) to be written or read
N  \param[in]     block_count  Number of blocks
N  \param[in]     block_size   Size of a block in bytes
N  \param[in]     mode         Transfer mode
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_AbortTransfer (void)
N  \brief         Abort current read/write data transfer.
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_Control (uint32_t control, uint32_t arg)
N  \brief         Control MCI Interface.
N  \param[in]     control  Operation
N  \param[in]     arg      Argument of operation (optional)
N  \return        \ref execution_status
N*/
N/**
N  \fn            ARM_MCI_STATUS ARM_MCI_GetStatus (void)
N  \brief         Get MCI status.
N  \return        MCI status \ref ARM_MCI_STATUS
N*/
N
N/**
N  \fn            void ARM_MCI_SignalEvent (uint32_t event)
N  \brief         Callback function that signals a MCI Card Event.
N  \param[in]     event \ref mci_event_gr
N  \return        none
N*/
N
Ntypedef void (*ARM_MCI_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_MCI_SignalEvent : Signal MCI Card Event.
N
N
N/**
N\brief  MCI Driver Capabilities.
N*/
Ntypedef struct _ARM_MCI_CAPABILITIES {
N  uint32_t cd_state          : 1;       ///< Card Detect State available
N  uint32_t cd_event          : 1;       ///< Signal Card Detect change event
N  uint32_t wp_state          : 1;       ///< Write Protect State available
N  uint32_t vdd               : 1;       ///< Supports VDD Card Power Supply Control
N  uint32_t vdd_1v8           : 1;       ///< Supports 1.8 VDD Card Power Supply
N  uint32_t vccq              : 1;       ///< Supports VCCQ Card Power Supply Control (eMMC)
N  uint32_t vccq_1v8          : 1;       ///< Supports 1.8 VCCQ Card Power Supply (eMMC)
N  uint32_t vccq_1v2          : 1;       ///< Supports 1.2 VCCQ Card Power Supply (eMMC)
N  uint32_t data_width_4      : 1;       ///< Supports 4-bit data
N  uint32_t data_width_8      : 1;       ///< Supports 8-bit data
N  uint32_t data_width_4_ddr  : 1;       ///< Supports 4-bit data, DDR (Dual Data Rate) - MMC only
N  uint32_t data_width_8_ddr  : 1;       ///< Supports 8-bit data, DDR (Dual Data Rate) - MMC only
N  uint32_t high_speed        : 1;       ///< Supports SD/MMC High Speed Mode
N  uint32_t uhs_signaling     : 1;       ///< Supports SD UHS-I (Ultra High Speed) 1.8V signaling 
N  uint32_t uhs_tuning        : 1;       ///< Supports SD UHS-I tuning 
N  uint32_t uhs_sdr50         : 1;       ///< Supports SD UHS-I SDR50  (Single Data Rate) up to  50MB/s
N  uint32_t uhs_sdr104        : 1;       ///< Supports SD UHS-I SDR104 (Single Data Rate) up to 104MB/s
N  uint32_t uhs_ddr50         : 1;       ///< Supports SD UHS-I DDR50  (Dual   Data Rate) up to  50MB/s
N  uint32_t uhs_driver_type_a : 1;       ///< Supports SD UHS-I Driver Type A
N  uint32_t uhs_driver_type_c : 1;       ///< Supports SD UHS-I Driver Type C
N  uint32_t uhs_driver_type_d : 1;       ///< Supports SD UHS-I Driver Type D 
N  uint32_t sdio_interrupt    : 1;       ///< Supports SD I/O Interrupt 
N  uint32_t read_wait         : 1;       ///< Supports Read Wait (SD I/O)
N  uint32_t suspend_resume    : 1;       ///< Supports Suspend/Resume (SD I/O)
N  uint32_t mmc_interrupt     : 1;       ///< Supports MMC Interrupt 
N  uint32_t mmc_boot          : 1;       ///< Supports MMC Boot 
N  uint32_t rst_n             : 1;       ///< Supports RST_n Pin Control (eMMC)
N  uint32_t ccs               : 1;       ///< Supports Command Completion Signal (CCS) for CE-ATA
N  uint32_t ccs_timeout       : 1;       ///< Supports Command Completion Signal (CCS) timeout for CE-ATA
N} ARM_MCI_CAPABILITIES;
N
N
N/**
N\brief  Access structure of the MCI Driver.
N*/
Ntypedef struct _ARM_DRIVER_MCI {
N  ARM_DRIVER_VERSION   (*GetVersion)     (void);                           ///< Pointer to \ref ARM_MCI_GetVersion : Get driver version.
N  ARM_MCI_CAPABILITIES (*GetCapabilities)(void);                           ///< Pointer to \ref ARM_MCI_GetCapabilities : Get driver capabilities.
N  int32_t              (*Initialize)     (ARM_MCI_SignalEvent_t cb_event); ///< Pointer to \ref ARM_MCI_Initialize : Initialize MCI Interface.
N  int32_t              (*Uninitialize)   (void);                           ///< Pointer to \ref ARM_MCI_Uninitialize : De-initialize MCI Interface.
N  int32_t              (*PowerControl)   (ARM_POWER_STATE state);          ///< Pointer to \ref ARM_MCI_PowerControl : Control MCI Interface Power.
N  int32_t              (*CardPower)      (uint32_t voltage);               ///< Pointer to \ref ARM_MCI_CardPower : Set card power supply voltage.
N  int32_t              (*ReadCD)         (void);                           ///< Pointer to \ref ARM_MCI_ReadCD : Read Card Detect (CD) state.
N  int32_t              (*ReadWP)         (void);                           ///< Pointer to \ref ARM_MCI_ReadWP : Read Write Protect (WP) state.
N  int32_t              (*SendCommand)    (uint32_t cmd, 
N                                          uint32_t arg, 
N                                          uint32_t flags,
N                                          uint32_t *response);             ///< Pointer to \ref ARM_MCI_SendCommand : Send Command to card and get the response.
N  int32_t              (*SetupTransfer)  (uint8_t *data,
N                                          uint32_t block_count,
N                                          uint32_t block_size,
N                                          uint32_t mode);                  ///< Pointer to \ref ARM_MCI_SetupTransfer : Setup data transfer operation.
N  int32_t              (*AbortTransfer)  (void);                           ///< Pointer to \ref ARM_MCI_AbortTransfer : Abort current data transfer.
N  int32_t              (*Control)        (uint32_t control, uint32_t arg); ///< Pointer to \ref ARM_MCI_Control : Control MCI Interface.
N  ARM_MCI_STATUS       (*GetStatus)      (void);                           ///< Pointer to \ref ARM_MCI_GetStatus : Get MCI status.
N} const ARM_DRIVER_MCI;
N
N#endif /* __DRIVER_MCI_H */
L 15 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N  #include "Driver_SPI.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_SPI.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        17. Apr 2014
N * $Revision:    V2.01
N *
N * Project:      SPI (Serial Peripheral Interface) Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.01
N *    Renamed status flag "tx_rx_busy" to "busy"
N *  Version 2.00
N *    New simplified driver:
N *      complexity moved to upper layer (especially data handling)
N *      more unified API for different communication interfaces
N *    Added:
N *      Slave Mode
N *      Half-duplex Modes
N *      Configurable number of data bits
N *      Support for TI Mode and Microwire
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.01
N *    Added "send_done_event" to Capabilities
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_SPI_H
N#define __DRIVER_SPI_H
N
N#include "Driver_Common.h"
N
N#define ARM_SPI_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,00)  /* API version */
N
N
N/****** SPI Control Codes *****/
N
N#define ARM_SPI_CONTROL_Pos              0
N#define ARM_SPI_CONTROL_Msk             (0xFFUL << ARM_SPI_CONTROL_Pos)
N
N/*----- SPI Control Codes: Mode -----*/
N#define ARM_SPI_MODE_INACTIVE           (0x00UL << ARM_SPI_CONTROL_Pos)     ///< SPI Inactive
N#define ARM_SPI_MODE_MASTER             (0x01UL << ARM_SPI_CONTROL_Pos)     ///< SPI Master (Output on MOSI, Input on MISO); arg = Bus Speed in bps
N#define ARM_SPI_MODE_SLAVE              (0x02UL << ARM_SPI_CONTROL_Pos)     ///< SPI Slave  (Output on MISO, Input on MOSI)
N#define ARM_SPI_MODE_MASTER_SIMPLEX     (0x03UL << ARM_SPI_CONTROL_Pos)     ///< SPI Master (Output/Input on MOSI); arg = Bus Speed in bps
N#define ARM_SPI_MODE_SLAVE_SIMPLEX      (0x04UL << ARM_SPI_CONTROL_Pos)     ///< SPI Slave  (Output/Input on MISO)
N
N/*----- SPI Control Codes: Mode Parameters: Frame Format -----*/
N#define ARM_SPI_FRAME_FORMAT_Pos         8
N#define ARM_SPI_FRAME_FORMAT_Msk        (7UL << ARM_SPI_FRAME_FORMAT_Pos)
N#define ARM_SPI_CPOL0_CPHA0             (0UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 0, Clock Phase 0 (default)
N#define ARM_SPI_CPOL0_CPHA1             (1UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 0, Clock Phase 1
N#define ARM_SPI_CPOL1_CPHA0             (2UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 1, Clock Phase 0
N#define ARM_SPI_CPOL1_CPHA1             (3UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 1, Clock Phase 1
N#define ARM_SPI_TI_SSI                  (4UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Texas Instruments Frame Format
N#define ARM_SPI_MICROWIRE               (5UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< National Microwire Frame Format
N
N/*----- SPI Control Codes: Mode Parameters: Data Bits -----*/
N#define ARM_SPI_DATA_BITS_Pos            12
N#define ARM_SPI_DATA_BITS_Msk           (0x3FUL << ARM_SPI_DATA_BITS_Pos)
N#define ARM_SPI_DATA_BITS(n)            (((n) & 0x3F) << ARM_SPI_DATA_BITS_Pos) ///< Number of Data bits
N
N/*----- SPI Control Codes: Mode Parameters: Bit Order -----*/
N#define ARM_SPI_BIT_ORDER_Pos            18
N#define ARM_SPI_BIT_ORDER_Msk           (1UL << ARM_SPI_BIT_ORDER_Pos)
N#define ARM_SPI_MSB_LSB                 (0UL << ARM_SPI_BIT_ORDER_Pos)      ///< SPI Bit order from MSB to LSB (default)
N#define ARM_SPI_LSB_MSB                 (1UL << ARM_SPI_BIT_ORDER_Pos)      ///< SPI Bit order from LSB to MSB
N
N/*----- SPI Control Codes: Mode Parameters: Slave Select Mode -----*/
N#define ARM_SPI_SS_MASTER_MODE_Pos       19
N#define ARM_SPI_SS_MASTER_MODE_Msk      (3UL << ARM_SPI_SS_MASTER_MODE_Pos)
N#define ARM_SPI_SS_MASTER_UNUSED        (0UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Not used (default)
N#define ARM_SPI_SS_MASTER_SW            (1UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Software controlled
N#define ARM_SPI_SS_MASTER_HW_OUTPUT     (2UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Hardware controlled Output
N#define ARM_SPI_SS_MASTER_HW_INPUT      (3UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Hardware monitored Input
N#define ARM_SPI_SS_SLAVE_MODE_Pos        21
N#define ARM_SPI_SS_SLAVE_MODE_Msk       (1UL << ARM_SPI_SS_SLAVE_MODE_Pos)
N#define ARM_SPI_SS_SLAVE_HW             (0UL << ARM_SPI_SS_SLAVE_MODE_Pos)  ///< SPI Slave Select when Slave: Hardware monitored (default)
N#define ARM_SPI_SS_SLAVE_SW             (1UL << ARM_SPI_SS_SLAVE_MODE_Pos)  ///< SPI Slave Select when Slave: Software controlled
N
N
N/*----- SPI Control Codes: Miscellaneous Controls  -----*/
N#define ARM_SPI_SET_BUS_SPEED           (0x10UL << ARM_SPI_CONTROL_Pos)     ///< Set Bus Speed in bps; arg = value
N#define ARM_SPI_GET_BUS_SPEED           (0x11UL << ARM_SPI_CONTROL_Pos)     ///< Get Bus Speed in bps
N#define ARM_SPI_SET_DEFAULT_TX_VALUE    (0x12UL << ARM_SPI_CONTROL_Pos)     ///< Set default Transmit value; arg = value
N#define ARM_SPI_CONTROL_SS              (0x13UL << ARM_SPI_CONTROL_Pos)     ///< Control Slave Select; arg: 0=inactive, 1=active 
N#define ARM_SPI_ABORT_TRANSFER          (0x14UL << ARM_SPI_CONTROL_Pos)     ///< Abort current data transfer
N
N
N/****** SPI Slave Select Signal definitions *****/
N#define ARM_SPI_SS_INACTIVE              0                                  ///< SPI Slave Select Signal Inactive
N#define ARM_SPI_SS_ACTIVE                1                                  ///< SPI Slave Select Signal Active
N
N
N/****** SPI specific error codes *****/
N#define ARM_SPI_ERROR_MODE              (ARM_DRIVER_ERROR_SPECIFIC - 1)     ///< Specified Mode not supported
N#define ARM_SPI_ERROR_FRAME_FORMAT      (ARM_DRIVER_ERROR_SPECIFIC - 2)     ///< Specified Frame Format not supported
N#define ARM_SPI_ERROR_DATA_BITS         (ARM_DRIVER_ERROR_SPECIFIC - 3)     ///< Specified number of Data bits not supported
N#define ARM_SPI_ERROR_BIT_ORDER         (ARM_DRIVER_ERROR_SPECIFIC - 4)     ///< Specified Bit order not supported
N#define ARM_SPI_ERROR_SS_MODE           (ARM_DRIVER_ERROR_SPECIFIC - 5)     ///< Specified Slave Select Mode not supported
N
N
N/**
N\brief SPI Status
N*/
Ntypedef struct _ARM_SPI_STATUS {
N  uint32_t busy       : 1;              ///< Transmitter/Receiver busy flag
N  uint32_t data_lost  : 1;              ///< Data lost: Receive overflow / Transmit underflow (cleared on start of transfer operation)
N  uint32_t mode_fault : 1;              ///< Mode fault detected; optional (cleared on start of transfer operation)
N} ARM_SPI_STATUS;
N
N
N/****** SPI Event *****/
N#define ARM_SPI_EVENT_TRANSFER_COMPLETE (1UL << 0)  ///< Data Transfer completed
N#define ARM_SPI_EVENT_DATA_LOST         (1UL << 1)  ///< Data lost: Receive overflow / Transmit underflow
N#define ARM_SPI_EVENT_MODE_FAULT        (1UL << 2)  ///< Master Mode Fault (SS deactivated when Master)
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_SPI_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N
N  \fn          ARM_SPI_CAPABILITIES ARM_SPI_GetCapabilities (void)
N  \brief       Get driver capabilities.
N  \return      \ref ARM_SPI_CAPABILITIES
N
N  \fn          int32_t ARM_SPI_Initialize (ARM_SPI_SignalEvent_t cb_event)
N  \brief       Initialize SPI Interface.
N  \param[in]   cb_event  Pointer to \ref ARM_SPI_SignalEvent
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Uninitialize (void)
N  \brief       De-initialize SPI Interface.
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_PowerControl (ARM_POWER_STATE state)
N  \brief       Control SPI Interface Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Send (const void *data, uint32_t num)
N  \brief       Start sending data to SPI transmitter.
N  \param[in]   data  Pointer to buffer with data to send to SPI transmitter
N  \param[in]   num   Number of data items to send
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Receive (void *data, uint32_t num)
N  \brief       Start receiving data from SPI receiver.
N  \param[out]  data  Pointer to buffer for data to receive from SPI receiver
N  \param[in]   num   Number of data items to receive
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Transfer (const void *data_out,
N                                               void *data_in,
N                                         uint32_t    num)
N  \brief       Start sending/receiving data to/from SPI transmitter/receiver.
N  \param[in]   data_out  Pointer to buffer with data to send to SPI transmitter
N  \param[out]  data_in   Pointer to buffer for data to receive from SPI receiver
N  \param[in]   num       Number of data items to transfer
N  \return      \ref execution_status
N
N  \fn          uint32_t ARM_SPI_GetDataCount (void)
N  \brief       Get transferred data count.
N  \return      number of data items transferred
N
N  \fn          int32_t ARM_SPI_Control (uint32_t control, uint32_t arg)
N  \brief       Control SPI Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      common \ref execution_status and driver specific \ref spi_execution_status
N
N  \fn          ARM_SPI_STATUS ARM_SPI_GetStatus (void)
N  \brief       Get SPI status.
N  \return      SPI status \ref ARM_SPI_STATUS
N
N  \fn          void ARM_SPI_SignalEvent (uint32_t event)
N  \brief       Signal SPI Events.
N  \param[in]   event \ref SPI_events notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_SPI_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_SPI_SignalEvent : Signal SPI Event.
N
N
N/**
N\brief SPI Driver Capabilities.
N*/
Ntypedef struct _ARM_SPI_CAPABILITIES {
N  uint32_t simplex          : 1;        ///< supports Simplex Mode (Master and Slave)
N  uint32_t ti_ssi           : 1;        ///< supports TI Synchronous Serial Interface
N  uint32_t microwire        : 1;        ///< supports Microwire Interface
N  uint32_t event_mode_fault : 1;        ///< Signal Mode Fault event: \ref ARM_SPI_EVENT_MODE_FAULT
N} ARM_SPI_CAPABILITIES;
N
N
N/**
N\brief Access structure of the SPI Driver.
N*/
Ntypedef struct _ARM_DRIVER_SPI {
N  ARM_DRIVER_VERSION   (*GetVersion)      (void);                             ///< Pointer to \ref ARM_SPI_GetVersion : Get driver version.
N  ARM_SPI_CAPABILITIES (*GetCapabilities) (void);                             ///< Pointer to \ref ARM_SPI_GetCapabilities : Get driver capabilities.
N  int32_t              (*Initialize)      (ARM_SPI_SignalEvent_t cb_event);   ///< Pointer to \ref ARM_SPI_Initialize : Initialize SPI Interface.
N  int32_t              (*Uninitialize)    (void);                             ///< Pointer to \ref ARM_SPI_Uninitialize : De-initialize SPI Interface.
N  int32_t              (*PowerControl)    (ARM_POWER_STATE state);            ///< Pointer to \ref ARM_SPI_PowerControl : Control SPI Interface Power.
N  int32_t              (*Send)            (const void *data, uint32_t num);   ///< Pointer to \ref ARM_SPI_Send : Start sending data to SPI Interface.
N  int32_t              (*Receive)         (      void *data, uint32_t num);   ///< Pointer to \ref ARM_SPI_Receive : Start receiving data from SPI Interface.
N  int32_t              (*Transfer)        (const void *data_out,
N                                                 void *data_in,
N                                           uint32_t    num);                  ///< Pointer to \ref ARM_SPI_Transfer : Start sending/receiving data to/from SPI.
N  uint32_t             (*GetDataCount)    (void);                             ///< Pointer to \ref ARM_SPI_GetDataCount : Get transferred data count.
N  int32_t              (*Control)         (uint32_t control, uint32_t arg);   ///< Pointer to \ref ARM_SPI_Control : Control SPI Interface.
N  ARM_SPI_STATUS       (*GetStatus)       (void);                             ///< Pointer to \ref ARM_SPI_GetStatus : Get SPI status.
N} const ARM_DRIVER_SPI;
N
N#endif /* __DRIVER_SPI_H */
L 16 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N#else
S  #define ARM_DRIVER_MCI          uint32_t
S  #define ARM_MCI_SignalEvent_t   uint32_t
S  #define ARM_MCI_CAPABILITIES    uint32_t
S  #define ARM_DRIVER_SPI          uint32_t
S  #define ARM_SPI_SignalEvent_t   uint32_t
S  #define ARM_SPI_CAPABILITIES    uint32_t
N#endif
N
N#if defined(RTE_FileSystem_Drive_NAND_0) || defined(RTE_FileSystem_Drive_NAND_1)
X#if 0L || 0L
S  #include "Driver_NAND.h"
N#else
N  #define ARM_DRIVER_NAND         uint32_t
N  #define ARM_NAND_SignalEvent_t  uint32_t
N  #define ARM_NAND_CAPABILITIES   uint32_t
N#endif
N
N#if defined(RTE_FileSystem_Drive_NOR_0) || defined(RTE_FileSystem_Drive_NOR_1)
X#if 0L || 0L
S  #include "Driver_Flash.h"
N#else
N  #define ARM_DRIVER_FLASH        uint32_t
N  #define ARM_Flash_SignalEvent_t uint32_t
N  #define ARM_FLASH_CAPABILITIES  uint32_t
N  #define ARM_FLASH_SECTOR        uint32_t
N#endif
N
N#include "rl_fs.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_fs.h
N * Purpose: File System API
N * Rev.:    V6.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_FS_H
N#define __RL_FS_H
N
N#include <stdint.h>
N#include <stdbool.h>
N
N// ==== Enumeration, structures, defines ====
N
N/// FAT File Attribute bit masks.
N#define FS_FAT_ATTR_READ_ONLY    0x01   ///< Read-only file attribute
N#define FS_FAT_ATTR_HIDDEN       0x02   ///< Hidden file attribute
N#define FS_FAT_ATTR_SYSTEM       0x04   ///< System file attribute
N#define FS_FAT_ATTR_VOLUME_ID    0x08   ///< Volume ID attribute
N#define FS_FAT_ATTR_DIRECTORY    0x10   ///< Directory file attribute
N#define FS_FAT_ATTR_ARCHIVE      0x20   ///< Archive file attribute
N
N/// IOC control code fsDevCtrlCodeCheckMedia return bit masks.
N#define FS_MEDIA_INSERTED        0x01   ///< Media Detected
N#define FS_MEDIA_PROTECTED       0x02   ///< Media Write Protected
N#define FS_MEDIA_INITIALIZED     0x04   ///< Media Initialized
N#define FS_MEDIA_NOCHKMEDIA      0x80   ///< Check Media Not implemented
N
N/// IOC control code fsDevCtrlCodeControlMedia argument values.
N#define FS_CONTROL_MEDIA_INIT    0x00   ///< Initialize media device
N#define FS_CONTROL_EMMC_SLEEP    0x01   ///< Switch eMMC device to Sleep State
N#define FS_CONTROL_EMMC_AWAKE    0x02   ///< Wake-up eMMC device from Sleep State
N
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// File System return codes.
Ntypedef enum {
N  fsOK = 0,                             ///< Operation succeeded
N  fsError,                              ///< Unspecified error
N  fsUnsupported,                        ///< Operation not supported
N  fsAccessDenied,                       ///< Resource access denied
N  fsInvalidParameter,                   ///< Invalid parameter specified
N  fsInvalidDrive,                       ///< Nonexistent drive
N  fsInvalidPath,                        ///< Invalid path specified
N  fsUninitializedDrive,                 ///< Drive is uninitialized
N  fsDriverError,                        ///< Read/write error
N  fsMediaError,                         ///< Media error
N  fsNoMedia,                            ///< No media, or not initialized
N  fsNoFileSystem,                       ///< File system is not formatted
N  fsNoFreeSpace,                        ///< No free space available
N  fsFileNotFound,                       ///< Requested file not found
N  fsDirNotEmpty,                        ///< The directory is not empty
N  fsTooManyOpenFiles                    ///< Too many open files
N} fsStatus;
N
N/// File System Type.
Ntypedef enum _fsType {
N  fsTypeNone = 0,                       ///< No file system (volume unformatted)
N  fsTypeUnknown,                        ///< File system type is unknown
N  fsTypeFAT12,                          ///< File system type is FAT12
N  fsTypeFAT16,                          ///< File system type is FAT16
N  fsTypeFAT32,                          ///< File system type is FAT32
N  fsTypeEFS                             ///< File system type is EFS
N} fsType;
N
N/// Driver DeviceCtrl parameter code.
Ntypedef enum _fsDevCtrlCode {
N  fsDevCtrlCodeCheckMedia = 0,          ///< Check Media Status
N  fsDevCtrlCodeControlMedia,            ///< Control Media Device
N  fsDevCtrlCodeFormat,                  ///< Format Media at low level
N  fsDevCtrlCodeSerial,                  ///< Return device serial number
N  fsDevCtrlCodeGetCID                   ///< Read Memory Card CID Register
N} fsDevCtrlCode;
N
N/// Media information.
Ntypedef struct _fsMediaInfo {
N  uint32_t  block_cnt;                  ///< Total number of blocks on the volume
N  uint16_t  read_blen;                  ///< Read block length
N  uint16_t  write_blen;                 ///< Write block length
N} fsMediaInfo;
N
N/// IO Control Cache information.
Ntypedef struct _fsIOC_Cache {
N  uint8_t *buffer;                      ///< Cache Buffer (4 byte aligned)
N  uint32_t size;                        ///< Cache Buffer size in bytes
N} fsIOC_Cache;
N
N/// Memory card CID register.
Ntypedef struct _fsCID_Register {
N  uint32_t   PSN;                       ///< Product serial number
N  uint16_t   OID;                       ///< OEM/Application ID
N  uint8_t    MID;                       ///< Manufacturer ID
N  uint8_t    PRV;                       ///< Product revision
N  uint16_t   MDT;                       ///< Manufacturing date
N  uint8_t    PNM[6];                    ///< Product name
N} fsCID_Register;
N
N/// File System Time structure.
Ntypedef struct _fsTime {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} fsTime;
N
N/// File information data.
Ntypedef struct _fsFileInfo {
N  char     name[256];                   ///< Filename path
N  uint32_t size;                        ///< File size in bytes
N  uint16_t fileID;                      ///< System Identification
N  uint8_t  attrib;                      ///< Attributes
N  fsTime   time;                        ///< Create/Modify Time
N} fsFileInfo;
N
N/// Drive information.
Ntypedef struct _fsDriveInfo {
N  fsType   fs_type;                     ///< Drives file system type
N  uint64_t capacity;                    ///< Drives capacity in bytes
N} fsDriveInfo;
N
N
N//  ==== System Routines ====
N
N/// \brief Initialize File System and drive related driver.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Failed to initialize the driver.
Nextern fsStatus finit (const char *drive);
N
N/// \brief Uninitialize File System.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funinit (const char *drive);
N
N/// \brief Mount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsUninitializedDrive = Media driver not initialized.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Media driver operation failed.
N///               - fsMediaError       = Failed to initialize the media.
N///               - fsNoMedia          = Media device is not insterted.
N///               - fsNoFileSystem     = No filesystem on the volume.
Nextern fsStatus fmount (const char *drive);
N
N/// \brief Unmount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funmount (const char *drive);
N
N
N//  ==== File Maintenance Routines ====
N
N/// \brief Delete one or multiple files.
N/// \param[in]  path                     a string specifying the file or directory.
N/// \param[in]  options                  a string specifying function options.
N/// \return     execution status \ref fsStatus
N#ifdef MW_FILESYSTEM_FDELETE_LEGACY
Sextern fsStatus fdelete (const char *path);
N#else
Nextern fsStatus fdelete (const char *path, const char *options);
N#endif
N
N
N/// \brief Find a file or directory matching search pattern.
N/// \param[in]  pattern                  string specifying the pattern.
N///                                      - May include drive prefix and the following wildcards:
N///                                      - "*" or "*.*" searches for all files in the directory.
N///                                      - "abc*"       searches for files that begin with abc.
N///                                      - "*.htm"      searches for files that end with .htm.
N///                                      - "abc*.text"  searches for files that begin with abc and that end with .text.
N/// \param[out] info                     structure storing information about matching files.
N/// \return     execution status \ref fsStatus
Nextern fsStatus ffind (const char *pattern, fsFileInfo *info);
N
N/// \brief Rename a file or directory with given path name to a new name.
N/// \param[in]  path                     string specifying the file or directory path.
N/// \param[in]  newname                  string specifying new file or directory name.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frename (const char *path, const char *newname);
N
N/// \brief Change file attributes.
N/// \param[in]  path                     string specifying file or directory path.
N/// \param[in]  attr                     string specifying file or directory attributes to be modified.
N///                                      The following characters are allowed within attr string:
N///                                      - + Sets an attribute.
N///                                      - - Clears an attribute.
N///                                      - R Read-only file attribute.
N///                                      - A Archive file attribute.
N///                                      - S System file attribute.
N///                                      - H Hidden file attribute.
N/// \return     execution status \ref fsStatus
N/// \note       This function supports FAT drives only.
Nextern fsStatus fattrib (const char *path, const char *attr);
N
N
N//  ==== Directory Maintenance Routines ====
N
N/// \brief Print working directory.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] buf                      pointer to string buffer.
N/// \param[in]  len                      string buffer length.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fpwd (const char *drive, char *buf, uint32_t len);
N
N/// \brief Change working directory.
N/// \param[in]  path                     string specifying the directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdir (const char *path);
N
N/// \brief Create a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fmkdir (const char *path);
N
N/// \brief Remove a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \param[in]  options                  string specifying function options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frmdir (const char *path, const char *options);
N
N
N//  ==== Utility Routines ====
N
N/// \brief Change current drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdrive (const char *drive);
N
N/// \brief Find free space on drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     free space or execution status
N///             - value >= 0: free space on drive in bytes.
N///             - value < 0:  error occurred, -value is execution status as defined with \ref fsStatus
Nextern int64_t ffree (const char *drive);
N
N/// \brief Format drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[in]  options                  string specifying formatting options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fformat (const char *drive, const char *options);
N
N/// \brief Analyse volume and check for file fragmentation.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     fragmentation factor or execution status
N///             - value >= 0 or <= 255: fragmentation factor
N///             - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
N/// \note       This function supports EFS drives only.
Nextern int32_t fanalyse (const char *drive);
N
N/// \brief Analyse volume and check for allocation errors.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful, no allocation errors
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Unsupported drive.
N///               - fsError            = Check failed due to allocation errors.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fcheck (const char *drive);
N
N/// \brief Defragment Embedded Flash drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Not all files are closed on specified drive or unsupported drive.
N///               - fsNoFreeSpace      = Not enough space to complete the defragmentation.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fdefrag (const char *drive);
N
N/// \brief Check if media present on removable drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = Tried to access non-removable drive.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fmedia (const char *drive);
N
N/// \brief Read drive information.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] info                     drive information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus finfo (const char *drive, fsDriveInfo *info);
N
N/// \brief Read volume label and serial number.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] label                    buffer for storing label as a null terminated string.
N///                                      When volume has no label an empty string is returned.
N///                                      This parameter can be NULL meaning label will not be read.
N/// \param[out] serial                   pointer to variable where serial number will be stored.
N///                                      This parameter can be NULL meaning serial number will not be read.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Trying to read label and serial from EFS drive.
N///               - fsDriverError      = Read/write error.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fvol (const char *drive, char *label, uint32_t *serial);
N
N
N//  ==== File Time Support Routines ====
N
N/// \brief Callback function used to provide the current date and time to the File System.
N/// \param[out] time                     Pointer to the \ref fsTime structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsError            = Failed to get the current time
N/// \note       This function supports FAT drives only.
Nextern fsStatus fs_get_time (fsTime *time);
N
N
N//  ==== Media Support Routines ====
N
N/// \brief   Callback function used to read Card Detect (CD) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:card detected, 0:card not detected, or error
Nextern int32_t fs_mc_read_cd (uint32_t drive_num);
N
N/// \brief   Callback function used to read Write Protect (WP) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:write protected, 0:not write protected, or error
Nextern int32_t fs_mc_read_wp (uint32_t drive_num);
N
N/// \brief   Callback function used to control Slave Select signal when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \param[in]  ss                       Slave select signal state
N/// \return     execution status
N///               - slave select signal state: 1:active, 0:inactive
N///               - -1: slave select signal control is not implemented
Nextern int32_t fs_mc_spi_control_ss (uint32_t drive_num, uint32_t ss);
N
N
N//  ==== I/O Control Interface Routines ====
N
N/// \brief Check if valid drive is specified and return its ID.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     drive ID or execution status
N///               - value >= 0: drive ID as an integer when specified drive exists and allows IOC access
N///               - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
Nextern int32_t fs_ioc_get_id (const char *drive);
N
N/// \brief Lock drive and block media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_lock (int32_t drv_id);
N
N/// \brief Unlock drive and allow media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_unlock (int32_t drv_id);
N
N/// \brief Return IOC cache buffer information.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] cache_info               IOC Cache information.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters are not valid.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_get_cache (int32_t drv_id, fsIOC_Cache *cache_info);
N
N/// \brief Read sector from media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_read_sector (int32_t drv_id, uint32_t sect, uint8_t *buf, uint32_t cnt);
N
N/// \brief Write sector to media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_write_sector (int32_t drv_id, uint32_t sect, const uint8_t *buf, uint32_t cnt);
N
N/// \brief Read media configuration info.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] info                     Media information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Media information read failed.
Nextern fsStatus fs_ioc_read_info (int32_t drv_id, fsMediaInfo *info);
N
N/// \brief IOC device control access; control code is sent directly to device driver.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  code                     Device control code.
N/// \param[in,out] p                     Generic pointer.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fs_ioc_device_ctrl (int32_t drv_id, fsDevCtrlCode code, void *p);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_FS_H */
L 43 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N#include "cmsis_os.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 1
N/* ----------------------------------------------------------------------
N * $Date:        5. February 2013
N * $Revision:    V1.02
N *
N * Project:      CMSIS-RTOS API
N * Title:        cmsis_os.h RTX header file
N *
N * Version 0.02
N *    Initial Proposal Phase
N * Version 0.03
N *    osKernelStart added, optional feature: main started as thread
N *    osSemaphores have standard behavior
N *    osTimerCreate does not start the timer, added osTimerStart
N *    osThreadPass is renamed to osThreadYield
N * Version 1.01
N *    Support for C++ interface
N *     - const attribute removed from the osXxxxDef_t typedef's
N *     - const attribute added to the osXxxxDef macros
N *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
N *    Added: osKernelInitialize
N * Version 1.02
N *    Control functions for short timeouts in microsecond resolution:
N *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
N *    Removed: osSignalGet 
N *----------------------------------------------------------------------------
N *
N * Copyright (c) 2013 ARM LIMITED
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *  - Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *  - Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *  - Neither the name of ARM  nor the names of its contributors may be used
N *    to endorse or promote products derived from this software without
N *    specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *---------------------------------------------------------------------------*/
N
N
N#ifndef _CMSIS_OS_H
N#define _CMSIS_OS_H
N
N#define osCMSIS           0x10002      ///< CMSIS-RTOS API version (main [31:16] .sub [15:0])
N
N#define osCMSIS_RTX     ((4<<16)|78)   ///< RTOS identification and version (main [31:16] .sub [15:0])
N
N#define osKernelSystemId "RTX V4.78"   ///< RTOS identification string
N
N
N#define osFeature_MainThread   1       ///< main can be thread
N#define osFeature_Pool         1       ///< Memory Pools available
N#define osFeature_MailQ        1       ///< Mail Queues available
N#define osFeature_MessageQ     1       ///< Message Queues available
N#define osFeature_Signals      16      ///< 16 Signal Flags available per thread
N#define osFeature_Semaphore    65535   ///< Maximum count for \ref osSemaphoreCreate function
N#define osFeature_Wait         0       ///< osWait not available
N#define osFeature_SysTick      1       ///< osKernelSysTick functions available
N
N#if defined (__CC_ARM)
X#if 1L
N#define os_InRegs __value_in_regs      // Compiler specific: force struct in registers
N#else
S#define os_InRegs
N#endif
N
N#include <stdint.h>
N#include <stddef.h>
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N// ==== Enumeration, structures, defines ====
N
N/// Priority used for thread control.
Ntypedef enum  {
N  osPriorityIdle          = -3,          ///< priority: idle (lowest)
N  osPriorityLow           = -2,          ///< priority: low
N  osPriorityBelowNormal   = -1,          ///< priority: below normal
N  osPriorityNormal        =  0,          ///< priority: normal (default)
N  osPriorityAboveNormal   = +1,          ///< priority: above normal
N  osPriorityHigh          = +2,          ///< priority: high
N  osPriorityRealtime      = +3,          ///< priority: realtime (highest)
N  osPriorityError         =  0x84        ///< system cannot determine priority or thread has illegal priority
N} osPriority;
N
N/// Timeout value.
N#define osWaitForever     0xFFFFFFFF     ///< wait forever timeout value
N
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum  {
N  osOK                    =     0,       ///< function completed; no error or event occurred.
N  osEventSignal           =  0x08,       ///< function completed; signal event occurred.
N  osEventMessage          =  0x10,       ///< function completed; message event occurred.
N  osEventMail             =  0x20,       ///< function completed; mail event occurred.
N  osEventTimeout          =  0x40,       ///< function completed; timeout occurred.
N  osErrorParameter        =  0x80,       ///< parameter error: a mandatory parameter was missing or specified an incorrect object.
N  osErrorResource         =  0x81,       ///< resource not available: a specified resource was not available.
N  osErrorTimeoutResource  =  0xC1,       ///< resource not available within given time: a specified resource was not available within the timeout period.
N  osErrorISR              =  0x82,       ///< not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osErrorISRRecursive     =  0x83,       ///< function called multiple times from ISR with same object.
N  osErrorPriority         =  0x84,       ///< system cannot determine priority or thread has illegal priority.
N  osErrorNoMemory         =  0x85,       ///< system is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorValue            =  0x86,       ///< value of a parameter is out of range.
N  osErrorOS               =  0xFF,       ///< unspecified RTOS error: run-time error but no other error message fits.
N  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osStatus;
N
N
N/// Timer type value for the timer definition.
Ntypedef enum  {
N  osTimerOnce             =     0,       ///< one-shot timer
N  osTimerPeriodic         =     1        ///< repeating timer
N} os_timer_type;
N
N/// Entry point of a thread.
Ntypedef void (*os_pthread) (void const *argument);
N
N/// Entry point of a timer call back function.
Ntypedef void (*os_ptimer) (void const *argument);
N
N// >>> the following data type definitions may shall adapted towards a specific RTOS
N
N/// Thread ID identifies the thread (pointer to a thread control block).
Ntypedef struct os_thread_cb *osThreadId;
N
N/// Timer ID identifies the timer (pointer to a timer control block).
Ntypedef struct os_timer_cb *osTimerId;
N
N/// Mutex ID identifies the mutex (pointer to a mutex control block).
Ntypedef struct os_mutex_cb *osMutexId;
N
N/// Semaphore ID identifies the semaphore (pointer to a semaphore control block).
Ntypedef struct os_semaphore_cb *osSemaphoreId;
N
N/// Pool ID identifies the memory pool (pointer to a memory pool control block).
Ntypedef struct os_pool_cb *osPoolId;
N
N/// Message ID identifies the message queue (pointer to a message queue control block).
Ntypedef struct os_messageQ_cb *osMessageQId;
N
N/// Mail ID identifies the mail queue (pointer to a mail queue control block).
Ntypedef struct os_mailQ_cb *osMailQId;
N
N
N/// Thread Definition structure contains startup information of a thread.
Ntypedef struct os_thread_def  {
N  os_pthread               pthread;    ///< start address of thread function
N  osPriority             tpriority;    ///< initial thread priority
N  uint32_t               instances;    ///< maximum number of instances of that thread function
N  uint32_t               stacksize;    ///< stack size requirements in bytes; 0 is default stack size
N} osThreadDef_t;
N
N/// Timer Definition structure contains timer parameters.
Ntypedef struct os_timer_def  {
N  os_ptimer                 ptimer;    ///< start address of a timer function
N  void                      *timer;    ///< pointer to internal data
N} osTimerDef_t;
N
N/// Mutex Definition structure contains setup information for a mutex.
Ntypedef struct os_mutex_def  {
N  void                      *mutex;    ///< pointer to internal data
N} osMutexDef_t;
N
N/// Semaphore Definition structure contains setup information for a semaphore.
Ntypedef struct os_semaphore_def  {
N  void                  *semaphore;    ///< pointer to internal data
N} osSemaphoreDef_t;
N
N/// Definition structure for memory block allocation.
Ntypedef struct os_pool_def  {
N  uint32_t                 pool_sz;    ///< number of items (elements) in the pool
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< pointer to memory for pool
N} osPoolDef_t;
N
N/// Definition structure for message queue.
Ntypedef struct os_messageQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  void                       *pool;    ///< memory array for messages
N} osMessageQDef_t;
N
N/// Definition structure for mail queue.
Ntypedef struct os_mailQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< memory array for mail
N} osMailQDef_t;
N
N/// Event structure contains detailed information about an event.
Ntypedef struct  {
N  osStatus                 status;     ///< status code: event or error information
N  union  {
N    uint32_t                    v;     ///< message as 32-bit value
N    void                       *p;     ///< message or mail as void pointer
N    int32_t               signals;     ///< signal flags
N  } value;                             ///< event value
N  union  {
N    osMailQId             mail_id;     ///< mail id obtained by \ref osMailCreate
N    osMessageQId       message_id;     ///< message id obtained by \ref osMessageCreate
N  } def;                               ///< event definition
N} osEvent;
N
N
N//  ==== Kernel Control Functions ====
N
N/// Initialize the RTOS Kernel for creating objects.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelInitialize (void);
N
N/// Start the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelStart (void);
N
N/// Check if the RTOS kernel is already started.
N/// \return 0 RTOS is not started, 1 RTOS is started.
Nint32_t osKernelRunning(void);
N
N#if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
X#if (1L  &&  (1 != 0))     
N
N/// \cond INTERNAL_VARIABLES
Nextern uint32_t const os_tickfreq;
Nextern uint16_t const os_tickus_i;
Nextern uint16_t const os_tickus_f;
N/// \endcond
N
N/// Get the RTOS kernel system timer counter.
N/// \return RTOS kernel system timer as 32-bit value 
Nuint32_t osKernelSysTick (void);
N
N/// The RTOS kernel system timer frequency in Hz.
N/// \note Reflects the system timer setting and is typically defined in a configuration file.
N#define osKernelSysTickFrequency os_tickfreq
N
N/// Convert a microseconds value to a RTOS kernel system timer value.
N/// \param         microsec     time value in microseconds.
N/// \return time value normalized to the \ref osKernelSysTickFrequency
N/*
N#define osKernelSysTickMicroSec(microsec) (((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)
N*/
N#define osKernelSysTickMicroSec(microsec) ((microsec * os_tickus_i) + ((microsec * os_tickus_f) >> 16))
N
N#endif    // System Timer available
N
N//  ==== Thread Management ====
N
N/// Create a Thread Definition with function, priority, and stack requirements.
N/// \param         name         name of the thread function.
N/// \param         priority     initial priority of the thread function.
N/// \param         instances    number of possible thread instances.
N/// \param         stacksz      stack size (in bytes) requirements for the thread function.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osThreadDef(name, priority, instances, stacksz)  \
Sextern const osThreadDef_t os_thread_def_##name
X#define osThreadDef(name, priority, instances, stacksz)  extern const osThreadDef_t os_thread_def_##name
N#else                            // define the object
N#define osThreadDef(name, priority, instances, stacksz)  \
Nconst osThreadDef_t os_thread_def_##name = \
N{ (name), (priority), (instances), (stacksz)  }
X#define osThreadDef(name, priority, instances, stacksz)  const osThreadDef_t os_thread_def_##name = { (name), (priority), (instances), (stacksz)  }
N#endif
N
N/// Access a Thread definition.
N/// \param         name          name of the thread definition object.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#define osThread(name)  \
N&os_thread_def_##name
X#define osThread(name)  &os_thread_def_##name
N
N/// Create a thread and add it to Active Threads and set it to state READY.
N/// \param[in]     thread_def    thread definition referenced with \ref osThread.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument);
N
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadGetId (void);
N
N/// Terminate execution of a thread and remove it from Active Threads.
N/// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadTerminate (osThreadId thread_id);
N
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadYield (void);
N
N/// Change priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadSetPriority (osThreadId thread_id, osPriority priority);
N
N/// Get current priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return current priority value of the thread function.
NosPriority osThreadGetPriority (osThreadId thread_id);
N
N
N//  ==== Generic Wait Functions ====
N
N/// Wait for Timeout (Time Delay).
N/// \param[in]     millisec      time delay value
N/// \return status code that indicates the execution status of the function.
NosStatus osDelay (uint32_t millisec);
N
N#if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available
X#if (1L  &&  (0 != 0))     
S
S/// Wait for Signal, Message, Mail, or Timeout.
S/// \param[in] millisec          timeout value or 0 in case of no time-out
S/// \return event that contains signal, message, or mail information or error code.
Sos_InRegs osEvent osWait (uint32_t millisec);
S
N#endif  // Generic Wait available
N
N
N//  ==== Timer Management Functions ====
N/// Define a Timer object.
N/// \param         name          name of the timer object.
N/// \param         function      name of the timer call back function.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osTimerDef(name, function)  \
Sextern const osTimerDef_t os_timer_def_##name
X#define osTimerDef(name, function)  extern const osTimerDef_t os_timer_def_##name
N#else                            // define the object
N#define osTimerDef(name, function)  \
Nuint32_t os_timer_cb_##name[6]; \
Nconst osTimerDef_t os_timer_def_##name = \
N{ (function), (os_timer_cb_##name) }
X#define osTimerDef(name, function)  uint32_t os_timer_cb_##name[6]; const osTimerDef_t os_timer_def_##name = { (function), (os_timer_cb_##name) }
N#endif
N
N/// Access a Timer definition.
N/// \param         name          name of the timer object.
N#define osTimer(name) \
N&os_timer_def_##name
X#define osTimer(name) &os_timer_def_##name
N
N/// Create a timer.
N/// \param[in]     timer_def     timer object referenced with \ref osTimer.
N/// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer call back function.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument);
N
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \param[in]     millisec      time delay value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStart (osTimerId timer_id, uint32_t millisec);
N
N/// Stop the timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStop (osTimerId timer_id);
N
N/// Delete a timer that was created by \ref osTimerCreate.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerDelete (osTimerId timer_id);
N
N
N//  ==== Signal Management ====
N
N/// Set the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that should be set.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
Nint32_t osSignalSet (osThreadId thread_id, int32_t signals);
N
N/// Clear the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that shall be cleared.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters or call from ISR.
Nint32_t osSignalClear (osThreadId thread_id, int32_t signals);
N
N/// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
N/// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return event flag information or error code.
Nos_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec);
X__value_in_regs osEvent osSignalWait (int32_t signals, uint32_t millisec);
N
N
N//  ==== Mutex Management ====
N
N/// Define a Mutex.
N/// \param         name          name of the mutex object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMutexDef(name)  \
Sextern const osMutexDef_t os_mutex_def_##name
X#define osMutexDef(name)  extern const osMutexDef_t os_mutex_def_##name
N#else                            // define the object
N#define osMutexDef(name)  \
Nuint32_t os_mutex_cb_##name[4] = { 0 }; \
Nconst osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
X#define osMutexDef(name)  uint32_t os_mutex_cb_##name[4] = { 0 }; const osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
N#endif
N
N/// Access a Mutex definition.
N/// \param         name          name of the mutex object.
N#define osMutex(name)  \
N&os_mutex_def_##name
X#define osMutex(name)  &os_mutex_def_##name
N
N/// Create and Initialize a Mutex object.
N/// \param[in]     mutex_def     mutex definition referenced with \ref osMutex.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId osMutexCreate (const osMutexDef_t *mutex_def);
N
N/// Wait until a Mutex becomes available.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexWait (osMutexId mutex_id, uint32_t millisec);
N
N/// Release a Mutex that was obtained by \ref osMutexWait.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexRelease (osMutexId mutex_id);
N
N/// Delete a Mutex that was created by \ref osMutexCreate.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexDelete (osMutexId mutex_id);
N
N
N//  ==== Semaphore Management Functions ====
N
N#if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))     // Semaphore available
X#if (1L  &&  (65535 != 0))     
N
N/// Define a Semaphore object.
N/// \param         name          name of the semaphore object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osSemaphoreDef(name)  \
Sextern const osSemaphoreDef_t os_semaphore_def_##name
X#define osSemaphoreDef(name)  extern const osSemaphoreDef_t os_semaphore_def_##name
N#else                            // define the object
N#define osSemaphoreDef(name)  \
Nuint32_t os_semaphore_cb_##name[2] = { 0 }; \
Nconst osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
X#define osSemaphoreDef(name)  uint32_t os_semaphore_cb_##name[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
N#endif
N
N/// Access a Semaphore definition.
N/// \param         name          name of the semaphore object.
N#define osSemaphore(name)  \
N&os_semaphore_def_##name
X#define osSemaphore(name)  &os_semaphore_def_##name
N
N/// Create and Initialize a Semaphore object used for managing resources.
N/// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore.
N/// \param[in]     count         number of available resources.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count);
N
N/// Wait until a Semaphore token becomes available.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return number of available tokens, or -1 in case of incorrect parameters.
Nint32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec);
N
N/// Release a Semaphore token.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreRelease (osSemaphoreId semaphore_id);
N
N/// Delete a Semaphore that was created by \ref osSemaphoreCreate.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreDelete (osSemaphoreId semaphore_id);
N
N#endif     // Semaphore available
N
N
N//  ==== Memory Pool Management Functions ====
N
N#if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0))  // Memory Pool Management available
X#if (1L  &&  (1 != 0))  
N
N/// \brief Define a Memory Pool.
N/// \param         name          name of the memory pool.
N/// \param         no            maximum number of blocks (objects) in the memory pool.
N/// \param         type          data type of a single block (object).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osPoolDef(name, no, type)   \
Sextern const osPoolDef_t os_pool_def_##name
X#define osPoolDef(name, no, type)   extern const osPoolDef_t os_pool_def_##name
N#else                            // define the object
N#define osPoolDef(name, no, type)   \
Nuint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; \
Nconst osPoolDef_t os_pool_def_##name = \
N{ (no), sizeof(type), (os_pool_m_##name) }
X#define osPoolDef(name, no, type)   uint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; const osPoolDef_t os_pool_def_##name = { (no), sizeof(type), (os_pool_m_##name) }
N#endif
N
N/// \brief Access a Memory Pool definition.
N/// \param         name          name of the memory pool
N#define osPool(name) \
N&os_pool_def_##name
X#define osPool(name) &os_pool_def_##name
N
N/// Create and Initialize a memory pool.
N/// \param[in]     pool_def      memory pool definition referenced with \ref osPool.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosPoolId osPoolCreate (const osPoolDef_t *pool_def);
N
N/// Allocate a memory block from a memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolAlloc (osPoolId pool_id);
N
N/// Allocate a memory block from a memory pool and set memory block to zero.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolCAlloc (osPoolId pool_id);
N
N/// Return an allocated memory block back to a specific memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \param[in]     block         address of the allocated memory block that is returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus osPoolFree (osPoolId pool_id, void *block);
N
N#endif   // Memory Pool Management available
N
N
N//  ==== Message Queue Management Functions ====
N
N#if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0))     // Message Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Message Queue Definition.
N/// \param         name          name of the queue.
N/// \param         queue_sz      maximum number of messages in the queue.
N/// \param         type          data type of a single message element (for debugger).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMessageQDef(name, queue_sz, type)   \
Sextern const osMessageQDef_t os_messageQ_def_##name
X#define osMessageQDef(name, queue_sz, type)   extern const osMessageQDef_t os_messageQ_def_##name
N#else                            // define the object
N#define osMessageQDef(name, queue_sz, type)   \
Nuint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; \
Nconst osMessageQDef_t os_messageQ_def_##name = \
N{ (queue_sz), (os_messageQ_q_##name) }
X#define osMessageQDef(name, queue_sz, type)   uint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; const osMessageQDef_t os_messageQ_def_##name = { (queue_sz), (os_messageQ_q_##name) }
N#endif
N
N/// \brief Access a Message Queue Definition.
N/// \param         name          name of the queue
N#define osMessageQ(name) \
N&os_messageQ_def_##name
X#define osMessageQ(name) &os_messageQ_def_##name
N
N/// Create and Initialize a Message Queue.
N/// \param[in]     queue_def     queue definition referenced with \ref osMessageQ.
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);
N
N/// Put a Message to a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     info          message information.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);
N
N/// Get a Message or Wait for a Message from a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return event information that includes status code.
Nos_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
N
N#endif     // Message Queues available
N
N
N//  ==== Mail Queue Management Functions ====
N
N#if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))     // Mail Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Mail Queue Definition.
N/// \param         name          name of the queue
N/// \param         queue_sz      maximum number of messages in queue
N/// \param         type          data type of a single message element
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMailQDef(name, queue_sz, type) \
Sextern const osMailQDef_t os_mailQ_def_##name
X#define osMailQDef(name, queue_sz, type) extern const osMailQDef_t os_mailQ_def_##name
N#else                            // define the object
N#define osMailQDef(name, queue_sz, type) \
Nuint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; \
Nuint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; \
Nvoid *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; \
Nconst osMailQDef_t os_mailQ_def_##name =  \
N{ (queue_sz), sizeof(type), (os_mailQ_p_##name) }
X#define osMailQDef(name, queue_sz, type) uint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; uint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; void *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; const osMailQDef_t os_mailQ_def_##name =  { (queue_sz), sizeof(type), (os_mailQ_p_##name) }
N#endif
N
N/// \brief Access a Mail Queue Definition.
N/// \param         name          name of the queue
N#define osMailQ(name)  \
N&os_mailQ_def_##name
X#define osMailQ(name)  &os_mailQ_def_##name
N
N/// Create and Initialize mail queue.
N/// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return mail queue ID for reference by other functions or NULL in case of error.
NosMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id);
N
N/// Allocate a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Allocate a memory block from a mail and set memory block to zero.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailCAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Put a mail to a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailPut (osMailQId queue_id, void *mail);
N
N/// Get a mail from a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return event that contains mail information or error code.
Nos_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
N
N/// Free a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailFree (osMailQId queue_id, void *mail);
N
N#endif  // Mail Queues available
N
N
N//  ==== RTX Extensions ====
N
N/// Suspend the RTX task scheduler.
N/// \return number of ticks, for how long the system can sleep or power-down.
Nuint32_t os_suspend (void);
N
N/// Resume the RTX task scheduler
N/// \param[in]     sleep_time    specifies how long the system was in sleep or power-down mode.
Nvoid os_resume (uint32_t sleep_time);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif  // _CMSIS_OS_H
L 44 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N
N
N/* Device System Type attribute */
N#define FS_CUR                   0x01   /* Initial Current Drive attribute    */
N#define FS_EMB                   0x02   /* Embedded File System (F:)          */
N#define FS_FAT                   0x04   /* FAT File System      (M:,N:,R:,U:) */
N#define FS_IOC                   0x08   /* IO Control allowed   (M:,N:)       */
N
N/* Driver Init/Uninit Parameter Codes */
N#define DM_IO                       0   /* Init/Uninit IO peripherals         */
N#define DM_MEDIA                    1   /* Init/Uninit storage Media          */
N
N/* NAND Configuration macros */
N#define NAND_ROW_CYCLES(b,p)  ((b*p > 65536) ? 3 : 2)
N#define NAND_COL_CYCLES(s)    ((s   >   528) ? 2 : 1)
N#define NAND_BTT_SIZE(b)      ((b*3)/100)
N#define NAND_SEC_PAGE(p)      (p/512)
N#define NAND_SEC_BLOCK(b,p)   ((p/512)*b)
N#define _DS_(b)               (b-(b*3)/100-1)
N#define _EP_(p)               ((p/512)*128)
N#define NAND_TSN_SIZE(b,p)    ((_DS_(b)+_EP_(p)-1)/_EP_(p))
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/* Device driver mapping type */
Ntypedef struct {
N  void   *dcb;                          /* Device Control block               */
N  char    id[3];                        /* Drive Name Identification          */
N  uint8_t attr;                         /* File System attributes             */
N} const FS_DEV;
N
N/* RAM interface control block */
Ntypedef struct {
N  uint8_t *Base;                        /* RAM buffer base address            */
N  uint32_t Size;                        /* RAM buffer size                    */
N} RAM_DEV;
N
N/* Memory Card Device Control block (MCI) */
Ntypedef struct {
N  ARM_DRIVER_MCI       *Driver;         /* Registered MCI driver              */
N  ARM_MCI_SignalEvent_t Callback;       /* Driver Callback                    */
N  ARM_MCI_CAPABILITIES  Capabilities;   /* Driver Capabilities                */
N  uint8_t              *ExtCSD;         /* Pointer to 512 byte buffer         */
N  uint32_t              Property;       /* Card Properties                    */
N  uint32_t              SerialNumber;   /* Memory card serial number          */
N  uint32_t              SectorCount;    /* Device density in 512B sectors     */
N  uint16_t volatile     Event;          /* Driver event flags                 */
N  uint8_t  volatile     MediaStatus;    /* Media status                       */
N  uint8_t               Status;         /* Device status                      */
N  uint16_t              RCA;            /* Relative Card Address              */
N  uint8_t               Instance;       /* Memory Card Instance number        */
N} MC_MCI;
N
N/* Memory Card Device Control block (SPI) */
Ntypedef struct {
N  ARM_DRIVER_SPI       *Driver;         /* Registered SPI driver              */
N  ARM_SPI_SignalEvent_t Callback;       /* Driver Callback                    */
N  uint8_t              *ExtCSD;         /* Pointer to 512 byte buffer         */
N  uint32_t              Property;       /* Card Properties                    */
N  uint32_t              SerialNumber;   /* Memory card serial number          */
N  uint32_t              SectorCount;    /* Device density in 512B sectors     */
N  uint8_t volatile      Event;          /* Driver event flags                 */
N  uint8_t volatile      MediaStatus;    /* Media status                       */
N  uint8_t               Status;         /* Device status                      */
N  uint16_t              RCA;            /* Relative Card Address              */
N  uint8_t               Instance;       /* Memory Card Instance number        */
N} MC_SPI;
N
N/* NAND Page Layout configuration */
Ntypedef struct _NAND_PAGE_LAYOUT {
N  struct {
N    uint8_t  ofs_lsn;                   /* LSN position, where logical sector number (LSN) is placed. Usually, this is the first byte of Spare and has the value 0. LSN is a 32-bit value. */
N    uint8_t  ofs_dcm;                   /* Page Data corrupted marker. Usually, this byte is the 5-th byte of Spare and has the value 4. */
N    uint8_t  ofs_bbm;                   /* Bad Block marker position. Is usually placed as the 6-th byte of Spare and has the value 5. */
N    uint8_t  ofs_ecc;                   /* Position of the first byte of Error Correction Code (ECC). Is usually the 7-th byte of Spare and has the value 6. This value is used by flash translation layer only if ECC is encoded and decoded in software. */
N  } spare;                              /* Structure spare */
N  uint16_t spare_ofs;                   /* Spare area offset from beginning of the page. */
N  uint16_t spare_inc;                   /* Column increment till next spare. If page contains multiple sectors, then the first byte of the first spare area is determined by reading spare_ofs value. Location of the first byte of the second spare is (spare_inc + spare_ofs). */
N  uint16_t sector_inc;                  /* Column increment till next sector. If page contains multiple sectors, then the first sector always starts at the beginning of the page (byte zero). Second sector starts at sect_inc, third sector at (sect_inc + sect_inc) and so on. */
N} NAND_PAGE_LAYOUT;
N
N/* NAND Flash Device information */
Ntypedef struct _NAND_DEVICE {
N  NAND_PAGE_LAYOUT *page_layout;        /* Page Layout configuration          */
N  uint8_t           bus_width;          /* Device bus width (0=8bit, 1=16bit  */
N  uint8_t           device_number;      /* Device number (chip select)        */
N  uint16_t          page_size;          /* Page Size in bytes                 */
N  uint32_t          block_count;        /* Number of Blocks in Device         */
N  uint16_t          page_count;         /* Number of Pages per Block          */
N  uint16_t          block_sectors;      /* Number of Sectors per Block        */
N  uint8_t           page_sectors;       /* Number of Sectors per Page         */
N  uint8_t           row_cycles;         /* Number of Row address cycles       */
N  uint8_t           col_cycles;         /* Number of Column address cycles    */
N  uint8_t           sw_ecc;             /* value > 0: error correction code (ECC) encoding/decoding enabled in software: \n value = 0: Software ECC disabled \n value = 1: Hamming ECC algorithm enabled in software. */
N} NAND_DEVICE;
N
N/* NAND Driver Info */
Ntypedef struct _NAND_DRIVER_INFO {
N  ARM_NAND_SignalEvent_t hw_cb;         /* Hardware event handler (callback)  */
X  uint32_t hw_cb;          
N  ARM_DRIVER_NAND       *drv;           /* NAND driver                        */
X  uint32_t       *drv;            
N  ARM_NAND_CAPABILITIES  capabilities;  /* NAND driver capabilities           */
X  uint32_t  capabilities;   
N  uint8_t                init;          /* Initialization counter             */
N} NAND_HW_DRIVER;
N
N/* Signal NAND Media Driver event */
Ntypedef void (*NAND_Media_SignalEvent_t) (uint32_t dev_num, uint32_t event);
N
N/* NAND Media Driver Instance */
Ntypedef struct _NFTL_DRIVER_HANDLE {
N  NAND_Media_SignalEvent_t media_cb;    /* NAND Media event handler (callback)*/
N  NAND_HW_DRIVER          *hw;          /* Hardware driver handle             */
N  NAND_DEVICE const       *dev;         /* NAND Device description            */
N  uint16_t                 ecc;         /* ECC algorithm index and ECC flags  */
N  uint8_t volatile         event;       /* Event flags                        */
N  uint8_t                  status;      /* Device status byte                 */
N  uint32_t                 seq;         /* Sequence number                    */
N} NAND_MEDIA_HANDLE;
N
N/* NAND Media Interface Driver */
Ntypedef struct _NAND_MEDIA_DRIVER {
N  int32_t (*Initialize)     (NAND_MEDIA_HANDLE *h);
N  int32_t (*Uninitialize)   (NAND_MEDIA_HANDLE *h);
N  int32_t (*ResetDevice)    (NAND_MEDIA_HANDLE *h);
N  int32_t (*ReadID)         (NAND_MEDIA_HANDLE *h, uint8_t addr, uint8_t *buf, uint32_t len);
N  int32_t (*ReadParamPage)  (NAND_MEDIA_HANDLE *h, uint32_t col, uint8_t *buf, uint32_t len);
N  int32_t (*ReadPage)       (NAND_MEDIA_HANDLE *h, uint32_t row, uint32_t col, uint8_t *buf, uint32_t len);
N  int32_t (*WritePage)      (NAND_MEDIA_HANDLE *h, uint32_t row, uint32_t col, const uint8_t *buf, uint32_t len);
N  int32_t (*CopyPage)       (NAND_MEDIA_HANDLE *h, uint32_t row_src, uint32_t row_dst, uint32_t row_cnt);
N  int32_t (*EraseBlock)     (NAND_MEDIA_HANDLE *h, uint32_t row);
N  int32_t (*ReadStatus)     (NAND_MEDIA_HANDLE *h, uint8_t *stat);
N} const NAND_MEDIA_DRIVER;
N
N/* NAND FTL Block Index Cache */
Ntypedef struct {
N  uint16_t pbn;                         /* Physical block number              */
N  uint16_t lbn;                         /* Logical block number               */
N  uint8_t  typ;                         /* Type of block in cache             */
N  uint8_t  nextPg;                      /* Next page to be indexed            */
N  uint8_t  *pgIdx;                      /* Index buffer                       */
N} BLOCK_CACHE;
N
N/* NAND FTL Page Cache */
Ntypedef struct {
N  uint32_t row;                         /* Row address of the page in cache   */
N  uint8_t *buf;                         /* Cached page buffer                 */
N} PAGE_CACHE;
N
N/* NAND FTL Buffer Pointers Structure */
Ntypedef struct {
N  uint32_t CacheBS;                     /* Block slot for block caching       */
N  uint32_t CachePS;                     /* Page slot for page caching         */
N  uint16_t CachedBlocks;                /* Number of indexed blocks           */
N  uint16_t CachedPages;                 /* Number of cached pages             */
N  BLOCK_CACHE *Block;                   /* Block indexing cache info struct   */
N  PAGE_CACHE  *Page;                    /* Page data cache info structure     */
N} NAND_FTL_CACHE;
N
N/* NAND FTL Configuration structure */
Ntypedef struct {
N  /* Block Translation Table Space */
N  uint16_t BttStartBn;                  /* First Physical Block               */
N  uint16_t BttEndBn;                    /* Last Physical Block                */
N  /* Data Space */
N  uint16_t DataStartBn;                 /* First Physical Block               */
N  uint16_t DataEndBn;                   /* Last Physical Block                */
N  /* Buffer Sizes */  
N  uint16_t NumCacheBlocks;              /* Number of indexed data blocks      */
N  uint16_t NumCachePages;               /* Number of cached data pages        */
N  uint16_t TsnTableSize;                /* Translation table cache size       */
N  /* Page buffer & Caches */
N  uint8_t     *PgBuf;                   /* Page data buffer                   */
N  BLOCK_CACHE *BlockCache;              /* Block indexing cache info struct   */
N  uint8_t     *BlockCacheBuf;           /* Block indexing cache buffer        */
N  PAGE_CACHE  *PageCache;               /* Page data cache info structure     */
N  uint8_t     *PageCacheBuf;            /* Page data cache buffer             */
N  uint32_t    *TsnTable;                /* Translation table cache buffer     */
N} const NAND_FTL_CFG;
N
N/* NAND Device Control block */
Ntypedef struct {
N  NAND_MEDIA_HANDLE *Media;             /* NAND Media Driver Instance         */
N  NAND_FTL_CFG      *Cfg;               /* NAND FTL configuration structure   */
N  NAND_PAGE_LAYOUT   PgLay;             /* Page layout definition             */
N
N  uint8_t   PageSectors;                /* Number of sectors/page 1,4,8, ...  */
N  uint8_t   SPP;                        /* Number of sectors/page             */
N                                        /*  (2^n, n = SPP)                    */
N  uint8_t   PPB;                        /* Number of pages/block              */
N                                        /*  (2^n, n = PPB)                    */
N  uint8_t   SPB;                        /* Number of sectors/block            */
N                                        /*  (2^n, n = SPB)                    */
N  uint8_t   EPS;                        /* Entries/table sector               */
N                                        /*  (2^n, n = EPS)                    */
N  uint8_t   LastECC;                    /* ECC status after last page read    */
N  uint16_t  LastDBN;                    /* Last allocated phy. block          */
N                                        /*  in data area                      */
N  uint16_t  LastTBN;                    /* Last allocated phy. block          */
N                                        /*  in table area                     */
N  uint32_t  CurrLBN;                    /* Current logical block number       */
N  uint32_t  GcLBN;                      /* Current logical block number used  */
N                                        /*  by forced GC                      */
N  uint16_t  PbnQ[3];                    /* Empty block queue                  */
N  uint16_t  BadBlockCnt;                /* Bad Block Counter                  */
N  uint16_t  NumDataBlocks;              /* Number of data blocks reported to  */
N                                        /*  file system                       */
N  uint8_t   Status;                     /* FTL Status Flags                   */
N  volatile
N  uint8_t   Timeout;                    /* Timeout status                     */
N  uint8_t  *PgBuf;                      /* Page data buffer                   */
N  uint32_t *TsnTable;                   /* Translation table cache buffer     */
N  uint16_t  TsnTableSize;               /* Translation table cache size       */
N  NAND_FTL_CACHE Ca;                    /* FTL cache info structure           */
N} NAND_FTL_DEV;
N
N/* FAT Name Cache Configuration */
Ntypedef struct fat_nca_cfg {
N  uint8_t   MaxPathDepth;               /* Maximum path depth                 */
N  uint8_t   ControlBlockCnt;            /* Number of control blocks           */
N  uint32_t  NameMemPoolSize;            /* Name cache memory pool size        */
N  uint32_t *NameMemPool;                /* Name cache memory pool             */
N} const FAT_NCACHE_CFG;
N
N/* FAT Sector Caching structure */
Ntypedef struct fcache {
N  uint32_t sect;                        /* Cached FAT sector number           */
N  uint8_t  *buf;                        /* FAT sector cache buffer            */
N  uint8_t  dirty;                       /* FAT table content modified         */
N  uint8_t  cfat;                        /* Current FAT                        */
N} FCACHE;
N
N/* Data Sector Caching structure */
Ntypedef struct dcache {
N  uint32_t sect;                        /* Working Data sector number         */
N  uint32_t csect;                       /* Data Cache starting sector number  */
N  uint8_t  *buf;                        /* Working Data sector buffer         */
N  uint8_t  *cbuf;                       /* Data Cache sector buffer           */
N  uint8_t  nwr;                         /* Number of buffered write sectors   */
N  uint8_t  nrd;                         /* Number of cached read sectors      */
N} DCACHE;
N
N/* Name Caching structure */
Ntypedef struct _NCACHE {
N  uint8_t   max_path_depth;             /* Maximum path depth                 */
N  uint32_t  size;                       /* Name cache memory pool size        */
N  uint32_t *buf;                        /* Name cache memory pool             */
N} NCACHE;
N
N/* FAT Volume Information struct */
Ntypedef struct fatinfo {
N  uint32_t BootSector;                  /* Boot Sector Offset                 */
N  uint8_t  FatType;                     /* File System Fat type.              */
N  uint8_t  NumOfFat;                    /* Number of Fat tables               */
N  uint8_t  SecPerClus;                  /* Number of Sectors per Cluster      */
N  uint16_t FatSize;                     /* Number of Sectors per FAT table    */
N  uint16_t RsvdSecCnt;                  /* Number of Reserved Sectors         */
N  uint32_t DskSize;                     /* Disk Size Sector Count             */
N  uint32_t DataSecCnt;                  /* Number of Data Sectors             */
N  uint16_t RootEntCnt;                  /* Maximum Root Directory entries     */
N  uint16_t BytesPerSec;                 /* Sector Size in bytes               */
N  uint32_t DataClusCnt;                 /* Data Cluster Count                 */
N  uint32_t RootDirAddr;                 /* Root Dir First Sector              */
N  uint16_t RootSecCnt;                  /* Number of Sectors for Root dir     */
N  uint32_t ClusSize;                    /* Cluster Size in bytes              */
N  uint16_t EntsPerClus;                 /* Number of entries per cluster      */
N                                        /* Added fields for FAT32             */
N  uint16_t FAT32_ExtFlags;              /* FAT extended flags                 */
N  uint32_t FAT32_RootClus;              /* Root directory first cluster       */
N  uint16_t FAT32_FSInfo;                /* FSInfo structure sector number     */
N  uint16_t FAT32_BkBootSec;             /* Boot Record copy sector number     */
N} FATINFO;
N
N/* FAT File System driver */
Ntypedef struct {
N  uint32_t (*Init)        (uint32_t mode);
N  uint32_t (*UnInit)      (uint32_t mode);
N  uint32_t (*ReadSect)    (uint32_t sect, uint8_t *buf, uint32_t cnt);
N  uint32_t (*WriteSect)   (uint32_t sect, uint8_t *buf, uint32_t cnt);
N  uint32_t (*ReadInfo)    (fsMediaInfo *cfg);
N  fsStatus (*DeviceCtrl)  (fsDevCtrlCode code, void *p);
N} const FAT_DRV;
N
N/* File System Journal Control block */
Ntypedef struct fsjour {
N  FAT_DRV *drv;                         /* Memory device driver               */
N  uint8_t *buf;                         /* Journal buffer                     */
N  uint32_t FirstSect;                   /* First sector of journal            */
N  uint32_t JournSect;                   /* Number of sectors available        */
N  uint32_t TrId;                        /* Transaction identifier             */
N  uint32_t TrSect;                      /* Transaction sector                 */
N  uint8_t  State;                       /* Journal state                      */
N  uint8_t  Status;                      /* Journal status                     */
N} FSJOUR;
N
N/* FAT Volume Description */
Ntypedef struct _fsFAT_Volume {
N  FAT_DRV  *Drv;                        /* Registered FAT Device Driver       */
N  uint32_t  Status;                     /* Volume Status                      */
N  uint32_t *CaBuf;                      /* Cache Buffer (FAT + Data)          */
N  uint32_t  CaSize;                     /* Cache Buffer size                  */
N  uint16_t  RsvdS;                      /* Reserved sectors used by journal   */
N  FSJOUR   *fsj;                        /* File System Journal                */
N  FATINFO   cfg;                        /* FAT Volume configuration           */
N  FCACHE    fat;                        /* FAT table cache control            */
N  DCACHE    ca;                         /* Data cache control                 */
N  uint32_t  free_clus_cnt;              /* FAT32: Number of free clusters     */
N  uint32_t  free_clus;                  /* FAT32: First free cluster          */
N  uint32_t  cdir_clus;                  /* Current directory cluster          */
N  NCACHE   *ncache;                     /* Name cache memory                  */
N} fsFAT_Volume;
N
N/* FAT File Handle Description */
Ntypedef struct _fsFAT_Handle {
N  fsFAT_Volume *vol;                    /* FAT volume pointer                 */
N  uint16_t  flags;                      /* File status flags                  */
N  uint32_t  fsize;                      /* File size                          */
N  uint32_t  fcsz;                       /* Current file size                  */
N  uint32_t  fpos;                       /* File position pointer              */
N
N  uint32_t  short_ent_clus;             /* SFN: Short entry cluster number    */
N  uint16_t  short_ent_offs;             /* SFN: Short entry sector offset     */
N
N  uint32_t  first_clus;                 /* First data cluster                 */
N  uint32_t  current_clus;               /* Current data cluster               */
N  uint8_t   current_sect;               /* Current data sector                */
N} fsFAT_Handle;
N
N/* EFS Volume Description */
Ntypedef struct _fsEFS_Volume {
N  ARM_DRIVER_FLASH       *Drv;          /* Registered Device Driver           */
X  uint32_t       *Drv;           
N  ARM_FLASH_SECTOR       *DevSect;      /* Flash Sectors Array                */
X  uint32_t       *DevSect;       
N  ARM_FLASH_CAPABILITIES  Capab;        /* Flash driver capabilities          */
X  uint32_t  Capab;         
N  ARM_Flash_SignalEvent_t Callback;     /* Flash driver callback              */
X  uint32_t Callback;      
N  uint32_t volatile       Event;        /* Flash driver events                */
N  uint32_t                Status;       /* Volume Status                      */
N  uint32_t                InitVal;      /* Value for empty flash              */
N  uint32_t                NumSect;      /* Number of Flash Sectors            */
N  uint32_t                Size;         /* Device Size                        */
N  uint16_t                TopID;        /* Top used FileID                    */
N} fsEFS_Volume;
N
N/* EFS File Handle Description */
Ntypedef struct _fsEFS_Handle {
N  fsEFS_Volume *vi;                     /* Volume Information                 */
N  uint16_t  flags;                      /* File status flags                  */
N  uint32_t  fsize;                      /* File Size                          */
N  uint32_t  fpos;                       /* File Position Indicator            */
N
N  uint16_t  fileID;                     /* File Identification Number         */
N  uint16_t  fblock;                     /* Current Flash Block index          */
N  uint16_t  fidx;                       /* Current File Block index           */
N  uint16_t  nfidx;                      /* Next File Block index              */
N  uint32_t  fbot;                       /* Flash Block free space bottom      */
N  uint32_t  ftop;                       /* Flash Block free space top         */
N} fsEFS_Handle;
N
N/* File System Configuration function */
Nextern void     fs_config          (const char *drive);
N
N/* RAM drive interface functions */
Nextern uint32_t ram_Init           (uint32_t mode, RAM_DEV *ram);
Nextern uint32_t ram_UnInit         (uint32_t mode, RAM_DEV *ram);
Nextern uint32_t ram_ReadSector     (uint32_t sect, uint8_t *buf, uint32_t cnt, RAM_DEV *ram);
Nextern uint32_t ram_WriteSector    (uint32_t sect, uint8_t *buf, uint32_t cnt, RAM_DEV *ram);
Nextern uint32_t ram_ReadInfo       (fsMediaInfo *info, RAM_DEV *ram);
Nextern fsStatus ram_DevCtrl        (fsDevCtrlCode code, void *p, RAM_DEV *ram);
N
N/* Memory Card SPI mode interface functions */
Nextern uint32_t mc_spi_Init        (uint32_t mode, MC_SPI *mc);
Nextern uint32_t mc_spi_UnInit      (uint32_t mode, MC_SPI *mc);
Nextern uint32_t mc_spi_ReadSector  (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_SPI *mc);
Nextern uint32_t mc_spi_WriteSector (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_SPI *mc);
Nextern uint32_t mc_spi_ReadInfo    (fsMediaInfo *info, MC_SPI *mc);
Nextern fsStatus mc_spi_DevCtrl     (fsDevCtrlCode code, void *p, MC_SPI *mc);
Nextern void     mc_spi_DrvEvent    (uint32_t event, MC_SPI *mc);
N
N/* Memory Card Native mode interface functions */
Nextern uint32_t mc_mci_Init        (uint32_t mode, MC_MCI *mc);
Nextern uint32_t mc_mci_UnInit      (uint32_t mode, MC_MCI *mc);
Nextern uint32_t mc_mci_ReadSector  (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_MCI *mc);
Nextern uint32_t mc_mci_WriteSector (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_MCI *mc);
Nextern uint32_t mc_mci_ReadInfo    (fsMediaInfo *info, MC_MCI *mc);
Nextern fsStatus mc_mci_DevCtrl     (fsDevCtrlCode code, void *p, MC_MCI *mc);
Nextern void     mc_mci_DrvEvent    (uint32_t event, MC_MCI *mc);
N
N/* NAND Flash Translation Layer interface functions */
Nextern uint32_t ftl_Init           (uint32_t mode, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_UnInit         (uint32_t mode, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_ReadSect       (uint32_t lsn, uint8_t *buf, uint32_t cnt, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_WriteSect      (uint32_t lsn, uint8_t *buf, uint32_t cnt, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_ReadInfo       (fsMediaInfo *info, NAND_FTL_DEV *ftl);
Nextern fsStatus ftl_DevCtrl        (fsDevCtrlCode code, void *p, NAND_FTL_DEV *ftl);
Nextern void     ftl_DrvEvent       (NAND_FTL_DEV *ftl);
N
N/* USB Mass Storage interface functions */
Nextern bool     FS_USBH_MSC_Initialize  (uint8_t instance, uint32_t mode);
Xextern _Bool     FS_USBH_MSC_Initialize  (uint8_t instance, uint32_t mode);
Nextern bool     FS_USBH_MSC_Uninitialize(uint8_t instance, uint32_t mode);
Xextern _Bool     FS_USBH_MSC_Uninitialize(uint8_t instance, uint32_t mode);
Nextern bool     FS_USBH_MSC_ReadSectors (uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Xextern _Bool     FS_USBH_MSC_ReadSectors (uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Nextern bool     FS_USBH_MSC_WriteSectors(uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Xextern _Bool     FS_USBH_MSC_WriteSectors(uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Nextern bool     FS_USBH_MSC_ReadInfo    (uint8_t instance, fsMediaInfo *info);
Xextern _Bool     FS_USBH_MSC_ReadInfo    (uint8_t instance, fsMediaInfo *info);
Nextern fsStatus FS_USBH_MSC_DeviceCtrl  (uint8_t instance, fsDevCtrlCode code, void *p);
N
N/* File System Journal interface functions */
Nextern uint32_t fsj_init      (FSJOUR *fsj, FAT_DRV *drv);
Nextern uint32_t fsj_set_space (FSJOUR *fsj, uint32_t start_sect, uint32_t cnt);
Nextern uint32_t fsj_write     (FSJOUR *fsj, uint32_t sect, uint32_t rsec, uint8_t *buf);
N
N/* Embedded File System interface functions */
Nextern fsStatus efs_init      (fsEFS_Volume *vol);
Nextern fsStatus efs_uninit    (fsEFS_Volume *vol);
Nextern fsStatus efs_mount     (fsEFS_Volume *vol);
Nextern fsStatus efs_unmount   (fsEFS_Volume *vol);
Nextern fsStatus efs_open      (int32_t handle, const char *fn, int openmode);
Nextern fsStatus efs_close     (int32_t handle);
Nextern int32_t  efs_read      (int32_t handle, uint8_t *buf, uint32_t len);
Nextern int32_t  efs_write     (int32_t handle, const uint8_t *buf, uint32_t len);
Nextern fsStatus efs_flush     (int32_t handle);
Nextern int32_t  efs_flen      (int32_t handle);
Nextern fsStatus efs_seek      (int32_t handle, uint32_t pos);
N
N/* EFS Auxiliary */
Nextern fsStatus efs_create    (int32_t handle, const char *name);
Nextern fsStatus efs_find      (int32_t handle, const char *name);
N
N/* EFS Maintenance Routines */
Nextern fsStatus efs_delete    (int32_t handle);
Nextern fsStatus efs_ffind     (int32_t handle, fsFileInfo *info);
Nextern fsStatus efs_rename    (int32_t handle, const char *filename);
N
N/* EFS Utility Routines */
Nextern uint32_t efs_free      (fsEFS_Volume *vi);
Nextern fsStatus efs_format    (fsEFS_Volume *vi);
Nextern int32_t  efs_analyse   (fsEFS_Volume *vi);
Nextern fsStatus efs_check     (fsEFS_Volume *vi);
Nextern fsStatus efs_defrag    (fsEFS_Volume *vi);
N
N/* EFS Event Callback handler for driver events */
Nextern void     efs_DrvEvent  (uint32_t event, fsEFS_Volume *vol);
N
N/* FAT File System interface functions */
Nextern fsStatus fat_init      (fsFAT_Volume *vol);
Nextern fsStatus fat_uninit    (fsFAT_Volume *vol);
Nextern fsStatus fat_mount     (fsFAT_Volume *vol);
Nextern fsStatus fat_unmount   (fsFAT_Volume *vol);
Nextern fsStatus fat_open      (int32_t handle, const char *name, int openmode);
Nextern fsStatus fat_close     (int32_t handle);
Nextern int32_t  fat_read      (int32_t handle, uint8_t *buf, uint32_t len);
Nextern int32_t  fat_write     (int32_t handle, const uint8_t *buf, uint32_t len);
Nextern int32_t  fat_flush     (int32_t handle);
Nextern int32_t  fat_flen      (int32_t handle);
Nextern fsStatus fat_seek      (int32_t handle, uint32_t pos);
N
N/* FAT File Maintenance Routines */
Nextern fsStatus fat_delete_l  (const char *fn, fsFAT_Volume *vol);
Nextern fsStatus fat_delete    (const char *fn, const char *options, fsFAT_Volume *vol);
Nextern fsStatus fat_ffind     (const char *fn, fsFileInfo *info, fsFAT_Volume *vol);
Nextern fsStatus fat_rename    (const char *path, const char *newname, fsFAT_Volume *vol);
N
N/* FAT Directory Support Routines */
Nextern fsStatus fat_mkdir     (const char *path, fsFAT_Volume *vol);
Nextern fsStatus fat_rmdir     (const char *path, const char *options, fsFAT_Volume *vol);
Nextern fsStatus fat_chdir     (const char *path, fsFAT_Volume *vol);
Nextern fsStatus fat_pwd       (      char *path, uint32_t len, fsFAT_Volume *vol);
N
N/* FAT Utility Routines */
Nextern uint64_t fat_free      (fsFAT_Volume *vol);
Nextern fsStatus fat_format    (fsFAT_Volume *vol, const char *param);
N
N/* FAT Journal System Routines */
Nextern uint32_t fat_jour_init (fsFAT_Volume *vol);
Nextern uint32_t fat_jour_prep (fsFAT_Volume *vol);
N
N/* FileSystem Retarget Routines */
Nextern int      __sys_open    (const char *fname, int openmode);
Nextern int      __sys_close   (int handle);
Nextern int      __sys_read    (int handle, uint8_t *buf, uint32_t len);
Nextern int      __sys_write   (int handle, const uint8_t *buf, uint32_t len);
Nextern int      __sys_ensure  (int handle);
Nextern int      __sys_seek    (int handle, uint32_t pos);
Nextern long     __sys_flen    (int handle);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_FS_LIB_H */
L 14 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\fs_config.h" 2
N
N#pragma thumb
N#pragma O3
N
N/* ---------------------------------------------------------------------------*/
N/* Reject MicroLib since it does not provide retargeting */
N#ifdef __MICROLIB
S  #error "File System does not work with MicroLIB"
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Standard file I/O retargeting is mandatory */
N#ifndef RTE_Compiler_IO_File_FS
S  #error "Standard file I/O library retarget requires ::Compiler:I/O:File software component from the 'Keil.ARM_Compiler' Pack!"
N#endif
N
N/* ---------------------------------------------------------------------------*/
N/* Provide definitions for undefined drives */
N/* Ensure compatibility for config files with "Default Drive" setting */
N#ifndef NOR0_ENABLE
N  #define NOR0_ENABLE   0
N#else
S  #ifdef NOR0_DEFAULT_DRIVE
S    #if  NOR0_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   0
S    #endif
S  #endif
N#endif
N#ifndef NOR1_ENABLE
N  #define NOR1_ENABLE   0
N#else
S  #ifdef NOR1_DEFAULT_DRIVE
S    #if  NOR1_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   1
S    #endif
S  #endif
N#endif
N#ifndef MC0_ENABLE
S  #define MC0_ENABLE    0
N#else
N  #ifdef MC0_DEFAULT_DRIVE
S    #if  MC0_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   2
S    #endif
N  #endif
N#endif
N#ifndef MC1_ENABLE
N  #define MC1_ENABLE    0
N#else
S  #ifdef MC1_DEFAULT_DRIVE
S    #if  MC1_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   3
S    #endif
S  #endif
N#endif
N#ifndef NAND0_ENABLE
N  #define NAND0_ENABLE  0
N#else
S  #ifdef NAND0_DEFAULT_DRIVE
S    #if  NAND0_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   4
S    #endif
S  #endif
N#endif
N#ifndef NAND1_ENABLE
N  #define NAND1_ENABLE  0
N#else
S  #ifdef NAND1_DEFAULT_DRIVE
S    #if  NAND1_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   5
S    #endif
S  #endif
N#endif
N#ifndef RAM0_ENABLE
N  #define RAM0_ENABLE   0
N#else
S  #ifdef RAM0_DEFAULT_DRIVE
S    #if  RAM0_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   6
S    #endif
S  #endif
N#endif
N#ifndef USB0_ENABLE
N  #define USB0_ENABLE   0
N#else
S  #ifdef USB0_DEFAULT_DRIVE
S    #if  USB0_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   7
S    #endif
S  #endif
N#endif
N#ifndef USB1_ENABLE
N  #define USB1_ENABLE   0
N#else
S  #ifdef USB1_DEFAULT_DRIVE
S    #if  USB1_DEFAULT_DRIVE
S      #define FS_INITIAL_CDRIVE   8
S    #endif
S  #endif
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Ensure compatibility for config files with "NUM_FILES" config option */
N#ifndef FAT_MAX_OPEN_FILES
S  #define FAT_MAX_OPEN_FILES NUM_FILES
N#endif
N#ifndef EFS_MAX_OPEN_FILES
S  #define EFS_MAX_OPEN_FILES NUM_FILES
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Ensure compatibility for config files with "FAT Name Cache Size" setting */
N#ifdef FAT_NAME_CACHE_SIZE
S  #if (FAT_NAME_CACHE_SIZE > 0)
S    #define MC0_NAME_CACHE_SIZE     FAT_NAME_CACHE_SIZE
S    #define MC1_NAME_CACHE_SIZE     FAT_NAME_CACHE_SIZE
S    #define NAND0_NAME_CACHE_SIZE   FAT_NAME_CACHE_SIZE
S    #define NAND1_NAME_CACHE_SIZE   FAT_NAME_CACHE_SIZE
S    #define USB0_NAME_CACHE_SIZE    FAT_NAME_CACHE_SIZE
S    #define USB1_NAME_CACHE_SIZE    FAT_NAME_CACHE_SIZE
S  #endif
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Ensure compatibility for config files with "Default Drive" setting */
N#ifndef FS_INITIAL_CDRIVE
S  #define __DEF  ((NOR0_DEFAULT_DRIVE  & NOR0_ENABLE)  +  \
S                  (NOR1_DEFAULT_DRIVE  & NOR1_ENABLE)  +  \
S                  (RAM0_DEFAULT_DRIVE  & RAM0_ENABLE)  +  \
S                  (MC0_DEFAULT_DRIVE   & MC0_ENABLE)   +  \
S                  (MC1_DEFAULT_DRIVE   & MC1_ENABLE)   +  \
S                  (USB0_DEFAULT_DRIVE  & USB0_ENABLE)  +  \
S                  (USB1_DEFAULT_DRIVE  & USB1_ENABLE)  +  \
S                  (NAND0_DEFAULT_DRIVE & NAND0_ENABLE) +  \
S                  (NAND1_DEFAULT_DRIVE & NAND1_ENABLE))
X  #define __DEF  ((NOR0_DEFAULT_DRIVE  & NOR0_ENABLE)  +                    (NOR1_DEFAULT_DRIVE  & NOR1_ENABLE)  +                    (RAM0_DEFAULT_DRIVE  & RAM0_ENABLE)  +                    (MC0_DEFAULT_DRIVE   & MC0_ENABLE)   +                    (MC1_DEFAULT_DRIVE   & MC1_ENABLE)   +                    (USB0_DEFAULT_DRIVE  & USB0_ENABLE)  +                    (USB1_DEFAULT_DRIVE  & USB1_ENABLE)  +                    (NAND0_DEFAULT_DRIVE & NAND0_ENABLE) +                    (NAND1_DEFAULT_DRIVE & NAND1_ENABLE))
S  #if (__DEF == 0)
S    #error "Default ::File System:Drive not specified"
S  #elif (__DEF > 1)
S    #error "Multiple default ::File System:Drive: enabled"
S  #endif
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Verify correct current drive configuration */
N#if ((FS_INITIAL_CDRIVE < 0) || (FS_INITIAL_CDRIVE > 8))
X#if ((2 < 0) || (2 > 8))
S  #error "Initial Current Drive configuration invalid"
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Initial Current Drive configuration */
N#define NOR0_CURRENT_DRIVE      (FS_INITIAL_CDRIVE == 0)
N#define NOR1_CURRENT_DRIVE      (FS_INITIAL_CDRIVE == 1)
N#define MC0_CURRENT_DRIVE       (FS_INITIAL_CDRIVE == 2)
N#define MC1_CURRENT_DRIVE       (FS_INITIAL_CDRIVE == 3)
N#define NAND0_CURRENT_DRIVE     (FS_INITIAL_CDRIVE == 4)
N#define NAND1_CURRENT_DRIVE     (FS_INITIAL_CDRIVE == 5)
N#define RAM0_CURRENT_DRIVE      (FS_INITIAL_CDRIVE == 6)
N#define USB0_CURRENT_DRIVE      (FS_INITIAL_CDRIVE == 7)
N#define USB1_CURRENT_DRIVE      (FS_INITIAL_CDRIVE == 8)
N/* ---------------------------------------------------------------------------*/
N/* Check if initial drive is enabled */
N#if ((FS_INITIAL_CDRIVE == 0) && (NOR0_ENABLE  == 0)) || \
N    ((FS_INITIAL_CDRIVE == 1) && (NOR1_ENABLE  == 0)) || \
N    ((FS_INITIAL_CDRIVE == 2) && (MC0_ENABLE   == 0)) || \
N    ((FS_INITIAL_CDRIVE == 3) && (MC1_ENABLE   == 0)) || \
N    ((FS_INITIAL_CDRIVE == 4) && (NAND0_ENABLE == 0)) || \
N    ((FS_INITIAL_CDRIVE == 5) && (NAND1_ENABLE == 0)) || \
N    ((FS_INITIAL_CDRIVE == 6) && (RAM0_ENABLE  == 0)) || \
N    ((FS_INITIAL_CDRIVE == 7) && (USB0_ENABLE  == 0)) || \
N    ((FS_INITIAL_CDRIVE == 8) && (USB1_ENABLE  == 0))
X#if ((2 == 0) && (0  == 0)) ||     ((2 == 1) && (0  == 0)) ||     ((2 == 2) && (1   == 0)) ||     ((2 == 3) && (0   == 0)) ||     ((2 == 4) && (0 == 0)) ||     ((2 == 5) && (0 == 0)) ||     ((2 == 6) && (0  == 0)) ||     ((2 == 7) && (0  == 0)) ||     ((2 == 8) && (0  == 0))
S  #error "Initial Current ::File System:Drive is not enabled"
N#endif
N/* ---------------------------------------------------------------------------*/
N/* Check number of enabled drives */
N#define FS_NDRV (NOR0_ENABLE  + NOR1_ENABLE +   \
N                 RAM0_ENABLE  +                 \
N                 MC0_ENABLE   + MC1_ENABLE  +   \
N                 USB0_ENABLE  + USB1_ENABLE +   \
N                 NAND0_ENABLE + NAND1_ENABLE)
X#define FS_NDRV (NOR0_ENABLE  + NOR1_ENABLE +                    RAM0_ENABLE  +                                  MC0_ENABLE   + MC1_ENABLE  +                    USB0_ENABLE  + USB1_ENABLE +                    NAND0_ENABLE + NAND1_ENABLE)
N#if (FS_NDRV == 0)
X#if ((0 + 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0) == 0)
S  #error "No drive enabled, File System requires at least one component ::File System:Drive"
N#endif
N
N/* Count number of enabled FAT drives */
N#define FS_FAT_NDRV (MC0_ENABLE   + MC1_ENABLE   + \
N                     NAND0_ENABLE + NAND1_ENABLE + \
N                     RAM0_ENABLE  +                \
N                     USB0_ENABLE  + USB1_ENABLE)
X#define FS_FAT_NDRV (MC0_ENABLE   + MC1_ENABLE   +                      NAND0_ENABLE + NAND1_ENABLE +                      RAM0_ENABLE  +                                     USB0_ENABLE  + USB1_ENABLE)
N                     
N
N/* Count number of enabled NAND devices */
N#define FS_NAND_NDRV  (NAND0_ENABLE + NAND1_ENABLE)
N
N
N/* Check MCI port consistency */
N#if (MC0_ENABLE && MC1_ENABLE)
X#if (1 && 0)
S  #if   ((MC0_SPI == 0) && (MC1_SPI == 0))
S    #if (MC0_MCI_DRIVER == MC1_MCI_DRIVER)
S    #error "::File System:Drive:Memory Card: MCI ports for different drives must be different"
S    #endif
S  #elif ((MC0_SPI == 1) && (MC1_SPI == 1))
S    #if (MC0_SPI_DRIVER == MC1_SPI_DRIVER)
S    #error "::File System:Drive:Memory Card: SPI ports for different drives must be different"
S    #endif
S  #endif
N#endif
N
N/* Check FS usage */
N#define EFS_USE (NOR0_ENABLE + NOR1_ENABLE)
N#define FAT_USE (MC0_ENABLE + MC1_ENABLE + NAND0_ENABLE + NAND1_ENABLE + RAM0_ENABLE + USB0_ENABLE + USB1_ENABLE)
N
N/* Check journal usage */
N#define FSJ_USE (MC0_ENABLE   * MC0_FAT_JOURNAL   +  \
N                 MC1_ENABLE   * MC1_FAT_JOURNAL   +  \
N                 NAND0_ENABLE * NAND0_FAT_JOURNAL +  \
N                 NAND1_ENABLE * NAND1_FAT_JOURNAL +  \
N                 USB0_ENABLE  * USB0_FAT_JOURNAL  +  \
N                 USB1_ENABLE  * USB1_FAT_JOURNAL)
X#define FSJ_USE (MC0_ENABLE   * MC0_FAT_JOURNAL   +                   MC1_ENABLE   * MC1_FAT_JOURNAL   +                   NAND0_ENABLE * NAND0_FAT_JOURNAL +                   NAND1_ENABLE * NAND1_FAT_JOURNAL +                   USB0_ENABLE  * USB0_FAT_JOURNAL  +                   USB1_ENABLE  * USB1_FAT_JOURNAL)
N
N/* Check name cache usage */
N#define NCACHE_USE (MC0_NAME_CACHE_SIZE   + MC1_NAME_CACHE_SIZE   + \
N                    NAND0_NAME_CACHE_SIZE + NAND1_NAME_CACHE_SIZE + \
N                    USB0_NAME_CACHE_SIZE  + USB1_NAME_CACHE_SIZE)
X#define NCACHE_USE (MC0_NAME_CACHE_SIZE   + MC1_NAME_CACHE_SIZE   +                     NAND0_NAME_CACHE_SIZE + NAND1_NAME_CACHE_SIZE +                     USB0_NAME_CACHE_SIZE  + USB1_NAME_CACHE_SIZE)
N
N/* Reserved sector count */
N#define FAT_SECT_RSVD 64
N
N/* Make sure to resolve a weak stdlib symbol. */
N#ifdef __RTX
Nextern volatile int _stream_list_lock;
N  #define STREAM_LIST_LOCK   _stream_list_lock;
N#else
S #define STREAM_LIST_LOCK
N#endif
N
N/* File Control Blocks for the FAT File System */
N#if (FAT_USE == 0 || FAT_MAX_OPEN_FILES == 0)
X#if ((1 + 0 + 0 + 0 + 0 + 0 + 0) == 0 || 4 == 0)
SfsFAT_Handle *fs_fat_fh;
Suint8_t const fs_fat_fh_cnt = 0;
N#else
NfsFAT_Handle  fs_fat_fh[FAT_MAX_OPEN_FILES];
XfsFAT_Handle  fs_fat_fh[4];
Nuint8_t const fs_fat_fh_cnt = FAT_MAX_OPEN_FILES;
Xuint8_t const fs_fat_fh_cnt = 4;
N#endif
N
N/* File Control Blocks for the Embedded File System */
N#if (EFS_USE == 0 || EFS_MAX_OPEN_FILES == 0)
X#if ((0 + 0) == 0 || 4 == 0)
NfsEFS_Handle *fs_efs_fh;
Nuint8_t const fs_efs_fh_cnt = 0;
N#else
SfsEFS_Handle  fs_efs_fh[EFS_MAX_OPEN_FILES];
Suint8_t const fs_efs_fh_cnt = EFS_MAX_OPEN_FILES;
N#endif
N
N/* Number of enabled drives */
Nuint8_t const _NDRV = FS_NDRV;
Xuint8_t const _NDRV = (0 + 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0);
N
N/* Embedded File System Operation Timeouts (in seconds) */
Nuint16_t const fs_efs_timeout_erase_chip   = 300;
Nuint8_t  const fs_efs_timeout_erase_sector = 5;
Nuint8_t  const fs_efs_timeout_write        = 1;
Nuint8_t  const fs_efs_timeout_read         = 1;
N
N /* FAT Name Cache definitions */
N#define FAT_NCACHE_LINK_SZ  (48)
N#define FAT_NCACHE_STAT_SZ  (20)
N#define FAT_NCACHE_USED_SZ  (8)
N
N/* Expansion macro used to create CMSIS Driver references */
N#define EXPAND_SYMBOL(name, port) name##port
N#define CREATE_SYMBOL(name, port) EXPAND_SYMBOL(name, port)
N
N/*----------------------------------------------------------------------------
N *  Drive F0: NOR Flash device NOR0 configuration
N *---------------------------------------------------------------------------*/
N#if (NOR0_ENABLE)
X#if (0)
S  static fsEFS_Volume   nor0_vol;
S
S  /* EFS Driver Event Callback */
S  static void NOR0_DriverEvent (uint32_t event) {
S    efs_DrvEvent (event, &nor0_vol);
S  }
S
S  extern ARM_DRIVER_FLASH CREATE_SYMBOL (Driver_Flash, NOR0_DRIVER);
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive F1: NOR Flash device NOR1 configuration
N *---------------------------------------------------------------------------*/
N#if (NOR1_ENABLE)
X#if (0)
S  static fsEFS_Volume   nor1_vol;
S
S  /* EFS Driver Event Callback */
S  static void NOR1_DriverEvent (uint32_t event) {
S    efs_DrvEvent (event, &nor1_vol);
S  }
S
S  extern ARM_DRIVER_FLASH CREATE_SYMBOL (Driver_Flash, NOR1_DRIVER);
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive M0: Memory Card device MC0 configuration
N *---------------------------------------------------------------------------*/
N#if (MC0_ENABLE)
X#if (1)
N  static fsFAT_Volume mc0_vol;
N  #if (MC0_SPI == 0)
X  #if (1 == 0)
S  static MC_MCI       mc0_dev;
N  #else
N  static MC_SPI       mc0_dev;
N  #endif
N
N  #if (MC0_FAT_JOURNAL)
X  #if (1)
N  static FSJOUR mc0_fsj;
N  #endif
N
N  #if (MC0_CACHE_RELOC == 1)
X  #if (0 == 1)
S    #define __AT_MC0  __attribute__ ((at(MC0_CACHE_ADDR)))
N  #else
N    #define __AT_MC0
N  #endif
N
N  /* MC0 Cache Buffer for Data and FAT Caching */
N  static uint32_t mc0_cache[(MC0_CACHE_SIZE+1) * 256 + MC0_FAT_JOURNAL * 128] __AT_MC0;
X  static uint32_t mc0_cache[(4+1) * 256 + 1 * 128] ;
N
N  #if (MC0_NAME_CACHE_SIZE > 0)
X  #if (0 > 0)
S    #define MC0_NAME_CACHE_MAX_DEPTH 8
S    #define MC0_NAME_CACHE_BUF_SIZE ((MC0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                     (MC0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                 FAT_NCACHE_STAT_SZ)
X    #define MC0_NAME_CACHE_BUF_SIZE ((MC0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                      (MC0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                  FAT_NCACHE_STAT_SZ)
S
S    static uint32_t mc0_ncache_buf[MC0_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE mc0_ncache = {
S      MC0_NAME_CACHE_MAX_DEPTH,
S      MC0_NAME_CACHE_BUF_SIZE,
S      mc0_ncache_buf
S    };
N  #endif
N
N  #if (MC0_SPI == 0)
X  #if (1 == 0)
S    /* SD Native bus mode */
S    #define MC0_INIT(m)      mc_mci_Init        (m,       &mc0_dev)
S    #define MC0_UNINIT(m)    mc_mci_UnInit      (m,       &mc0_dev)
S    #define MC0_RDSEC(s,b,c) mc_mci_ReadSector  (s, b, c, &mc0_dev)
S    #define MC0_WRSEC(s,b,c) mc_mci_WriteSector (s, b, c, &mc0_dev)
S    #define MC0_RDINFO(i)    mc_mci_ReadInfo    (i,       &mc0_dev)
S    #define MC0_DEVCTRL(c,p) mc_mci_DevCtrl     (c, p,    &mc0_dev)
S
S    extern ARM_DRIVER_MCI CREATE_SYMBOL (Driver_MCI, MC0_MCI_DRIVER);
N  #else
N    /* SPI bus mode */
N    #define MC0_INIT(m)      mc_spi_Init        (m,       &mc0_dev)
N    #define MC0_UNINIT(m)    mc_spi_UnInit      (m,       &mc0_dev)
N    #define MC0_RDSEC(s,b,c) mc_spi_ReadSector  (s, b, c, &mc0_dev)
N    #define MC0_WRSEC(s,b,c) mc_spi_WriteSector (s, b, c, &mc0_dev)
N    #define MC0_RDINFO(i)    mc_spi_ReadInfo    (i,       &mc0_dev)
N    #define MC0_DEVCTRL(c,p) mc_spi_DevCtrl     (c, p,    &mc0_dev)
N
N    extern ARM_DRIVER_SPI CREATE_SYMBOL (Driver_SPI, MC0_SPI_DRIVER);
X    extern ARM_DRIVER_SPI Driver_SPI0;
N  #endif
N
N  /* MC0 wrapper functions */
N  static uint32_t mc0_Init (uint32_t mode) {
N    return (MC0_INIT (mode));
X    return (mc_spi_Init (mode, &mc0_dev));
N  }
N  static uint32_t mc0_UnInit (uint32_t mode) {
N    return (MC0_UNINIT (mode));
X    return (mc_spi_UnInit (mode, &mc0_dev));
N  }
N  static uint32_t mc0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
N    return (MC0_RDSEC (sect, buf, cnt));
X    return (mc_spi_ReadSector (sect, buf, cnt, &mc0_dev));
N  }
N  static uint32_t mc0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
N    return (MC0_WRSEC (sect, buf, cnt));
X    return (mc_spi_WriteSector (sect, buf, cnt, &mc0_dev));
N  }
N  static uint32_t mc0_RdInfo (fsMediaInfo *info) {
N    return (MC0_RDINFO (info));
X    return (mc_spi_ReadInfo (info, &mc0_dev));
N  }
N  static fsStatus mc0_DevCtrl (fsDevCtrlCode code, void *p) {
N    return (MC0_DEVCTRL (code, p));
X    return (mc_spi_DevCtrl (code, p, &mc0_dev));
N  }
N
N  /* MC0 FAT device driver */
N  FAT_DRV mc0_drv = {
N    mc0_Init,
N    mc0_UnInit,
N    mc0_RdSect,
N    mc0_WrSect,
N    mc0_RdInfo,
N    mc0_DevCtrl
N  };
N
N  /* ------- MC0 MCI/SPI Callback ------- */
N  #if (MC0_SPI == 0)
X  #if (1 == 0)
S  static void MC0_MCI_SignalEvent (uint32_t event) {
S    mc_mci_DrvEvent (event, &mc0_dev);
S  }
N  #endif
N  #if (MC0_SPI == 1)
X  #if (1 == 1)
N  static void MC0_SPI_SignalEvent (uint32_t event) {
N    mc_spi_DrvEvent (event, &mc0_dev);
N  }
N  #endif
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive M1: Memory Card device MC1 configuration
N *---------------------------------------------------------------------------*/
N#if (MC1_ENABLE)
X#if (0)
S  static fsFAT_Volume mc1_vol;
S  #if (MC1_SPI == 0)
S  static MC_MCI       mc1_dev;
S  #else
S  static MC_SPI       mc1_dev;
S  #endif
S
S  #if (MC1_FAT_JOURNAL)
S  static FSJOUR mc1_fsj;
S  #endif
S
S  #if (MC1_CACHE_RELOC == 1)
S    #define __AT_MC1  __attribute__ ((at(MC1_CACHE_ADDR)))
S  #else
S    #define __AT_MC1
S  #endif
S
S  /* MC1 Cache Buffer for Data and FAT Caching */
S  static uint32_t mc1_cache[(MC1_CACHE_SIZE+1) * 256 + MC1_FAT_JOURNAL * 128] __AT_MC1;
S
S  #if (MC1_NAME_CACHE_SIZE > 0)
S    #define MC1_NAME_CACHE_MAX_DEPTH 8
S    #define MC1_NAME_CACHE_BUF_SIZE ((MC1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                     (MC1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                 FAT_NCACHE_STAT_SZ)
X    #define MC1_NAME_CACHE_BUF_SIZE ((MC1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                      (MC1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                  FAT_NCACHE_STAT_SZ)
S
S    static uint32_t mc1_ncache_buf[MC1_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE mc1_ncache = {
S      MC1_NAME_CACHE_MAX_DEPTH,
S      MC1_NAME_CACHE_BUF_SIZE,
S      mc1_ncache_buf
S    };
S  #endif
S
S  #if (MC1_SPI == 0)
S    /* SD Native bus mode */
S    #define MC1_INIT(m)      mc_mci_Init        (m,       &mc1_dev)
S    #define MC1_UNINIT(m)    mc_mci_UnInit      (m,       &mc1_dev)
S    #define MC1_RDSEC(s,b,c) mc_mci_ReadSector  (s, b, c, &mc1_dev)
S    #define MC1_WRSEC(s,b,c) mc_mci_WriteSector (s, b, c, &mc1_dev)
S    #define MC1_RDINFO(i)    mc_mci_ReadInfo    (i,       &mc1_dev)
S    #define MC1_DEVCTRL(c,p) mc_mci_DevCtrl     (c, p,    &mc1_dev)
S
S    extern ARM_DRIVER_MCI CREATE_SYMBOL (Driver_MCI, MC1_MCI_DRIVER);
S  #else
S    /* SPI bus mode */
S    #define MC1_INIT(m)      mc_spi_Init        (m,       &mc1_dev)
S    #define MC1_UNINIT(m)    mc_spi_UnInit      (m,       &mc1_dev)
S    #define MC1_RDSEC(s,b,c) mc_spi_ReadSector  (s, b, c, &mc1_dev)
S    #define MC1_WRSEC(s,b,c) mc_spi_WriteSector (s, b, c, &mc1_dev)
S    #define MC1_RDINFO(i)    mc_spi_ReadInfo    (i,       &mc1_dev)
S    #define MC1_DEVCTRL(c,p) mc_spi_DevCtrl     (c, p,    &mc1_dev)
S
S    extern ARM_DRIVER_SPI CREATE_SYMBOL (Driver_SPI, MC1_SPI_DRIVER);
S  #endif
S
S  /* MC1 wrapper functions */
S  static uint32_t mc1_Init (uint32_t mode) {
S    return (MC1_INIT (mode));
S  }
S  static uint32_t mc1_UnInit (uint32_t mode) {
S    return (MC1_UNINIT (mode));
S  }
S  static uint32_t mc1_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (MC1_RDSEC (sect, buf, cnt));
S  }
S  static uint32_t mc1_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (MC1_WRSEC (sect, buf, cnt));
S  }
S  static uint32_t mc1_RdInfo (fsMediaInfo *info) {
S    return (MC1_RDINFO (info));
S  }
S  static fsStatus mc1_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (MC1_DEVCTRL (code, p));
S  }
S
S  /* MC1 FAT device driver */
S  FAT_DRV mc1_drv = {
S    mc1_Init,
S    mc1_UnInit,
S    mc1_RdSect,
S    mc1_WrSect,
S    mc1_RdInfo,
S    mc1_DevCtrl
S  };
S
S  /* ------- MC1 MCI/SPI Callback ------- */
S  #if (MC1_SPI == 0)
S  static void MC1_MCI_SignalEvent (uint32_t event) {
S    mc_mci_DrvEvent (event, &mc1_dev);
S  }
S  #endif
S  #if (MC1_SPI == 1)
S  static void MC1_SPI_SignalEvent (uint32_t event) {
S    mc_spi_DrvEvent (event, &mc1_dev);
S  }
S  #endif
N#endif
N
N/*----------------------------------------------------------------------------
N *  General NAND Flash device configuration
N *---------------------------------------------------------------------------*/
N#if (NAND0_ENABLE)
X#if (0)
S  static NAND_MEDIA_HANDLE nand0_media_handle;
S  static NAND_FTL_DEV      nand0_handle;
N#endif
N
N#if (NAND1_ENABLE)
X#if (0)
S  static NAND_MEDIA_HANDLE nand1_media_handle;
S  static NAND_FTL_DEV      nand1_handle;
N#endif
N
N#if (NAND0_ENABLE || NAND1_ENABLE)
X#if (0 || 0)
S  extern void nand_DrvEvent   (uint32_t event, NAND_MEDIA_HANDLE *h);
S  extern void nand_MediaEvent (NAND_FTL_DEV *ftl);
N#endif
N
N#ifdef RTE_FileSystem_Drive_NAND_0
S  #if (NAND0_ENABLE)
S  extern ARM_DRIVER_NAND   CREATE_SYMBOL (Driver_NAND, NAND0_DRIVER);
S  
S  static NAND_HW_DRIVER    nand0_hw_driver;
S
S
S  #if ((NAND1_ENABLE) && (NAND1_DRIVER == NAND0_DRIVER))
S    #if (NAND1_DEV_NUM == NAND0_DEV_NUM)
S      #error "::File System:Drive:NAND: NAND ports for different drives must be different"
S    #endif
S
S    #define NAND0_DEVICE1
S
S    /* NAND0 Device1 Configuration Part */
S    #define NAND1_MEDIA_EVENT_HANDLER NAND0_Media_SignalEventHandler
S    #define NAND1_HW_EVENT_HANDLER    NAND0_HW_SignalEventHandler
S    #define NAND1_HW_DRIVER           nand0_hw_driver
S    #define NAND1_DRIVER_CONFIG  0
S  #endif
S
S  static void NAND0_HW_SignalEventHandler (uint32_t dev_num, uint32_t event) {
S    /* Event from nand_driver to nand_media */
S    switch (dev_num) {
S      case NAND0_DEV_NUM: nand_DrvEvent (event, &nand0_media_handle); break;
S
S      #if defined(NAND0_DEVICE1)
S      case NAND1_DEV_NUM: nand_DrvEvent (event, &nand1_media_handle); break;
S      #endif
S
S      default: return;
S    }
S  }
S
S  static void NAND0_Media_SignalEventHandler (uint32_t dev_num, uint32_t event) {
S    /* Event from nand_media to nftl */
S    switch (dev_num) {
S      case NAND0_DEV_NUM: nand_MediaEvent (&nand0_handle); break;
S
S      #if defined(NAND0_DEVICE1)
S      case NAND1_DEV_NUM: nand_MediaEvent (&nand1_handle); break;
S      #endif
S
S      default: return;
S    }
S  }
S  #endif
N#endif
N
N#ifdef RTE_FileSystem_Drive_NAND_1
S  #if (((NAND0_ENABLE == 0) && NAND1_ENABLE) || ((NAND0_ENABLE && NAND1_ENABLE) && (NAND1_DRIVER != NAND0_DRIVER)))
S  extern ARM_DRIVER_NAND  CREATE_SYMBOL (Driver_NAND, NAND1_DRIVER);
S
S  static NAND_HW_DRIVER    nand1_hw_driver;
S
S  /* NAND1 Device0 Configuration Part */
S  #define NAND1_MEDIA_EVENT_HANDLER NAND1_Media_SignalEventHandler
S  #define NAND1_HW_EVENT_HANDLER    NAND1_HW_SignalEventHandler
S  #define NAND1_HW_DRIVER           nand1_hw_driver
S  #define NAND1_DRIVER_CONFIG       1
S
S  static void NAND1_HW_SignalEventHandler (uint32_t dev_num, uint32_t event) {
S    switch (dev_num) {
S      case NAND1_DEV_NUM: nand_DrvEvent (event, &nand1_media_handle); break;
S
S      default: return;
S    }
S  }
S
S  static void NAND1_Media_SignalEventHandler (uint32_t dev_num, uint32_t event) {
S    /* Event from nand_media to nftl */
S    switch (dev_num) {
S      case NAND1_DEV_NUM: nand_MediaEvent (&nand1_handle); break;
S
S      default: return;
S    }
S  }
S  #endif
N#endif
N
N
N/*----------------------------------------------------------------------------
N *  Drive N0: NAND Flash device NAND0 configuration
N *---------------------------------------------------------------------------*/
N#if (NAND0_ENABLE)
X#if (0)
S  extern ARM_DRIVER_NAND  CREATE_SYMBOL (Driver_NAND, NAND0_DRIVER);
S
S  #if (NAND0_CACHE_RELOC == 1)
S    #define __AT_NAND0  __attribute__ ((at(NAND0_CACHE_ADDR)))
S  #else
S    #define __AT_NAND0
S  #endif
S
S  /* NAND Cache Buffer for FAT, Page and Block Caching */
S  #define NAND0_CSZ   ((NAND0_CACHE_SIZE  + 1) * 1024             + \
S                       (NAND0_PAGE_CACHE  + 2) * NAND0_PAGE_SIZE  + \
S                       (NAND0_BLOCK_CACHE + 2) * NAND0_PAGE_COUNT)
X  #define NAND0_CSZ   ((NAND0_CACHE_SIZE  + 1) * 1024             +                        (NAND0_PAGE_CACHE  + 2) * NAND0_PAGE_SIZE  +                        (NAND0_BLOCK_CACHE + 2) * NAND0_PAGE_COUNT)
S  #define NAND0_FSJBUF (NAND0_FAT_JOURNAL      * 512)
S
S  static uint32_t     nand0_cache[NAND0_CSZ/4 + NAND0_FSJBUF/4] __AT_NAND0;
S  static PAGE_CACHE   nand0_capg [NAND0_PAGE_CACHE  + 1];
S  static BLOCK_CACHE  nand0_cabl [NAND0_BLOCK_CACHE + 2];
S  static uint32_t     nand0_ttsn [NAND_TSN_SIZE(NAND0_BLOCK_COUNT, NAND0_PAGE_SIZE)];
S
S  static fsFAT_Volume      nand0_vol;
S  #if (NAND0_FAT_JOURNAL)
S  static FSJOUR            nand0_fsj;
S  #endif
S
S  #if (NAND0_NAME_CACHE_SIZE > 0)
S    #define NAND0_NAME_CACHE_MAX_DEPTH 8
S    #define NAND0_NAME_CACHE_BUF_SIZE ((NAND0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                       (NAND0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                     FAT_NCACHE_STAT_SZ)
X    #define NAND0_NAME_CACHE_BUF_SIZE ((NAND0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                        (NAND0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                      FAT_NCACHE_STAT_SZ)
S
S    static uint32_t nand0_ncache_buf[NAND0_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE nand0_ncache = {
S      NAND0_NAME_CACHE_MAX_DEPTH,
S      NAND0_NAME_CACHE_BUF_SIZE,
S      nand0_ncache_buf
S    };
S  #endif
S
S  const NAND_DEVICE nand0_device = {
S   &nand0_handle.PgLay,
S    NAND0_BUS_WIDTH,
S    NAND0_DEV_NUM,
S    NAND0_PAGE_SIZE,
S    NAND0_BLOCK_COUNT,
S    NAND0_PAGE_COUNT,
S    NAND_SEC_BLOCK  (NAND0_PAGE_COUNT, NAND0_PAGE_SIZE),
S    NAND_SEC_PAGE   (NAND0_PAGE_SIZE),
S    NAND_ROW_CYCLES (NAND0_BLOCK_COUNT, NAND0_PAGE_COUNT),
S    NAND_COL_CYCLES (NAND0_PAGE_SIZE),
S    NAND0_SW_ECC
S  };
S
S  /* NAND Flash Configuration */
S  static NAND_FTL_CFG nand0_cfg = {
S    /* Block Translation Table Space */
S    1,
S    NAND_BTT_SIZE (NAND0_BLOCK_COUNT),
S
S    /* Data Space */
S    NAND_BTT_SIZE (NAND0_BLOCK_COUNT) + 1,
S    NAND0_BLOCK_COUNT - 1,
S
S    /* Caching */
S    NAND0_BLOCK_CACHE + 2,
S    NAND0_PAGE_CACHE  + 1,
S    NAND_TSN_SIZE(NAND0_BLOCK_COUNT, NAND0_PAGE_SIZE),
S
S    /* Page buffer & Caches */
S    (uint8_t *)&nand0_cache[(NAND0_CACHE_SIZE+1)*256],
S    &nand0_cabl[0],
S    (uint8_t *)&nand0_cache[(NAND0_CACHE_SIZE+1)*256+(NAND0_PAGE_CACHE+2)*NAND0_PAGE_SIZE/4],
S    &nand0_capg[0],
S    (uint8_t *)&nand0_cache[(NAND0_CACHE_SIZE+1)*256+NAND0_PAGE_SIZE/4],
S    &nand0_ttsn[0]
S  };
S
S  /* NAND0 wrapper functions */
S  static uint32_t nand0_Init (uint32_t mode) {
S    return (ftl_Init (mode, &nand0_handle));
S  }
S  static uint32_t nand0_UnInit (uint32_t mode) {
S    return (ftl_UnInit (mode, &nand0_handle));
S  }
S  static uint32_t nand0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    uint32_t retv = ftl_ReadSect (sect, buf, cnt, &nand0_handle);
S    if (retv < 2) return (true);
S    else          return (false);
S  }
S  static uint32_t nand0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    uint32_t retv = ftl_WriteSect (sect, buf, cnt, &nand0_handle);
S    if (retv < 2) return (true);
S    else          return (false);
S  }
S  static uint32_t nand0_RdInfo (fsMediaInfo *info) {
S    return (ftl_ReadInfo (info, &nand0_handle));
S  }
S  static fsStatus nand0_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (ftl_DevCtrl (code, p, &nand0_handle));
S  }
S
S  FAT_DRV nand0_drv = {
S    nand0_Init,
S    nand0_UnInit,
S    nand0_RdSect,
S    nand0_WrSect,
S    nand0_RdInfo,
S    nand0_DevCtrl
S  };
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive N1: NAND Flash device NAND1 configuration
N *---------------------------------------------------------------------------*/
N#if (NAND1_ENABLE)
X#if (0)
S  #if defined(NAND1_DEVICE0)
S  extern ARM_DRIVER_NAND  CREATE_SYMBOL (Driver_NAND, NAND1_DRIVER);
S  #endif
S
S  #if (NAND1_CACHE_RELOC == 1)
S    #define __AT_NAND1  __attribute__ ((at(NAND1_CACHE_ADDR)))
S  #else
S    #define __AT_NAND1
S  #endif
S
S  /* NAND Cache Buffer for FAT, Page and Block Caching */
S  #define NAND1_CSZ   ((NAND1_CACHE_SIZE  + 1) * 1024             + \
S                       (NAND1_PAGE_CACHE  + 2) * NAND1_PAGE_SIZE  + \
S                       (NAND1_BLOCK_CACHE + 2) * NAND1_PAGE_COUNT)
X  #define NAND1_CSZ   ((NAND1_CACHE_SIZE  + 1) * 1024             +                        (NAND1_PAGE_CACHE  + 2) * NAND1_PAGE_SIZE  +                        (NAND1_BLOCK_CACHE + 2) * NAND1_PAGE_COUNT)
S  #define NAND1_FSJBUF (NAND1_FAT_JOURNAL      * 512)
S 
S  static uint32_t     nand1_cache[NAND1_CSZ/4 + NAND1_FSJBUF/4] __AT_NAND1;
S  static PAGE_CACHE   nand1_capg [NAND1_PAGE_CACHE  + 1];
S  static BLOCK_CACHE  nand1_cabl [NAND1_BLOCK_CACHE + 2];
S  static uint32_t     nand1_ttsn [NAND_TSN_SIZE(NAND1_BLOCK_COUNT, NAND1_PAGE_SIZE)];
S
S  static fsFAT_Volume      nand1_vol;
S  #if (NAND1_FAT_JOURNAL)
S  static FSJOUR            nand1_fsj;
S  #endif
S
S  #if (NAND1_NAME_CACHE_SIZE > 0)
S    #define NAND1_NAME_CACHE_MAX_DEPTH 8
S    #define NAND1_NAME_CACHE_BUF_SIZE ((NAND1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                       (NAND1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                     FAT_NCACHE_STAT_SZ)
X    #define NAND1_NAME_CACHE_BUF_SIZE ((NAND1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                        (NAND1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                      FAT_NCACHE_STAT_SZ)
S
S    static uint32_t nand1_ncache_buf[NAND1_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE nand1_ncache = {
S      NAND1_NAME_CACHE_MAX_DEPTH,
S      NAND1_NAME_CACHE_BUF_SIZE,
S      nand1_ncache_buf
S    };
S  #endif
S
S  const NAND_DEVICE nand1_device = {
S   &nand1_handle.PgLay,
S    NAND1_BUS_WIDTH,
S    NAND1_DEV_NUM,
S    NAND1_PAGE_SIZE,
S    NAND1_BLOCK_COUNT,
S    NAND1_PAGE_COUNT,
S    NAND_SEC_BLOCK  (NAND1_PAGE_COUNT, NAND1_PAGE_SIZE),
S    NAND_SEC_PAGE   (NAND1_PAGE_SIZE),
S    NAND_ROW_CYCLES (NAND1_BLOCK_COUNT, NAND1_PAGE_COUNT),
S    NAND_COL_CYCLES (NAND1_PAGE_SIZE),
S    NAND1_SW_ECC
S  };
S
S  /* NAND Flash Configuration */
S  static NAND_FTL_CFG nand1_cfg = {
S    /* Block Translation Table Space */
S    1,
S    NAND_BTT_SIZE (NAND1_BLOCK_COUNT),
S
S    /* Data Space */
S    NAND_BTT_SIZE (NAND1_BLOCK_COUNT) + 1,
S    NAND1_BLOCK_COUNT - 1,
S
S    /* Caching */
S    NAND1_BLOCK_CACHE + 2,
S    NAND1_PAGE_CACHE  + 1,
S    NAND_TSN_SIZE(NAND1_BLOCK_COUNT, NAND1_PAGE_SIZE),
S
S    /* Page buffer & Caches */
S    (uint8_t *)&nand1_cache[(NAND1_CACHE_SIZE+1)*256],
S    &nand1_cabl[0],
S    (uint8_t *)&nand1_cache[(NAND1_CACHE_SIZE+1)*256+(NAND1_PAGE_CACHE+2)*NAND1_PAGE_SIZE/4],
S    &nand1_capg[0],
S    (uint8_t *)&nand1_cache[(NAND1_CACHE_SIZE+1)*256+NAND1_PAGE_SIZE/4],
S    &nand1_ttsn[0],
S  };
S
S  /* NAND1 wrapper functions */
S  static uint32_t nand1_Init (uint32_t mode) {
S    return (ftl_Init(mode, &nand1_handle));
S  }
S  static uint32_t nand1_UnInit (uint32_t mode) {
S    return (ftl_UnInit (mode, &nand1_handle));
S  }
S  static uint32_t nand1_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    uint32_t retv = ftl_ReadSect (sect, buf, cnt, &nand1_handle);
S    if (retv < 2) return (true);
S    else          return (false);
S  }
S  static uint32_t nand1_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    uint32_t retv = ftl_WriteSect (sect, buf, cnt, &nand1_handle);
S    if (retv < 2) return (true);
S    else          return (false);
S  }
S  static uint32_t nand1_RdInfo (fsMediaInfo *info) {
S    return (ftl_ReadInfo (info, &nand1_handle));
S  }
S  static fsStatus nand1_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (ftl_DevCtrl (code, p, &nand1_handle));
S  }
S
S  FAT_DRV nand1_drv = {
S    nand1_Init,
S    nand1_UnInit,
S    nand1_RdSect,
S    nand1_WrSect,
S    nand1_RdInfo,
S    nand1_DevCtrl
S  };
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive R0: RAM device RAM0 configuration
N *---------------------------------------------------------------------------*/
N#if (RAM0_ENABLE)
X#if (0)
S  static fsFAT_Volume ram0_vol;
S
S  #if (RAM0_SIZE < 0x4A00)
S    #error "::File System:Drive:RAM requires minimum of 0x4A00 bytes of memory"
S  #endif
S
S  #if (RAM0_RELOC == 1)
S    #define __AT_RAM0  __attribute__ ((at(RAM0_BASE_ADDR)))
S  #else
S    #define __AT_RAM0
S  #endif
S
S  /* RAM0 Device data buffer */
S  static uint32_t ram0_buf[256 + (RAM0_SIZE/4)] __AT_RAM0;
S
S  /* RAM0 device info */
S  static RAM_DEV  ram0_dev = {
S    (uint8_t *)&ram0_buf[256],
S    RAM0_SIZE
S  };
S
S  /* RAM0 wrapper functions */
S  static uint32_t ram0_Init (uint32_t mode) {
S    return (ram_Init (mode, &ram0_dev));
S  }
S  static uint32_t ram0_UnInit (uint32_t mode) {
S    return (ram_UnInit (mode, &ram0_dev));
S  }
S  static uint32_t ram0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (ram_ReadSector (sect, buf, cnt, &ram0_dev));
S  }
S  static uint32_t ram0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (ram_WriteSector (sect, buf, cnt, &ram0_dev));
S  }
S  static uint32_t ram0_RdInfo (fsMediaInfo *info) {
S    return (ram_ReadInfo (info, &ram0_dev));
S  }
S  static fsStatus ram0_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (ram_DevCtrl (code, p, &ram0_dev));
S  }
S
S  /* FAT RAM Driver Control Block */
S  FAT_DRV ram0_drv = {
S    ram0_Init,
S    ram0_UnInit,
S    ram0_RdSect,
S    ram0_WrSect,
S    ram0_RdInfo,
S    ram0_DevCtrl
S  };
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive U0: USB Flash device USB0 configuration
N *---------------------------------------------------------------------------*/
N#if (USB0_ENABLE)
X#if (0)
S  extern FAT_DRV usb0_drv;
S
S  #if (USB0_FAT_JOURNAL)
S  static FSJOUR usb0_fsj;
S  #endif
S
S  #if (USB0_NAME_CACHE_SIZE > 0)
S    #define USB0_NAME_CACHE_MAX_DEPTH 8
S    #define USB0_NAME_CACHE_BUF_SIZE ((USB0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                      (USB0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                   FAT_NCACHE_STAT_SZ)
X    #define USB0_NAME_CACHE_BUF_SIZE ((USB0_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                       (USB0_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                    FAT_NCACHE_STAT_SZ)
S
S    static uint32_t usb0_ncache_buf[USB0_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE usb0_ncache = {
S      USB0_NAME_CACHE_MAX_DEPTH,
S      USB0_NAME_CACHE_BUF_SIZE,
S      usb0_ncache_buf
S    };
S  #endif
S
S  /* USB Cache Buffer for Data and FAT Caching */
S  static uint32_t usb0_cache[(USB0_CACHE_SIZE+1) * 256 + USB0_FAT_JOURNAL * 128];
S  static fsFAT_Volume usb0_vol;
S
S  /* USB0 wrapper functions */
S  static uint32_t usb0_Init (uint32_t mode) {
S    return (FS_USBH_MSC_Initialize      (0, mode));
S  }
S  static uint32_t usb0_UnInit (uint32_t mode) {
S    return (FS_USBH_MSC_Uninitialize    (0, mode));
S  }
S  static uint32_t usb0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (FS_USBH_MSC_ReadSectors     (0, sect, cnt, buf));
S  }
S  static uint32_t usb0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (FS_USBH_MSC_WriteSectors    (0, sect, cnt, buf));
S  }
S  static uint32_t usb0_RdInfo (fsMediaInfo *info) {
S    return (FS_USBH_MSC_ReadInfo        (0, info));
S  }
S  static fsStatus usb0_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (FS_USBH_MSC_DeviceCtrl      (0, code, p));
S  }
S
S  FAT_DRV usb0_drv = {
S    usb0_Init,
S    usb0_UnInit,
S    usb0_RdSect,
S    usb0_WrSect,
S    usb0_RdInfo,
S    usb0_DevCtrl
S  };
N#endif
N
N/*----------------------------------------------------------------------------
N *  Drive U1: USB Flash device USB1 configuration
N *---------------------------------------------------------------------------*/
N#if (USB1_ENABLE)
X#if (0)
S  extern FAT_DRV usb1_drv;
S
S  #if (USB1_FAT_JOURNAL)
S  static FSJOUR usb1_fsj;
S  #endif
S
S  /* USB Cache Buffer for Data and FAT Caching */
S  static uint32_t usb1_cache[(USB1_CACHE_SIZE+1) * 256 + USB1_FAT_JOURNAL * 128];
S  static fsFAT_Volume usb1_vol;
S
S  #if (USB1_NAME_CACHE_SIZE > 0)
S    #define USB1_NAME_CACHE_MAX_DEPTH 8
S    #define USB1_NAME_CACHE_BUF_SIZE ((USB1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) + \
S                                      (USB1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) + \
S                                                                   FAT_NCACHE_STAT_SZ)
X    #define USB1_NAME_CACHE_BUF_SIZE ((USB1_NAME_CACHE_SIZE      * FAT_NCACHE_LINK_SZ) +                                       (USB1_NAME_CACHE_MAX_DEPTH * FAT_NCACHE_USED_SZ) +                                                                    FAT_NCACHE_STAT_SZ)
S
S    static uint32_t usb1_ncache_buf[USB1_NAME_CACHE_BUF_SIZE/4];
S
S    static NCACHE usb1_ncache = {
S      USB1_NAME_CACHE_MAX_DEPTH,
S      USB1_NAME_CACHE_BUF_SIZE,
S      usb1_ncache_buf
S    };
S  #endif
S
S  /* USB1 wrapper functions */
S  static uint32_t usb1_Init (uint32_t mode) {
S    return (FS_USBH_MSC_Initialize      (1, mode));
S  }
S  static uint32_t usb1_UnInit (uint32_t mode) {
S    return (FS_USBH_MSC_Uninitialize    (1, mode));
S  }
S  static uint32_t usb1_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (FS_USBH_MSC_ReadSectors     (1, sect, cnt, buf));
S  }
S  static uint32_t usb1_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
S    return (FS_USBH_MSC_WriteSectors    (1, sect, cnt, buf));
S  }
S  static uint32_t usb1_RdInfo (fsMediaInfo *info) {
S    return (FS_USBH_MSC_ReadInfo        (1, info));
S  }
S  static fsStatus usb1_DevCtrl (fsDevCtrlCode code, void *p) {
S    return (FS_USBH_MSC_DeviceCtrl      (1, code, p));
S  }
S
S  FAT_DRV usb1_drv = {
S    usb1_Init,
S    usb1_UnInit,
S    usb1_RdSect,
S    usb1_WrSect,
S    usb1_RdInfo,
S    usb1_DevCtrl
S  };
N#endif
N
N
N/*-----------------------------------------------------------------------------
N *  An array of installed Device drivers
N *----------------------------------------------------------------------------*/
NFS_DEV fs_DevPool[FS_NDRV] = {
XFS_DEV fs_DevPool[(0 + 0 + 0 + 1 + 0 + 0 + 0 + 0 + 0)] = {
N#if (NOR0_ENABLE)
X#if (0)
S  { &nor0_vol, "F0", NOR0_CURRENT_DRIVE  | FS_EMB },
N#endif
N#if (NOR1_ENABLE)
X#if (0)
S  { &nor1_vol, "F1", NOR1_CURRENT_DRIVE  | FS_EMB },
N#endif
N#if (MC0_ENABLE)
X#if (1)
N  { &mc0_vol,  "M0", MC0_CURRENT_DRIVE   | FS_FAT | FS_IOC },
X  { &mc0_vol,  "M0", (2 == 2)   | 0x04 | 0x08 },
N#endif
N#if (MC1_ENABLE)
X#if (0)
S  { &mc1_vol,  "M1", MC1_CURRENT_DRIVE   | FS_FAT | FS_IOC },
N#endif
N#if (NAND0_ENABLE)
X#if (0)
S  { &nand0_vol,"N0", NAND0_CURRENT_DRIVE | FS_FAT | FS_IOC },
N#endif
N#if (NAND1_ENABLE)
X#if (0)
S  { &nand1_vol,"N1", NAND1_CURRENT_DRIVE | FS_FAT | FS_IOC },
N#endif
N#if (RAM0_ENABLE)
X#if (0)
S  { &ram0_vol, "R0", RAM0_CURRENT_DRIVE  | FS_FAT },
N#endif
N#if (USB0_ENABLE)
X#if (0)
S  { &usb0_vol, "U0", USB0_CURRENT_DRIVE  | FS_FAT },
N#endif
N#if (USB1_ENABLE)
X#if (0)
S  { &usb1_vol, "U1", USB1_CURRENT_DRIVE  | FS_FAT },
N#endif
N};
N
N__inline static void fs_config_flash (char num) {
N  switch (num) {
N#if (NOR0_ENABLE)
X#if (0)
S    case '0':
S      nor0_vol.Drv      = &CREATE_SYMBOL (Driver_Flash, NOR0_DRIVER);
S      nor0_vol.Callback = &NOR0_DriverEvent;
S      break;
N#endif /* NOR0_ENABLE */
N    
N#if (NOR1_ENABLE)
X#if (0)
S    case '1':
S      nor1_vol.Drv      = &CREATE_SYMBOL (Driver_Flash, NOR1_DRIVER);
S      nor1_vol.Callback = &NOR1_DriverEvent;
S      break;
N#endif /* NOR1_ENABLE */
N  }
N}
N
N__inline static void fs_config_mc (char num) {
N  switch (num) {
N#if (MC0_ENABLE)
X#if (1)
N    case '0':
N      mc0_vol.Drv           = &mc0_drv;
N      mc0_vol.CaBuf         = mc0_cache;
N      mc0_vol.CaSize        = MC0_CACHE_SIZE * 2;
X      mc0_vol.CaSize        = 4 * 2;
N     #if (MC0_NAME_CACHE_SIZE)
X     #if (0)
S      mc0_vol.ncache        = &mc0_ncache;
N     #else
N      mc0_vol.ncache        = NULL;
X      mc0_vol.ncache        = 0;
N     #endif
N
N      mc0_dev.Instance      = 0;
N      mc0_dev.ExtCSD        = (uint8_t *)mc0_cache;
N      /* Register MCI driver for Native mode */
N     #if   (MC0_SPI == 0)
X     #if   (1 == 0)
S      mc0_dev.Driver        = &CREATE_SYMBOL (Driver_MCI, MC0_MCI_DRIVER);
S      mc0_dev.Callback      = MC0_MCI_SignalEvent;
N     #elif (MC0_SPI == 1)
X     #elif (1 == 1)
N      /* Register SPI driver for SPI mode */
N      mc0_dev.Driver        = &CREATE_SYMBOL (Driver_SPI, MC0_SPI_DRIVER);
X      mc0_dev.Driver        = &Driver_SPI0;
N      mc0_dev.Callback      = MC0_SPI_SignalEvent;
N     #else
S      #error "Memory Card Interface Mode Invalid in FS_Config_MC_0.h"
N     #endif
N
N     #if (MC0_FAT_JOURNAL)
X     #if (1)
N      /* Register file system journal */
N      mc0_fsj.buf           = (uint8_t *)&mc0_cache[(MC0_CACHE_SIZE+1) * 256];
X      mc0_fsj.buf           = (uint8_t *)&mc0_cache[(4+1) * 256];
N      mc0_vol.fsj           = &mc0_fsj;
N      mc0_vol.RsvdS         = FAT_SECT_RSVD;
X      mc0_vol.RsvdS         = 64;
N     #else
S      mc0_vol.fsj           = NULL;
S      mc0_vol.RsvdS         = 0;
N     #endif
N      break;
N#endif /* MC0_ENABLE */
N
N#if (MC1_ENABLE)
X#if (0)
S    case '1':
S      mc1_vol.Drv           = &mc1_drv;
S      mc1_vol.CaBuf         = mc1_cache;
S      mc1_vol.CaSize        = MC1_CACHE_SIZE * 2;
S     #if (MC1_NAME_CACHE_SIZE)
S      mc1_vol.ncache        = &mc1_ncache;
S     #else
S      mc1_vol.ncache        = NULL;
S     #endif
S
S      mc1_dev.Instance      = 1;
S      mc1_dev.ExtCSD        = (uint8_t *)mc1_cache;
S     /* Register MCI driver for Native mode */
S     #if   (MC1_SPI == 0)
S      mc1_dev.Driver        = &CREATE_SYMBOL (Driver_MCI, MC1_MCI_DRIVER);
S      mc1_dev.Callback      = MC1_MCI_SignalEvent;
S     #elif (MC1_SPI == 1)
S      /* Register SPI driver for SPI mode */
S      mc1_dev.Driver        = &CREATE_SYMBOL (Driver_SPI, MC1_SPI_DRIVER);
S      mc1_dev.Callback      = MC1_SPI_SignalEvent;
S     #else
S      #error "Memory Card Interface Mode Invalid in FS_Config_MC_1.h"
S     #endif
S
S     #if (MC1_FAT_JOURNAL)
S      /* Register file system journal */
S      mc1_fsj.buf           = (uint8_t *)&mc1_cache[(MC1_CACHE_SIZE+1) * 256];
S      mc1_vol.fsj           = &mc1_fsj;
S      mc1_vol.RsvdS         = FAT_SECT_RSVD;
S     #else
S      mc1_vol.fsj           = NULL;
S      mc1_vol.RsvdS         = 0;
S     #endif
S      break;
N#endif /* MC1_ENABLE */
N  }
N}
N
N__inline static void fs_config_nand (char num) {
N  switch (num) {
N#if (NAND0_ENABLE)
X#if (0)
S    case '0':
S      nand0_vol.Drv               = &nand0_drv;
S      nand0_vol.CaBuf             = nand0_cache;
S      nand0_vol.CaSize            = NAND0_CACHE_SIZE * 2;
S     #if (NAND0_NAME_CACHE_SIZE)
S      nand0_vol.ncache            = &nand0_ncache;
S     #else
S      nand0_vol.ncache            = NULL;
S     #endif
S
S      nand0_handle.Media          = &nand0_media_handle;
S      nand0_handle.Cfg            = &nand0_cfg;
S
S      nand0_hw_driver.hw_cb       = &NAND0_HW_SignalEventHandler;
S      nand0_hw_driver.drv         = &CREATE_SYMBOL (Driver_NAND, NAND0_DRIVER);
S      nand0_hw_driver.init        = 0;
S
S      nand0_media_handle.media_cb = &NAND0_Media_SignalEventHandler;
S      nand0_media_handle.hw       = &nand0_hw_driver;
S      nand0_media_handle.dev      = &nand0_device;
S      nand0_media_handle.status   = 0;
S
S     #if (NAND0_FAT_JOURNAL)
S      /* Register file system journal */
S      nand0_fsj.buf               = (uint8_t *)&nand0_cache[NAND0_CSZ/4];
S      nand0_vol.fsj               = &nand0_fsj;
S      nand0_vol.RsvdS             = FAT_SECT_RSVD;
S     #else
S      nand0_vol.fsj               = NULL;
S      nand0_vol.RsvdS             = 0;
S     #endif
S      break;
N#endif /* NAND0_ENABLE */
N
N#if (NAND1_ENABLE)
X#if (0)
S    case '1':
S      nand1_vol.Drv               = &nand1_drv;
S      nand1_vol.CaBuf             = nand1_cache;
S      nand1_vol.CaSize            = NAND1_CACHE_SIZE * 2;
S     #if (NAND1_NAME_CACHE_SIZE)
S      nand1_vol.ncache            = &nand1_ncache;
S     #else
S      nand1_vol.ncache            = NULL;
S     #endif
S
S      nand1_handle.Media          = &nand1_media_handle;
S      nand1_handle.Cfg            = &nand1_cfg;
S
S      #if NAND1_DRIVER_CONFIG
S      nand1_hw_driver.hw_cb       = &NAND1_HW_EVENT_HANDLER;
S      nand1_hw_driver.drv         = &CREATE_SYMBOL (Driver_NAND, NAND1_DRIVER);
S      nand1_hw_driver.init        = 0;
S      #endif
S
S      nand1_media_handle.media_cb = &NAND1_MEDIA_EVENT_HANDLER;
S      nand1_media_handle.hw       = &NAND1_HW_DRIVER;
S      nand1_media_handle.dev      = &nand1_device;
S      nand1_media_handle.status   = 0;
S
S     #if (NAND1_FAT_JOURNAL)
S      /* Register file system journal */
S      nand1_fsj.buf               = (uint8_t *)&nand1_cache[NAND1_CSZ/4];
S      nand1_vol.fsj               = &nand1_fsj;
S      nand1_vol.RsvdS             = FAT_SECT_RSVD;
S     #else
S      nand1_vol.fsj               = NULL;
S      nand1_vol.RsvdS             = 0;
S     #endif
S      break;
N#endif /* NAND1_ENABLE */
N  }
N}
N
N__inline static void fs_config_ram (char num) {
N  switch (num) {
N#if (RAM0_ENABLE)
X#if (0)
S    case '0':
S      ram0_vol.Drv      = &ram0_drv;
S      ram0_vol.CaBuf    = ram0_buf;
S      ram0_vol.CaSize   = 0;
S      ram0_vol.RsvdS    = 0;
S      ram0_vol.fsj      = NULL;
S      break;
N#endif /* RAM0_ENABLE */
N  }
N}
N
N__inline static void fs_config_usb (char num) {
N  switch (num) {
N#if (USB0_ENABLE)
X#if (0)
S    case '0':
S      usb0_vol.Drv      = &usb0_drv;
S      usb0_vol.CaBuf    = usb0_cache;
S      usb0_vol.CaSize   = USB0_CACHE_SIZE * 2;
S     #if (USB0_NAME_CACHE_SIZE)
S      usb0_vol.ncache   = &usb0_ncache;
S     #else
S      usb0_vol.ncache   = NULL;
S     #endif
S
S     #if (USB0_FAT_JOURNAL)
S      /* Register file system journal */
S      usb0_fsj.buf      = (uint8_t *)&usb0_cache[(USB0_CACHE_SIZE+1) * 256];
S      usb0_vol.fsj      = &usb0_fsj;
S      usb0_vol.RsvdS    = FAT_SECT_RSVD;
S     #else
S      usb0_vol.fsj      = NULL;
S      usb0_vol.RsvdS    = 0;
S     #endif
S      break;
N#endif /* USB0_ENABLE */
N
N#if (USB1_ENABLE)
X#if (0)
S    case '1':
S      usb1_vol.Drv      = &usb1_drv;
S      usb1_vol.CaSize   = USB1_CACHE_SIZE * 2;
S      usb1_vol.CaBuf    = usb1_cache;
S     #if (USB1_NAME_CACHE_SIZE)
S      usb1_vol.ncache   = &usb1_ncache;
S     #else
S      usb1_vol.ncache   = NULL;
S     #endif
S
S     #if (USB1_FAT_JOURNAL)
S      /* Register file system journal */
S      usb1_fsj.buf      = (uint8_t *)&usb1_cache[(USB1_CACHE_SIZE+1) * 256];
S      usb1_vol.fsj      = &usb1_fsj;
S      usb1_vol.RsvdS    = FAT_SECT_RSVD;
S     #else
S      usb1_vol.fsj      = NULL;
S      usb1_vol.RsvdS    = 0;
S     #endif
S      break;
N#endif /* USB1_ENABLE */
N  }
N}
N
N/*-----------------------------------------------------------------------------
N *  Configure Flash File System
N *----------------------------------------------------------------------------*/
Nvoid fs_config (const char *drive) {
N  switch (drive[0]) {
N#if (NOR0_ENABLE || NOR1_ENABLE)
X#if (0 || 0)
S    case 'F':
S      fs_config_flash (drive[1]);
S      break;
N#endif
N
N#if (MC0_ENABLE || MC1_ENABLE)
X#if (1 || 0)
N    case 'M':
N      fs_config_mc (drive[1]);
N      break;
N#endif
N
N#if (NAND0_ENABLE || NAND1_ENABLE)
X#if (0 || 0)
S    case 'N':
S      fs_config_nand (drive[1]);
S      break;
N#endif
N
N#if (RAM0_ENABLE)
X#if (0)
S    case 'R':
S      fs_config_ram (drive[1]);
S      break;
N#endif
N
N#if (USB0_ENABLE || USB1_ENABLE)
X#if (0 || 0)
S    case 'U':
S      fs_config_usb (drive[1]);
S      break;
N#endif
N    default:
N      STREAM_LIST_LOCK;
X      _stream_list_lock;;
N      break;
N  }
N}
N
N
N/*-----------------------------------------------------------------------------
N *  Legacy support
N *
N *  fdelete(): to use the old function API and behavior, please
N *             define MW_FILESYSTEM_FDELETE_LEGACY in the project settings.
N *----------------------------------------------------------------------------*/
N#ifdef MW_FILESYSTEM_FDELETE_LEGACY
Sextern fsStatus _fdelete_legacy (const char *path);
S
S/* Use old fdelete() function */
SfsStatus fdelete (const char *path) {
S  return (_fdelete_legacy (path));
S}
N#else
Nextern fsStatus _fdelete (const char *path, const char *options);
N
N/* Use new fdelete() function */
NfsStatus fdelete (const char *path, const char *options) {
N  return (_fdelete (path, options));
N}
N#endif
N
N
N/*-----------------------------------------------------------------------------
N *  fflush hook
N *
N *  ARM Standard Run-Time library only provides call to the _sys_write() when
N *  fflush() is called, which is the same mechanism as for fwrite(). This means
N *  that it is impossible to differentiate between a call to the fflush() and
N *  a call to the fwrite().
N *  Therefore, this hook is used to catch the calls to fflush and trigger flush
N *  operation in the FileSystem library after fflush returns.
N *----------------------------------------------------------------------------*/
N #include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 192842 $
N * Checkin $Date: 2015-04-28 10:58:32 +0100 (Tue, 28 Apr 2015) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060001
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 1365 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\fs_config.h" 2
N
Nextern int $Super$$fflush(FILE * /*stream*/);
N
N_ARMABI int $Sub$$fflush(FILE *stream) {
X__declspec(__nothrow) int $Sub$$fflush(FILE *stream) {
N  int *fh;
N
N  if ($Super$$fflush (stream) == 0) {
N    fh = (int *)stream;
N    /* File handle is at offset 5 */
N    return (__sys_ensure (fh[5]));
N  }
N  return (1);
N}
N
N
N/*-----------------------------------------------------------------------------
N *  Empty functions to reduce image size when some components are not used
N *----------------------------------------------------------------------------*/
N#if (EFS_USE == 0)
X#if ((0 + 0) == 0)
N bool     efs_path_valid (const char *p)                      { return (false);   }
X _Bool     efs_path_valid (const char *p)                      { return (0);   }
N int32_t  efs_handle_get(fsEFS_Volume *v)                     { return (-1);      }
N fsStatus efs_init      (fsEFS_Volume *v)                     { return (fsError); }
N fsStatus efs_uninit    (fsEFS_Volume *v)                     { return (fsError); }
N fsStatus efs_mount     (fsEFS_Volume *v)                     { return (fsError); }
N fsStatus efs_unmount   (fsEFS_Volume *v)                     { return (fsError); }
N fsStatus efs_open  (int32_t h, const char *p, int a)         { return (fsError); }
N fsStatus efs_close (int32_t h)                               { return (fsError); }
N int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a) { return (0);       }
N int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a) { return (-1);      }
N fsStatus efs_flush (int32_t h)                               { return (fsError); }
N int32_t  efs_flen  (int32_t h)                               { return (-1);      }
N fsStatus efs_seek  (int32_t h, uint32_t a)                   { return (fsError); }
N fsStatus efs_ffind (int32_t h, fsFileInfo *i)                { return (fsError); }
N fsStatus efs_find  (int32_t h, const char *p)                { return (fsError); }
N fsStatus efs_delete(int32_t h)                               { return (fsError); }
N int32_t  efs_analyse(fsEFS_Volume *v)                        { return (0);       }
N fsStatus efs_check  (fsEFS_Volume *v)                        { return (fsError); }
N fsStatus efs_format (fsEFS_Volume *v)                        { return (fsError); }
N uint32_t efs_free   (fsEFS_Volume *v)                        { return (0);       }
N fsStatus efs_defrag (fsEFS_Volume *v)                        { return (fsError); }
N#endif /* EFS_USE */
N
N#if (FAT_USE == 0)
X#if ((1 + 0 + 0 + 0 + 0 + 0 + 0) == 0)
S int32_t  fat_handle_get(fsFAT_Volume *v)                            { return (-1); }
S fsStatus fat_init      (fsFAT_Volume *v)                            { return (fsError); }
S fsStatus fat_uninit    (fsFAT_Volume *v)                            { return (fsError); }
S fsStatus fat_mount     (fsFAT_Volume *v)                            { return (fsError); }
S fsStatus fat_unmount   (fsFAT_Volume *v)                            { return (fsError); }
S fsStatus fat_open (int32_t h, const char *p, int32_t a)             { return (fsError); }
S fsStatus fat_close(int32_t h)                                       { return (fsError); }
S int32_t  fat_read (int32_t h, uint8_t *p, uint32_t a)               { return (-1);      }
S int32_t  fat_write(int32_t h, const uint8_t *p, uint32_t a)         { return (-1);      }
S int32_t  fat_flush(int32_t h)                                       { return (-1);      }
S int32_t  fat_flen (int32_t h)                                       { return (-1);      }
S fsStatus fat_seek (int32_t h, uint32_t a)                           { return (fsError); }
S fsStatus fat_ffind  (const char *p, fsFileInfo *i, fsFAT_Volume *v) { return (fsError); }
S#ifdef MW_FILESYSTEM_FDELETE_LEGACY
S fsStatus fat_delete_l(const char *p, fsFAT_Volume *v)               { return (fsError); }
S#else
S fsStatus fat_delete  (const char *p, const char *o, fsFAT_Volume *v){ return (fsError); }
S#endif
S fsStatus fat_rename (const char *p, const char *n, fsFAT_Volume *v) { return (fsError); }
S fsStatus fat_format (fsFAT_Volume *v, const char *o)                { return (fsError); }
S uint64_t fat_free   (fsFAT_Volume *v)                               { return (0);       }
S fsStatus fat_attrib (fsFAT_Volume *v, const char *p, uint32_t a)    { return (fsError); }
S fsStatus fat_read_label  (fsFAT_Volume *v, char *p)                 { return (fsError); }
S fsStatus fat_read_serial (fsFAT_Volume *v, uint32_t *p)             { return (fsError); }
S fsStatus fat_mkdir (const char *p, fsFAT_Volume *v)                 { return (fsError); }
S fsStatus fat_rmdir (const char *p, const char *o, fsFAT_Volume *v)  { return (fsError); }
S uint32_t fat_jour_init (fsFAT_Volume *v)                            { return (true);    }
N#else
N #if (FSJ_USE == 0)
X #if ((1 * 1 + 0 * MC1_FAT_JOURNAL + 0 * NAND0_FAT_JOURNAL + 0 * NAND1_FAT_JOURNAL + 0 * USB0_FAT_JOURNAL + 0 * USB1_FAT_JOURNAL) == 0)
S  uint32_t fat_jour_init (fsFAT_Volume *v)                               { return (true);  }
S  uint32_t fat_jour_prep (fsFAT_Volume *v)                               { return (true);  }
S  uint32_t fsj_set_space (FSJOUR *p, uint32_t s, uint32_t c)             { return (false); }
S  uint32_t fsj_write     (FSJOUR *p, uint32_t s, uint32_t c, uint8_t *b) { return (false); }
S  uint32_t fsj_init      (FSJOUR *p, FAT_DRV *d)                         { return (false); }
N #endif
N#endif /* FAT_USE */
N
N#if (NCACHE_USE == 0)
X#if ((0 + MC1_NAME_CACHE_SIZE + NAND0_NAME_CACHE_SIZE + NAND1_NAME_CACHE_SIZE + USB0_NAME_CACHE_SIZE + USB1_NAME_CACHE_SIZE) == 0)
N  uint32_t   elink_init      (void)                              { return (1);    }
N  uint32_t   elink_init_path (const char *p, bool b)             { return (0xFF); }
X  uint32_t   elink_init_path (const char *p, _Bool b)             { return (0xFF); }
N  uint32_t   elink_flush     (const char *p)                     { return (1);    }
N  uint32_t   elink_cmd       (uint32_t i, uint32_t j)            { return (0);    }
N  uint32_t   elink_insert    (void *p, uint32_t i)               { return (1);    }
N  uint32_t   elink_delete    (void *p, uint32_t i)               { return (0);    }
N  uint32_t   elink_scan      (uint32_t i, void **pp, uint32_t j) { return (1);    }
N#endif
L 76 "RTE\File_System\FS_Config.c" 2
