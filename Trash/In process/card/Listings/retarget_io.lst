L 1 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c"
N/*-----------------------------------------------------------------------------
N * Name:    retarget_io.c
N * Purpose: Retarget I/O
N * Rev.:    1.0.0
N *-----------------------------------------------------------------------------*/
N 
N/* Copyright (c) 2013 - 2015 ARM LIMITED
N 
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N 
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060001
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 35 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060001
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 36 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 192842 $
N * Checkin $Date: 2015-04-28 10:58:32 +0100 (Tue, 28 Apr 2015) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060001
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 37 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060001
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 38 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060001
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 39 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#include <rt_sys.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rt_sys.h" 1
N/* rt_sys.h: prototypes for _sys_* functions and types
N *
N * Copyright 1999 ARM Limited. All rights reserved.
N *
N * RCS $Revision: 178362 $
N * Checkin $Date: 2013-01-10 16:08:02 +0000 (Thu, 10 Jan 2013) $
N * Revising $Author: pwright $
N */
N
N#ifndef __RT_SYS_H
N#define __RT_SYS_H
N#define __ARMCLIB_VERSION 5060001
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N * This type is used by the _sys_ I/O functions to denote an open
N * file.
N */
Ntypedef int FILEHANDLE;
N
N/*
N * Open a file. May return -1 if the file failed to open.
N */
Nextern FILEHANDLE _sys_open(const char * /*name*/, int /*openmode*/);
N/*
N * openmode is a bitmap, whose bits are given below. They
N * correspond directly to the ANSI mode specification.
N */
N#define OPEN_R 0
N#define OPEN_W 4
N#define OPEN_A 8
N#define OPEN_B 1
N#define OPEN_PLUS 2
N
N/*
N * These names should be special strings which will be recognised
N * by _sys_open and will cause it to return the standard I/O
N * handles, instead of opening a real file.
N */
Nextern const char __stdin_name[];
Nextern const char __stdout_name[];
Nextern const char __stderr_name[];
N
N/*
N * Close a file. Should return 0 on success or a negative value on error.
N */
Nextern int _sys_close(FILEHANDLE /*fh*/);
N
N/*
N * Write to a file. Returns 0 on success, negative on error, and
N * the number of characters _not_ written on partial success.
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_write(FILEHANDLE /*fh*/, const unsigned char * /*buf*/,
N                      unsigned /*len*/, int /*mode*/);
N
N/*
N * Read from a file. Can return:
N *  - zero if the read was completely successful
N *  - the number of bytes _not_ read, if the read was partially successful
N *  - the number of bytes not read, plus the top bit set (0x80000000), if
N *    the read was partially successful due to end of file
N *  - -1 if some error other than EOF occurred
N *
N * It is also legal to signal EOF by returning no data but
N * signalling no error (i.e. the top-bit-set mechanism need never
N * be used).
N *
N * So if (for example) the user is trying to read 8 bytes at a time
N * from a file in which only 5 remain, this routine can do three
N * equally valid things:
N *
N *  - it can return 0x80000003 (3 bytes not read due to EOF)
N *  - OR it can return 3 (3 bytes not read), and then return
N *    0x80000008 (8 bytes not read due to EOF) on the next attempt
N *  - OR it can return 3 (3 bytes not read), and then return
N *    8 (8 bytes not read, meaning 0 read, meaning EOF) on the next
N *    attempt
N *
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_read(FILEHANDLE /*fh*/, unsigned char * /*buf*/,
N                     unsigned /*len*/, int /*mode*/);
N
N/*
N * Write a character to the output channel. This function is used
N * for last-resort error message output.
N */
Nextern void _ttywrch(int /*ch*/);
N
N/*
N * Return non-zero if the argument file is connected to a terminal.
N */
Nextern int _sys_istty(FILEHANDLE /*fh*/);
N
N/*
N * Move the file position to a given offset from the file start.
N * Returns >=0 on success, <0 on failure.
N */
Nextern int _sys_seek(FILEHANDLE /*fh*/, long /*pos*/);
N
N/*
N * Flush any OS buffers associated with fh, ensuring that the file
N * is up to date on disk. Result is >=0 if OK, negative for an
N * error.
N */
Nextern int _sys_ensure(FILEHANDLE /*fh*/);
N
N/*
N * Return the current length of a file, or <0 if an error occurred.
N * _sys_flen is allowed to reposition the file pointer (so Unix can
N * implement it with a single lseek, for example), since it is only
N * called when processing SEEK_END relative fseeks, and therefore a
N * call to _sys_flen is always followed by a call to _sys_seek.
N */
Nextern long _sys_flen(FILEHANDLE /*fh*/);
N
N/*
N * Return the name for temporary file number sig in the buffer
N * name. Returns 0 on failure. maxlen is the maximum name length
N * allowed.
N */
Nextern int _sys_tmpnam(char * /*name*/, int /*sig*/, unsigned /*maxlen*/);
N
N/*
N * Terminate the program, passing a return code back to the user.
N * This function may not return.
N */
Nextern void _sys_exit(int /*returncode*/);   /* never returns */
N
N/*
N * Return a pointer to the command line used to invoke the program.
N * The supplied buffer may be used to store the string, but need
N * not be.
N */
Nextern char *_sys_command_string(char * /*cmd*/, int /*len*/);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 40 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N 
N#include "RTE_Components.h"
L 1 "D:\Keil555\1986VE9X\card\RTE\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Component Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'card' 
N * Target:  'MDR1986VE93Y' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N#define CMSIS_Drivers_SPI0                /* Driver SPI0 */
N        #define CMSIS_Drivers_SPI1                /* Driver SPI1 */
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N#define RTE_Compiler_IO_File            /* Compiler I/O: File */
N        #define RTE_Compiler_IO_File_FS         /* Compiler I/O: File (File System) */
N#define RTE_FileSystem_Core             /* File System Core */
N          #define RTE_FileSystem_LFN              /* File System with Long Filename support */
N#define RTE_FileSystem_Drive_MC_0       /* File System Memory Card Drive 0 */
N
N#endif /* RTE_COMPONENTS_H */
L 42 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N 
N#ifdef RTE_Compiler_IO_File_FS
N#include "rl_fs_lib.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_fs_lib.h
N * Purpose: File System Library Definitions
N * Rev.:    V6.5.0
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_FS_LIB_H
N#define __RL_FS_LIB_H
N
N#if defined(RTE_FileSystem_Drive_MC_0) || defined(RTE_FileSystem_Drive_MC_1)
X#if 1L || 0L
N  #include "Driver_MCI.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_MCI.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        16. May 2014
N * $Revision:    V2.02
N *
N * Project:      MCI (Memory Card Interface) Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.02
N *    Added timeout and error flags to ARM_MCI_STATUS
N *    Added support for controlling optional RST_n pin (eMMC)
N *    Removed explicit Clock Control (ARM_MCI_CONTROL_CLOCK)
N *    Removed event ARM_MCI_EVENT_BOOT_ACK_TIMEOUT
N *  Version 2.01
N *    Decoupled SPI mode from MCI driver
N *    Replaced function ARM_MCI_CardSwitchRead with ARM_MCI_ReadCD and ARM_MCI_ReadWP
N *  Version 2.00
N *    Added support for:
N *      SD UHS-I (Ultra High Speed)
N *      SD I/O Interrupt
N *      Read Wait (SD I/O)
N *      Suspend/Resume (SD I/O)
N *      MMC Interrupt
N *      MMC Boot
N *      Stream Data transfer (MMC)
N *      VCCQ Power Supply Control (eMMC)
N *      Command Completion Signal (CCS) for CE-ATA
N *    Added ARM_MCI_Control function
N *    Added ARM_MCI_GetStatus function
N *    Removed ARM_MCI_BusMode, ARM_MCI_BusDataWidth, ARM_MCI_BusSingaling functions
N *      (replaced by ARM_MCI_Control)
N *    Changed ARM_MCI_CardPower function (voltage parameter)
N *    Changed ARM_MCI_SendCommnad function (flags parameter)
N *    Changed ARM_MCI_SetupTransfer function (mode parameter)
N *    Removed ARM_MCI_ReadTransfer and ARM_MCI_WriteTransfer functions
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Changed return values of some functions to int32_t
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_MCI_H
N#define __DRIVER_MCI_H
N
N#include "Driver_Common.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        2. Jan 2014
N * $Revision:    V2.00
N *
N * Project:      Common Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.00
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_COMMON_H
N#define __DRIVER_COMMON_H
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060001
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 41 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 2
N#include <stdint.h>
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060001
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 43 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_Common.h" 2
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* __DRIVER_COMMON_H */
L 67 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_MCI.h" 2
N
N#define ARM_MCI_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,02)  /* API version */
N
N
N/****** MCI Send Command Flags *****/
N#define ARM_MCI_RESPONSE_Pos             0
N#define ARM_MCI_RESPONSE_Msk            (3UL << ARM_MCI_RESPONSE_Pos)
N#define ARM_MCI_RESPONSE_NONE           (0UL << ARM_MCI_RESPONSE_Pos)   ///< No response expected (default)
N#define ARM_MCI_RESPONSE_SHORT          (1UL << ARM_MCI_RESPONSE_Pos)   ///< Short response (48-bit)
N#define ARM_MCI_RESPONSE_SHORT_BUSY     (2UL << ARM_MCI_RESPONSE_Pos)   ///< Short response with busy signal (48-bit)
N#define ARM_MCI_RESPONSE_LONG           (3UL << ARM_MCI_RESPONSE_Pos)   ///< Long response (136-bit)
N
N#define ARM_MCI_RESPONSE_INDEX          (1UL << 2)  ///< Check command index in response
N#define ARM_MCI_RESPONSE_CRC            (1UL << 3)  ///< Check CRC in response
N
N#define ARM_MCI_WAIT_BUSY               (1UL << 4)  ///< Wait until busy before sending the command
N
N#define ARM_MCI_TRANSFER_DATA           (1UL << 5)  ///< Activate Data transfer
N
N#define ARM_MCI_CARD_INITIALIZE         (1UL << 6)  ///< Execute Memory Card initialization sequence
N
N#define ARM_MCI_INTERRUPT_COMMAND       (1UL << 7)  ///< Send Interrupt command (CMD40 - MMC only)
N#define ARM_MCI_INTERRUPT_RESPONSE      (1UL << 8)  ///< Send Interrupt response (CMD40 - MMC only)
N
N#define ARM_MCI_BOOT_OPERATION          (1UL << 9)  ///< Execute Boot operation (MMC only)
N#define ARM_MCI_BOOT_ALTERNATIVE        (1UL << 10) ///< Execute Alternative Boot operation (MMC only)
N#define ARM_MCI_BOOT_ACK                (1UL << 11) ///< Expect Boot Acknowledge (MMC only)
N
N#define ARM_MCI_CCSD                    (1UL << 12) ///< Send Command Completion Signal Disable (CCSD) for CE-ATA device
N#define ARM_MCI_CCS                     (1UL << 13) ///< Expect Command Completion Signal (CCS) for CE-ATA device
N
N
N/****** MCI Setup Transfer Mode *****/
N#define ARM_MCI_TRANSFER_READ           (0UL << 0)  ///< Data Read Transfer (from MCI)
N#define ARM_MCI_TRANSFER_WRITE          (1UL << 0)  ///< Data Write Transfer (to MCI)
N#define ARM_MCI_TRANSFER_BLOCK          (0UL << 1)  ///< Block Data transfer (default)
N#define ARM_MCI_TRANSFER_STREAM         (1UL << 1)  ///< Stream Data transfer (MMC only)
N
N
N/****** MCI Control Codes *****/
N#define ARM_MCI_BUS_SPEED               (0x01)      ///< Set Bus Speed; arg = requested speed in bits/s; returns configured speed in bits/s
N#define ARM_MCI_BUS_SPEED_MODE          (0x02)      ///< Set Bus Speed Mode as specified with arg
N#define ARM_MCI_BUS_CMD_MODE            (0x03)      ///< Set CMD Line Mode as specified with arg
N#define ARM_MCI_BUS_DATA_WIDTH          (0x04)      ///< Set Bus Data Width as specified with arg
N#define ARM_MCI_DRIVER_STRENGTH         (0x05)      ///< Set SD UHS-I Driver Strength as specified with arg 
N#define ARM_MCI_CONTROL_RESET           (0x06)      ///< Control optional RST_n Pin (eMMC); arg: 0=inactive, 1=active 
N#define ARM_MCI_CONTROL_CLOCK_IDLE      (0x07)      ///< Control Clock generation on CLK Pin when idle; arg: 0=disabled, 1=enabled
N#define ARM_MCI_UHS_TUNING_OPERATION    (0x08)      ///< Sampling clock Tuning operation (SD UHS-I); arg: 0=reset, 1=execute
N#define ARM_MCI_UHS_TUNING_RESULT       (0x09)      ///< Sampling clock Tuning result (SD UHS-I); returns: 0=done, 1=in progress, -1=error
N#define ARM_MCI_DATA_TIMEOUT            (0x0A)      ///< Set Data timeout; arg = timeout in bus cycles
N#define ARM_MCI_CSS_TIMEOUT             (0x0B)      ///< Set Command Completion Signal (CCS) timeout; arg = timeout in bus cycles
N#define ARM_MCI_MONITOR_SDIO_INTERRUPT  (0x0C)      ///< Monitor SD I/O interrupt: arg: 0=disabled, 1=enabled
N#define ARM_MCI_CONTROL_READ_WAIT       (0x0D)      ///< Control Read/Wait for SD I/O; arg: 0=disabled, 1=enabled
N#define ARM_MCI_SUSPEND_TRANSFER        (0x0E)      ///< Suspend Data transfer (SD I/O); returns number of remaining bytes to transfer
N#define ARM_MCI_RESUME_TRANSFER         (0x0F)      ///< Resume Data transfer (SD I/O)
N
N/*----- MCI Bus Speed Mode -----*/
N#define ARM_MCI_BUS_DEFAULT_SPEED       (0x00)      ///< SD/MMC: Default Speed mode up to 25/26MHz
N#define ARM_MCI_BUS_HIGH_SPEED          (0x01)      ///< SD/MMC: High    Speed mode up to 50/52MHz
N#define ARM_MCI_BUS_UHS_SDR12           (0x02)      ///< SD: SDR12  (Single Data Rate) up to  25MHz,  12.5MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR25           (0x03)      ///< SD: SDR25  (Single Data Rate) up to  50MHz,  25  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR50           (0x04)      ///< SD: SDR50  (Single Data Rate) up to 100MHz,  50  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_SDR104          (0x05)      ///< SD: SDR104 (Single Data Rate) up to 208MHz, 104  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N#define ARM_MCI_BUS_UHS_DDR50           (0x06)      ///< SD: DDR50  (Dual Data Rate)   up to  50MHz,  50  MB/s: UHS-I (Ultra High Speed) 1.8V signaling
N
N/*----- MCI CMD Line Mode -----*/
N#define ARM_MCI_BUS_CMD_PUSH_PULL       (0x00)      ///< Push-Pull CMD line (default)
N#define ARM_MCI_BUS_CMD_OPEN_DRAIN      (0x01)      ///< Open Drain CMD line (MMC only)
N
N/*----- MCI Bus Data Width -----*/
N#define ARM_MCI_BUS_DATA_WIDTH_1        (0x00)      ///< Bus data width: 1 bit (default)
N#define ARM_MCI_BUS_DATA_WIDTH_4        (0x01)      ///< Bus data width: 4 bits
N#define ARM_MCI_BUS_DATA_WIDTH_8        (0x02)      ///< Bus data width: 8 bits
N#define ARM_MCI_BUS_DATA_WIDTH_4_DDR    (0x03)      ///< Bus data width: 4 bits, DDR (Dual Data Rate) - MMC only
N#define ARM_MCI_BUS_DATA_WIDTH_8_DDR    (0x04)      ///< Bus data width: 8 bits, DDR (Dual Data Rate) - MMC only
N
N/*----- MCI Driver Strength -----*/
N#define ARM_MCI_DRIVER_TYPE_A           (0x01)      ///< SD UHS-I Driver Type A
N#define ARM_MCI_DRIVER_TYPE_B           (0x00)      ///< SD UHS-I Driver Type B (default)
N#define ARM_MCI_DRIVER_TYPE_C           (0x02)      ///< SD UHS-I Driver Type C
N#define ARM_MCI_DRIVER_TYPE_D           (0x03)      ///< SD UHS-I Driver Type D
N
N
N/****** MCI Card Power *****/
N#define ARM_MCI_POWER_VDD_Pos            0
N#define ARM_MCI_POWER_VDD_Msk           (0x0FUL << ARM_MCI_POWER_VDD_Pos)
N#define ARM_MCI_POWER_VDD_OFF           (0x01UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) turned off
N#define ARM_MCI_POWER_VDD_3V3           (0x02UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) = 3.3V
N#define ARM_MCI_POWER_VDD_1V8           (0x03UL << ARM_MCI_POWER_VDD_Pos)   ///< VDD (VCC) = 1.8V
N#define ARM_MCI_POWER_VCCQ_Pos           4
N#define ARM_MCI_POWER_VCCQ_Msk          (0x0FUL << ARM_MCI_POWER_VCCQ_Pos)
N#define ARM_MCI_POWER_VCCQ_OFF          (0x01UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ turned off
N#define ARM_MCI_POWER_VCCQ_3V3          (0x02UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 3.3V
N#define ARM_MCI_POWER_VCCQ_1V8          (0x03UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 1.8V
N#define ARM_MCI_POWER_VCCQ_1V2          (0x04UL << ARM_MCI_POWER_VCCQ_Pos)  ///< eMMC VCCQ = 1.2V
N
N
N/**
N\brief MCI Status
N*/
Ntypedef struct _ARM_MCI_STATUS {
N  uint32_t command_active   : 1;        ///< Command active flag
N  uint32_t command_timeout  : 1;        ///< Command timeout flag (cleared on start of next command)
N  uint32_t command_error    : 1;        ///< Command error flag (cleared on start of next command)
N  uint32_t transfer_active  : 1;        ///< Transfer active flag
N  uint32_t transfer_timeout : 1;        ///< Transfer timeout flag (cleared on start of next command)
N  uint32_t transfer_error   : 1;        ///< Transfer error flag (cleared on start of next command)
N  uint32_t sdio_interrupt   : 1;        ///< SD I/O Interrupt flag (cleared on start of monitoring)
N  uint32_t ccs              : 1;        ///< CCS flag (cleared on start of next command)
N} ARM_MCI_STATUS;
N
N
N/****** MCI Card Event *****/
N#define ARM_MCI_EVENT_CARD_INSERTED     (1UL << 0)  ///< Memory Card inserted
N#define ARM_MCI_EVENT_CARD_REMOVED      (1UL << 1)  ///< Memory Card removed
N#define ARM_MCI_EVENT_COMMAND_COMPLETE  (1UL << 2)  ///< Command completed
N#define ARM_MCI_EVENT_COMMAND_TIMEOUT   (1UL << 3)  ///< Command timeout
N#define ARM_MCI_EVENT_COMMAND_ERROR     (1UL << 4)  ///< Command response error (CRC error or invalid response)
N#define ARM_MCI_EVENT_TRANSFER_COMPLETE (1UL << 5)  ///< Data transfer completed
N#define ARM_MCI_EVENT_TRANSFER_TIMEOUT  (1UL << 6)  ///< Data transfer timeout
N#define ARM_MCI_EVENT_TRANSFER_ERROR    (1UL << 7)  ///< Data transfer CRC failed
N#define ARM_MCI_EVENT_SDIO_INTERRUPT    (1UL << 8)  ///< SD I/O Interrupt
N#define ARM_MCI_EVENT_CCS               (1UL << 9)  ///< Command Completion Signal (CCS)
N#define ARM_MCI_EVENT_CCS_TIMEOUT       (1UL << 10) ///< Command Completion Signal (CCS) Timeout
N
N
N// Function documentation
N/**
N  \fn            ARM_DRIVER_VERSION ARM_MCI_GetVersion (void)
N  \brief         Get driver version.
N  \return        \ref ARM_DRIVER_VERSION
N*/
N/**
N  \fn            ARM_MCI_CAPABILITIES ARM_MCI_GetCapabilities (void)
N  \brief         Get driver capabilities.
N  \return        \ref ARM_MCI_CAPABILITIES
N*/
N/**
N  \fn            int32_t ARM_MCI_Initialize (ARM_MCI_SignalEvent_t cb_event)
N  \brief         Initialize the Memory Card Interface
N  \param[in]     cb_event  Pointer to \ref ARM_MCI_SignalEvent
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_Uninitialize (void)
N  \brief         De-initialize Memory Card Interface.
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_PowerControl (ARM_POWER_STATE state)
N  \brief         Control Memory Card Interface Power.
N  \param[in]     state   Power state \ref ARM_POWER_STATE
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_CardPower (uint32_t voltage)
N  \brief         Set Memory Card Power supply voltage.
N  \param[in]     voltage  Memory Card Power supply voltage
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_ReadCD (void)
N  \brief         Read Card Detect (CD) state.
N  \return        1:card detected, 0:card not detected, or error
N*/
N/**
N  \fn            int32_t ARM_MCI_ReadWP (void)
N  \brief         Read Write Protect (WP) state.
N  \return        1:write protected, 0:not write protected, or error
N*/
N/**
N  \fn            int32_t ARM_MCI_SendCommand (uint32_t  cmd,
N                                              uint32_t  arg,
N                                              uint32_t  flags,
N                                              uint32_t *response)
N  \brief         Send Command to card and get the response.
N  \param[in]     cmd       Memory Card command
N  \param[in]     arg       Command argument
N  \param[in]     flags     Command flags
N  \param[out]    response  Pointer to buffer for response
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_SetupTransfer (uint8_t *data,
N                                                uint32_t block_count,
N                                                uint32_t block_size,
N                                                uint32_t mode)
N  \brief         Setup read or write transfer operation.
N  \param[in,out] data         Pointer to data block(s) to be written or read
N  \param[in]     block_count  Number of blocks
N  \param[in]     block_size   Size of a block in bytes
N  \param[in]     mode         Transfer mode
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_AbortTransfer (void)
N  \brief         Abort current read/write data transfer.
N  \return        \ref execution_status
N*/
N/**
N  \fn            int32_t ARM_MCI_Control (uint32_t control, uint32_t arg)
N  \brief         Control MCI Interface.
N  \param[in]     control  Operation
N  \param[in]     arg      Argument of operation (optional)
N  \return        \ref execution_status
N*/
N/**
N  \fn            ARM_MCI_STATUS ARM_MCI_GetStatus (void)
N  \brief         Get MCI status.
N  \return        MCI status \ref ARM_MCI_STATUS
N*/
N
N/**
N  \fn            void ARM_MCI_SignalEvent (uint32_t event)
N  \brief         Callback function that signals a MCI Card Event.
N  \param[in]     event \ref mci_event_gr
N  \return        none
N*/
N
Ntypedef void (*ARM_MCI_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_MCI_SignalEvent : Signal MCI Card Event.
N
N
N/**
N\brief  MCI Driver Capabilities.
N*/
Ntypedef struct _ARM_MCI_CAPABILITIES {
N  uint32_t cd_state          : 1;       ///< Card Detect State available
N  uint32_t cd_event          : 1;       ///< Signal Card Detect change event
N  uint32_t wp_state          : 1;       ///< Write Protect State available
N  uint32_t vdd               : 1;       ///< Supports VDD Card Power Supply Control
N  uint32_t vdd_1v8           : 1;       ///< Supports 1.8 VDD Card Power Supply
N  uint32_t vccq              : 1;       ///< Supports VCCQ Card Power Supply Control (eMMC)
N  uint32_t vccq_1v8          : 1;       ///< Supports 1.8 VCCQ Card Power Supply (eMMC)
N  uint32_t vccq_1v2          : 1;       ///< Supports 1.2 VCCQ Card Power Supply (eMMC)
N  uint32_t data_width_4      : 1;       ///< Supports 4-bit data
N  uint32_t data_width_8      : 1;       ///< Supports 8-bit data
N  uint32_t data_width_4_ddr  : 1;       ///< Supports 4-bit data, DDR (Dual Data Rate) - MMC only
N  uint32_t data_width_8_ddr  : 1;       ///< Supports 8-bit data, DDR (Dual Data Rate) - MMC only
N  uint32_t high_speed        : 1;       ///< Supports SD/MMC High Speed Mode
N  uint32_t uhs_signaling     : 1;       ///< Supports SD UHS-I (Ultra High Speed) 1.8V signaling 
N  uint32_t uhs_tuning        : 1;       ///< Supports SD UHS-I tuning 
N  uint32_t uhs_sdr50         : 1;       ///< Supports SD UHS-I SDR50  (Single Data Rate) up to  50MB/s
N  uint32_t uhs_sdr104        : 1;       ///< Supports SD UHS-I SDR104 (Single Data Rate) up to 104MB/s
N  uint32_t uhs_ddr50         : 1;       ///< Supports SD UHS-I DDR50  (Dual   Data Rate) up to  50MB/s
N  uint32_t uhs_driver_type_a : 1;       ///< Supports SD UHS-I Driver Type A
N  uint32_t uhs_driver_type_c : 1;       ///< Supports SD UHS-I Driver Type C
N  uint32_t uhs_driver_type_d : 1;       ///< Supports SD UHS-I Driver Type D 
N  uint32_t sdio_interrupt    : 1;       ///< Supports SD I/O Interrupt 
N  uint32_t read_wait         : 1;       ///< Supports Read Wait (SD I/O)
N  uint32_t suspend_resume    : 1;       ///< Supports Suspend/Resume (SD I/O)
N  uint32_t mmc_interrupt     : 1;       ///< Supports MMC Interrupt 
N  uint32_t mmc_boot          : 1;       ///< Supports MMC Boot 
N  uint32_t rst_n             : 1;       ///< Supports RST_n Pin Control (eMMC)
N  uint32_t ccs               : 1;       ///< Supports Command Completion Signal (CCS) for CE-ATA
N  uint32_t ccs_timeout       : 1;       ///< Supports Command Completion Signal (CCS) timeout for CE-ATA
N} ARM_MCI_CAPABILITIES;
N
N
N/**
N\brief  Access structure of the MCI Driver.
N*/
Ntypedef struct _ARM_DRIVER_MCI {
N  ARM_DRIVER_VERSION   (*GetVersion)     (void);                           ///< Pointer to \ref ARM_MCI_GetVersion : Get driver version.
N  ARM_MCI_CAPABILITIES (*GetCapabilities)(void);                           ///< Pointer to \ref ARM_MCI_GetCapabilities : Get driver capabilities.
N  int32_t              (*Initialize)     (ARM_MCI_SignalEvent_t cb_event); ///< Pointer to \ref ARM_MCI_Initialize : Initialize MCI Interface.
N  int32_t              (*Uninitialize)   (void);                           ///< Pointer to \ref ARM_MCI_Uninitialize : De-initialize MCI Interface.
N  int32_t              (*PowerControl)   (ARM_POWER_STATE state);          ///< Pointer to \ref ARM_MCI_PowerControl : Control MCI Interface Power.
N  int32_t              (*CardPower)      (uint32_t voltage);               ///< Pointer to \ref ARM_MCI_CardPower : Set card power supply voltage.
N  int32_t              (*ReadCD)         (void);                           ///< Pointer to \ref ARM_MCI_ReadCD : Read Card Detect (CD) state.
N  int32_t              (*ReadWP)         (void);                           ///< Pointer to \ref ARM_MCI_ReadWP : Read Write Protect (WP) state.
N  int32_t              (*SendCommand)    (uint32_t cmd, 
N                                          uint32_t arg, 
N                                          uint32_t flags,
N                                          uint32_t *response);             ///< Pointer to \ref ARM_MCI_SendCommand : Send Command to card and get the response.
N  int32_t              (*SetupTransfer)  (uint8_t *data,
N                                          uint32_t block_count,
N                                          uint32_t block_size,
N                                          uint32_t mode);                  ///< Pointer to \ref ARM_MCI_SetupTransfer : Setup data transfer operation.
N  int32_t              (*AbortTransfer)  (void);                           ///< Pointer to \ref ARM_MCI_AbortTransfer : Abort current data transfer.
N  int32_t              (*Control)        (uint32_t control, uint32_t arg); ///< Pointer to \ref ARM_MCI_Control : Control MCI Interface.
N  ARM_MCI_STATUS       (*GetStatus)      (void);                           ///< Pointer to \ref ARM_MCI_GetStatus : Get MCI status.
N} const ARM_DRIVER_MCI;
N
N#endif /* __DRIVER_MCI_H */
L 15 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N  #include "Driver_SPI.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include\Driver_SPI.h" 1
N/* -----------------------------------------------------------------------------
N * Copyright (c) 2013-2014 ARM Ltd.
N *
N * This software is provided 'as-is', without any express or implied warranty.
N * In no event will the authors be held liable for any damages arising from
N * the use of this software. Permission is granted to anyone to use this
N * software for any purpose, including commercial applications, and to alter
N * it and redistribute it freely, subject to the following restrictions:
N *
N * 1. The origin of this software must not be misrepresented; you must not
N *    claim that you wrote the original software. If you use this software in
N *    a product, an acknowledgment in the product documentation would be
N *    appreciated but is not required.
N *
N * 2. Altered source versions must be plainly marked as such, and must not be
N *    misrepresented as being the original software.
N *
N * 3. This notice may not be removed or altered from any source distribution.
N *
N *
N * $Date:        17. Apr 2014
N * $Revision:    V2.01
N *
N * Project:      SPI (Serial Peripheral Interface) Driver definitions
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.01
N *    Renamed status flag "tx_rx_busy" to "busy"
N *  Version 2.00
N *    New simplified driver:
N *      complexity moved to upper layer (especially data handling)
N *      more unified API for different communication interfaces
N *    Added:
N *      Slave Mode
N *      Half-duplex Modes
N *      Configurable number of data bits
N *      Support for TI Mode and Microwire
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.01
N *    Added "send_done_event" to Capabilities
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef __DRIVER_SPI_H
N#define __DRIVER_SPI_H
N
N#include "Driver_Common.h"
N
N#define ARM_SPI_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,00)  /* API version */
N
N
N/****** SPI Control Codes *****/
N
N#define ARM_SPI_CONTROL_Pos              0
N#define ARM_SPI_CONTROL_Msk             (0xFFUL << ARM_SPI_CONTROL_Pos)
N
N/*----- SPI Control Codes: Mode -----*/
N#define ARM_SPI_MODE_INACTIVE           (0x00UL << ARM_SPI_CONTROL_Pos)     ///< SPI Inactive
N#define ARM_SPI_MODE_MASTER             (0x01UL << ARM_SPI_CONTROL_Pos)     ///< SPI Master (Output on MOSI, Input on MISO); arg = Bus Speed in bps
N#define ARM_SPI_MODE_SLAVE              (0x02UL << ARM_SPI_CONTROL_Pos)     ///< SPI Slave  (Output on MISO, Input on MOSI)
N#define ARM_SPI_MODE_MASTER_SIMPLEX     (0x03UL << ARM_SPI_CONTROL_Pos)     ///< SPI Master (Output/Input on MOSI); arg = Bus Speed in bps
N#define ARM_SPI_MODE_SLAVE_SIMPLEX      (0x04UL << ARM_SPI_CONTROL_Pos)     ///< SPI Slave  (Output/Input on MISO)
N
N/*----- SPI Control Codes: Mode Parameters: Frame Format -----*/
N#define ARM_SPI_FRAME_FORMAT_Pos         8
N#define ARM_SPI_FRAME_FORMAT_Msk        (7UL << ARM_SPI_FRAME_FORMAT_Pos)
N#define ARM_SPI_CPOL0_CPHA0             (0UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 0, Clock Phase 0 (default)
N#define ARM_SPI_CPOL0_CPHA1             (1UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 0, Clock Phase 1
N#define ARM_SPI_CPOL1_CPHA0             (2UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 1, Clock Phase 0
N#define ARM_SPI_CPOL1_CPHA1             (3UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Clock Polarity 1, Clock Phase 1
N#define ARM_SPI_TI_SSI                  (4UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< Texas Instruments Frame Format
N#define ARM_SPI_MICROWIRE               (5UL << ARM_SPI_FRAME_FORMAT_Pos)   ///< National Microwire Frame Format
N
N/*----- SPI Control Codes: Mode Parameters: Data Bits -----*/
N#define ARM_SPI_DATA_BITS_Pos            12
N#define ARM_SPI_DATA_BITS_Msk           (0x3FUL << ARM_SPI_DATA_BITS_Pos)
N#define ARM_SPI_DATA_BITS(n)            (((n) & 0x3F) << ARM_SPI_DATA_BITS_Pos) ///< Number of Data bits
N
N/*----- SPI Control Codes: Mode Parameters: Bit Order -----*/
N#define ARM_SPI_BIT_ORDER_Pos            18
N#define ARM_SPI_BIT_ORDER_Msk           (1UL << ARM_SPI_BIT_ORDER_Pos)
N#define ARM_SPI_MSB_LSB                 (0UL << ARM_SPI_BIT_ORDER_Pos)      ///< SPI Bit order from MSB to LSB (default)
N#define ARM_SPI_LSB_MSB                 (1UL << ARM_SPI_BIT_ORDER_Pos)      ///< SPI Bit order from LSB to MSB
N
N/*----- SPI Control Codes: Mode Parameters: Slave Select Mode -----*/
N#define ARM_SPI_SS_MASTER_MODE_Pos       19
N#define ARM_SPI_SS_MASTER_MODE_Msk      (3UL << ARM_SPI_SS_MASTER_MODE_Pos)
N#define ARM_SPI_SS_MASTER_UNUSED        (0UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Not used (default)
N#define ARM_SPI_SS_MASTER_SW            (1UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Software controlled
N#define ARM_SPI_SS_MASTER_HW_OUTPUT     (2UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Hardware controlled Output
N#define ARM_SPI_SS_MASTER_HW_INPUT      (3UL << ARM_SPI_SS_MASTER_MODE_Pos) ///< SPI Slave Select when Master: Hardware monitored Input
N#define ARM_SPI_SS_SLAVE_MODE_Pos        21
N#define ARM_SPI_SS_SLAVE_MODE_Msk       (1UL << ARM_SPI_SS_SLAVE_MODE_Pos)
N#define ARM_SPI_SS_SLAVE_HW             (0UL << ARM_SPI_SS_SLAVE_MODE_Pos)  ///< SPI Slave Select when Slave: Hardware monitored (default)
N#define ARM_SPI_SS_SLAVE_SW             (1UL << ARM_SPI_SS_SLAVE_MODE_Pos)  ///< SPI Slave Select when Slave: Software controlled
N
N
N/*----- SPI Control Codes: Miscellaneous Controls  -----*/
N#define ARM_SPI_SET_BUS_SPEED           (0x10UL << ARM_SPI_CONTROL_Pos)     ///< Set Bus Speed in bps; arg = value
N#define ARM_SPI_GET_BUS_SPEED           (0x11UL << ARM_SPI_CONTROL_Pos)     ///< Get Bus Speed in bps
N#define ARM_SPI_SET_DEFAULT_TX_VALUE    (0x12UL << ARM_SPI_CONTROL_Pos)     ///< Set default Transmit value; arg = value
N#define ARM_SPI_CONTROL_SS              (0x13UL << ARM_SPI_CONTROL_Pos)     ///< Control Slave Select; arg: 0=inactive, 1=active 
N#define ARM_SPI_ABORT_TRANSFER          (0x14UL << ARM_SPI_CONTROL_Pos)     ///< Abort current data transfer
N
N
N/****** SPI Slave Select Signal definitions *****/
N#define ARM_SPI_SS_INACTIVE              0                                  ///< SPI Slave Select Signal Inactive
N#define ARM_SPI_SS_ACTIVE                1                                  ///< SPI Slave Select Signal Active
N
N
N/****** SPI specific error codes *****/
N#define ARM_SPI_ERROR_MODE              (ARM_DRIVER_ERROR_SPECIFIC - 1)     ///< Specified Mode not supported
N#define ARM_SPI_ERROR_FRAME_FORMAT      (ARM_DRIVER_ERROR_SPECIFIC - 2)     ///< Specified Frame Format not supported
N#define ARM_SPI_ERROR_DATA_BITS         (ARM_DRIVER_ERROR_SPECIFIC - 3)     ///< Specified number of Data bits not supported
N#define ARM_SPI_ERROR_BIT_ORDER         (ARM_DRIVER_ERROR_SPECIFIC - 4)     ///< Specified Bit order not supported
N#define ARM_SPI_ERROR_SS_MODE           (ARM_DRIVER_ERROR_SPECIFIC - 5)     ///< Specified Slave Select Mode not supported
N
N
N/**
N\brief SPI Status
N*/
Ntypedef struct _ARM_SPI_STATUS {
N  uint32_t busy       : 1;              ///< Transmitter/Receiver busy flag
N  uint32_t data_lost  : 1;              ///< Data lost: Receive overflow / Transmit underflow (cleared on start of transfer operation)
N  uint32_t mode_fault : 1;              ///< Mode fault detected; optional (cleared on start of transfer operation)
N} ARM_SPI_STATUS;
N
N
N/****** SPI Event *****/
N#define ARM_SPI_EVENT_TRANSFER_COMPLETE (1UL << 0)  ///< Data Transfer completed
N#define ARM_SPI_EVENT_DATA_LOST         (1UL << 1)  ///< Data lost: Receive overflow / Transmit underflow
N#define ARM_SPI_EVENT_MODE_FAULT        (1UL << 2)  ///< Master Mode Fault (SS deactivated when Master)
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_SPI_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N
N  \fn          ARM_SPI_CAPABILITIES ARM_SPI_GetCapabilities (void)
N  \brief       Get driver capabilities.
N  \return      \ref ARM_SPI_CAPABILITIES
N
N  \fn          int32_t ARM_SPI_Initialize (ARM_SPI_SignalEvent_t cb_event)
N  \brief       Initialize SPI Interface.
N  \param[in]   cb_event  Pointer to \ref ARM_SPI_SignalEvent
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Uninitialize (void)
N  \brief       De-initialize SPI Interface.
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_PowerControl (ARM_POWER_STATE state)
N  \brief       Control SPI Interface Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Send (const void *data, uint32_t num)
N  \brief       Start sending data to SPI transmitter.
N  \param[in]   data  Pointer to buffer with data to send to SPI transmitter
N  \param[in]   num   Number of data items to send
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Receive (void *data, uint32_t num)
N  \brief       Start receiving data from SPI receiver.
N  \param[out]  data  Pointer to buffer for data to receive from SPI receiver
N  \param[in]   num   Number of data items to receive
N  \return      \ref execution_status
N
N  \fn          int32_t ARM_SPI_Transfer (const void *data_out,
N                                               void *data_in,
N                                         uint32_t    num)
N  \brief       Start sending/receiving data to/from SPI transmitter/receiver.
N  \param[in]   data_out  Pointer to buffer with data to send to SPI transmitter
N  \param[out]  data_in   Pointer to buffer for data to receive from SPI receiver
N  \param[in]   num       Number of data items to transfer
N  \return      \ref execution_status
N
N  \fn          uint32_t ARM_SPI_GetDataCount (void)
N  \brief       Get transferred data count.
N  \return      number of data items transferred
N
N  \fn          int32_t ARM_SPI_Control (uint32_t control, uint32_t arg)
N  \brief       Control SPI Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      common \ref execution_status and driver specific \ref spi_execution_status
N
N  \fn          ARM_SPI_STATUS ARM_SPI_GetStatus (void)
N  \brief       Get SPI status.
N  \return      SPI status \ref ARM_SPI_STATUS
N
N  \fn          void ARM_SPI_SignalEvent (uint32_t event)
N  \brief       Signal SPI Events.
N  \param[in]   event \ref SPI_events notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_SPI_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_SPI_SignalEvent : Signal SPI Event.
N
N
N/**
N\brief SPI Driver Capabilities.
N*/
Ntypedef struct _ARM_SPI_CAPABILITIES {
N  uint32_t simplex          : 1;        ///< supports Simplex Mode (Master and Slave)
N  uint32_t ti_ssi           : 1;        ///< supports TI Synchronous Serial Interface
N  uint32_t microwire        : 1;        ///< supports Microwire Interface
N  uint32_t event_mode_fault : 1;        ///< Signal Mode Fault event: \ref ARM_SPI_EVENT_MODE_FAULT
N} ARM_SPI_CAPABILITIES;
N
N
N/**
N\brief Access structure of the SPI Driver.
N*/
Ntypedef struct _ARM_DRIVER_SPI {
N  ARM_DRIVER_VERSION   (*GetVersion)      (void);                             ///< Pointer to \ref ARM_SPI_GetVersion : Get driver version.
N  ARM_SPI_CAPABILITIES (*GetCapabilities) (void);                             ///< Pointer to \ref ARM_SPI_GetCapabilities : Get driver capabilities.
N  int32_t              (*Initialize)      (ARM_SPI_SignalEvent_t cb_event);   ///< Pointer to \ref ARM_SPI_Initialize : Initialize SPI Interface.
N  int32_t              (*Uninitialize)    (void);                             ///< Pointer to \ref ARM_SPI_Uninitialize : De-initialize SPI Interface.
N  int32_t              (*PowerControl)    (ARM_POWER_STATE state);            ///< Pointer to \ref ARM_SPI_PowerControl : Control SPI Interface Power.
N  int32_t              (*Send)            (const void *data, uint32_t num);   ///< Pointer to \ref ARM_SPI_Send : Start sending data to SPI Interface.
N  int32_t              (*Receive)         (      void *data, uint32_t num);   ///< Pointer to \ref ARM_SPI_Receive : Start receiving data from SPI Interface.
N  int32_t              (*Transfer)        (const void *data_out,
N                                                 void *data_in,
N                                           uint32_t    num);                  ///< Pointer to \ref ARM_SPI_Transfer : Start sending/receiving data to/from SPI.
N  uint32_t             (*GetDataCount)    (void);                             ///< Pointer to \ref ARM_SPI_GetDataCount : Get transferred data count.
N  int32_t              (*Control)         (uint32_t control, uint32_t arg);   ///< Pointer to \ref ARM_SPI_Control : Control SPI Interface.
N  ARM_SPI_STATUS       (*GetStatus)       (void);                             ///< Pointer to \ref ARM_SPI_GetStatus : Get SPI status.
N} const ARM_DRIVER_SPI;
N
N#endif /* __DRIVER_SPI_H */
L 16 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N#else
S  #define ARM_DRIVER_MCI          uint32_t
S  #define ARM_MCI_SignalEvent_t   uint32_t
S  #define ARM_MCI_CAPABILITIES    uint32_t
S  #define ARM_DRIVER_SPI          uint32_t
S  #define ARM_SPI_SignalEvent_t   uint32_t
S  #define ARM_SPI_CAPABILITIES    uint32_t
N#endif
N
N#if defined(RTE_FileSystem_Drive_NAND_0) || defined(RTE_FileSystem_Drive_NAND_1)
X#if 0L || 0L
S  #include "Driver_NAND.h"
N#else
N  #define ARM_DRIVER_NAND         uint32_t
N  #define ARM_NAND_SignalEvent_t  uint32_t
N  #define ARM_NAND_CAPABILITIES   uint32_t
N#endif
N
N#if defined(RTE_FileSystem_Drive_NOR_0) || defined(RTE_FileSystem_Drive_NOR_1)
X#if 0L || 0L
S  #include "Driver_Flash.h"
N#else
N  #define ARM_DRIVER_FLASH        uint32_t
N  #define ARM_Flash_SignalEvent_t uint32_t
N  #define ARM_FLASH_CAPABILITIES  uint32_t
N  #define ARM_FLASH_SECTOR        uint32_t
N#endif
N
N#include "rl_fs.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::File System
N * Copyright (c) 2004-2015 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_fs.h
N * Purpose: File System API
N * Rev.:    V6.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_FS_H
N#define __RL_FS_H
N
N#include <stdint.h>
N#include <stdbool.h>
N
N// ==== Enumeration, structures, defines ====
N
N/// FAT File Attribute bit masks.
N#define FS_FAT_ATTR_READ_ONLY    0x01   ///< Read-only file attribute
N#define FS_FAT_ATTR_HIDDEN       0x02   ///< Hidden file attribute
N#define FS_FAT_ATTR_SYSTEM       0x04   ///< System file attribute
N#define FS_FAT_ATTR_VOLUME_ID    0x08   ///< Volume ID attribute
N#define FS_FAT_ATTR_DIRECTORY    0x10   ///< Directory file attribute
N#define FS_FAT_ATTR_ARCHIVE      0x20   ///< Archive file attribute
N
N/// IOC control code fsDevCtrlCodeCheckMedia return bit masks.
N#define FS_MEDIA_INSERTED        0x01   ///< Media Detected
N#define FS_MEDIA_PROTECTED       0x02   ///< Media Write Protected
N#define FS_MEDIA_INITIALIZED     0x04   ///< Media Initialized
N#define FS_MEDIA_NOCHKMEDIA      0x80   ///< Check Media Not implemented
N
N/// IOC control code fsDevCtrlCodeControlMedia argument values.
N#define FS_CONTROL_MEDIA_INIT    0x00   ///< Initialize media device
N#define FS_CONTROL_EMMC_SLEEP    0x01   ///< Switch eMMC device to Sleep State
N#define FS_CONTROL_EMMC_AWAKE    0x02   ///< Wake-up eMMC device from Sleep State
N
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// File System return codes.
Ntypedef enum {
N  fsOK = 0,                             ///< Operation succeeded
N  fsError,                              ///< Unspecified error
N  fsUnsupported,                        ///< Operation not supported
N  fsAccessDenied,                       ///< Resource access denied
N  fsInvalidParameter,                   ///< Invalid parameter specified
N  fsInvalidDrive,                       ///< Nonexistent drive
N  fsInvalidPath,                        ///< Invalid path specified
N  fsUninitializedDrive,                 ///< Drive is uninitialized
N  fsDriverError,                        ///< Read/write error
N  fsMediaError,                         ///< Media error
N  fsNoMedia,                            ///< No media, or not initialized
N  fsNoFileSystem,                       ///< File system is not formatted
N  fsNoFreeSpace,                        ///< No free space available
N  fsFileNotFound,                       ///< Requested file not found
N  fsDirNotEmpty,                        ///< The directory is not empty
N  fsTooManyOpenFiles                    ///< Too many open files
N} fsStatus;
N
N/// File System Type.
Ntypedef enum _fsType {
N  fsTypeNone = 0,                       ///< No file system (volume unformatted)
N  fsTypeUnknown,                        ///< File system type is unknown
N  fsTypeFAT12,                          ///< File system type is FAT12
N  fsTypeFAT16,                          ///< File system type is FAT16
N  fsTypeFAT32,                          ///< File system type is FAT32
N  fsTypeEFS                             ///< File system type is EFS
N} fsType;
N
N/// Driver DeviceCtrl parameter code.
Ntypedef enum _fsDevCtrlCode {
N  fsDevCtrlCodeCheckMedia = 0,          ///< Check Media Status
N  fsDevCtrlCodeControlMedia,            ///< Control Media Device
N  fsDevCtrlCodeFormat,                  ///< Format Media at low level
N  fsDevCtrlCodeSerial,                  ///< Return device serial number
N  fsDevCtrlCodeGetCID                   ///< Read Memory Card CID Register
N} fsDevCtrlCode;
N
N/// Media information.
Ntypedef struct _fsMediaInfo {
N  uint32_t  block_cnt;                  ///< Total number of blocks on the volume
N  uint16_t  read_blen;                  ///< Read block length
N  uint16_t  write_blen;                 ///< Write block length
N} fsMediaInfo;
N
N/// IO Control Cache information.
Ntypedef struct _fsIOC_Cache {
N  uint8_t *buffer;                      ///< Cache Buffer (4 byte aligned)
N  uint32_t size;                        ///< Cache Buffer size in bytes
N} fsIOC_Cache;
N
N/// Memory card CID register.
Ntypedef struct _fsCID_Register {
N  uint32_t   PSN;                       ///< Product serial number
N  uint16_t   OID;                       ///< OEM/Application ID
N  uint8_t    MID;                       ///< Manufacturer ID
N  uint8_t    PRV;                       ///< Product revision
N  uint16_t   MDT;                       ///< Manufacturing date
N  uint8_t    PNM[6];                    ///< Product name
N} fsCID_Register;
N
N/// File System Time structure.
Ntypedef struct _fsTime {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} fsTime;
N
N/// File information data.
Ntypedef struct _fsFileInfo {
N  char     name[256];                   ///< Filename path
N  uint32_t size;                        ///< File size in bytes
N  uint16_t fileID;                      ///< System Identification
N  uint8_t  attrib;                      ///< Attributes
N  fsTime   time;                        ///< Create/Modify Time
N} fsFileInfo;
N
N/// Drive information.
Ntypedef struct _fsDriveInfo {
N  fsType   fs_type;                     ///< Drives file system type
N  uint64_t capacity;                    ///< Drives capacity in bytes
N} fsDriveInfo;
N
N
N//  ==== System Routines ====
N
N/// \brief Initialize File System and drive related driver.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Failed to initialize the driver.
Nextern fsStatus finit (const char *drive);
N
N/// \brief Uninitialize File System.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funinit (const char *drive);
N
N/// \brief Mount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsUninitializedDrive = Media driver not initialized.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsDriverError      = Media driver operation failed.
N///               - fsMediaError       = Failed to initialize the media.
N///               - fsNoMedia          = Media device is not insterted.
N///               - fsNoFileSystem     = No filesystem on the volume.
Nextern fsStatus fmount (const char *drive);
N
N/// \brief Unmount drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameter invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus funmount (const char *drive);
N
N
N//  ==== File Maintenance Routines ====
N
N/// \brief Delete one or multiple files.
N/// \param[in]  path                     a string specifying the file or directory.
N/// \param[in]  options                  a string specifying function options.
N/// \return     execution status \ref fsStatus
N#ifdef MW_FILESYSTEM_FDELETE_LEGACY
Sextern fsStatus fdelete (const char *path);
N#else
Nextern fsStatus fdelete (const char *path, const char *options);
N#endif
N
N
N/// \brief Find a file or directory matching search pattern.
N/// \param[in]  pattern                  string specifying the pattern.
N///                                      - May include drive prefix and the following wildcards:
N///                                      - "*" or "*.*" searches for all files in the directory.
N///                                      - "abc*"       searches for files that begin with abc.
N///                                      - "*.htm"      searches for files that end with .htm.
N///                                      - "abc*.text"  searches for files that begin with abc and that end with .text.
N/// \param[out] info                     structure storing information about matching files.
N/// \return     execution status \ref fsStatus
Nextern fsStatus ffind (const char *pattern, fsFileInfo *info);
N
N/// \brief Rename a file or directory with given path name to a new name.
N/// \param[in]  path                     string specifying the file or directory path.
N/// \param[in]  newname                  string specifying new file or directory name.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frename (const char *path, const char *newname);
N
N/// \brief Change file attributes.
N/// \param[in]  path                     string specifying file or directory path.
N/// \param[in]  attr                     string specifying file or directory attributes to be modified.
N///                                      The following characters are allowed within attr string:
N///                                      - + Sets an attribute.
N///                                      - - Clears an attribute.
N///                                      - R Read-only file attribute.
N///                                      - A Archive file attribute.
N///                                      - S System file attribute.
N///                                      - H Hidden file attribute.
N/// \return     execution status \ref fsStatus
N/// \note       This function supports FAT drives only.
Nextern fsStatus fattrib (const char *path, const char *attr);
N
N
N//  ==== Directory Maintenance Routines ====
N
N/// \brief Print working directory.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] buf                      pointer to string buffer.
N/// \param[in]  len                      string buffer length.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fpwd (const char *drive, char *buf, uint32_t len);
N
N/// \brief Change working directory.
N/// \param[in]  path                     string specifying the directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdir (const char *path);
N
N/// \brief Create a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fmkdir (const char *path);
N
N/// \brief Remove a directory.
N/// \param[in]  path                     string specifying directory path.
N/// \param[in]  options                  string specifying function options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus frmdir (const char *path, const char *options);
N
N
N//  ==== Utility Routines ====
N
N/// \brief Change current drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
Nextern fsStatus fchdrive (const char *drive);
N
N/// \brief Find free space on drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     free space or execution status
N///             - value >= 0: free space on drive in bytes.
N///             - value < 0:  error occurred, -value is execution status as defined with \ref fsStatus
Nextern int64_t ffree (const char *drive);
N
N/// \brief Format drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[in]  options                  string specifying formatting options.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fformat (const char *drive, const char *options);
N
N/// \brief Analyse volume and check for file fragmentation.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     fragmentation factor or execution status
N///             - value >= 0 or <= 255: fragmentation factor
N///             - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
N/// \note       This function supports EFS drives only.
Nextern int32_t fanalyse (const char *drive);
N
N/// \brief Analyse volume and check for allocation errors.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful, no allocation errors
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Unsupported drive.
N///               - fsError            = Check failed due to allocation errors.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fcheck (const char *drive);
N
N/// \brief Defragment Embedded Flash drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Not all files are closed on specified drive or unsupported drive.
N///               - fsNoFreeSpace      = Not enough space to complete the defragmentation.
N/// \note       This function supports EFS drives only.
Nextern fsStatus fdefrag (const char *drive);
N
N/// \brief Check if media present on removable drive.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = Tried to access non-removable drive.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fmedia (const char *drive);
N
N/// \brief Read drive information.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] info                     drive information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters invalid.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
Nextern fsStatus finfo (const char *drive, fsDriveInfo *info);
N
N/// \brief Read volume label and serial number.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \param[out] label                    buffer for storing label as a null terminated string.
N///                                      When volume has no label an empty string is returned.
N///                                      This parameter can be NULL meaning label will not be read.
N/// \param[out] serial                   pointer to variable where serial number will be stored.
N///                                      This parameter can be NULL meaning serial number will not be read.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive letter specified.
N///               - fsAccessDenied     = Trying to read label and serial from EFS drive.
N///               - fsDriverError      = Read/write error.
N/// \note       This function supports FAT drives only.
Nextern fsStatus fvol (const char *drive, char *label, uint32_t *serial);
N
N
N//  ==== File Time Support Routines ====
N
N/// \brief Callback function used to provide the current date and time to the File System.
N/// \param[out] time                     Pointer to the \ref fsTime structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsError            = Failed to get the current time
N/// \note       This function supports FAT drives only.
Nextern fsStatus fs_get_time (fsTime *time);
N
N
N//  ==== Media Support Routines ====
N
N/// \brief   Callback function used to read Card Detect (CD) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:card detected, 0:card not detected, or error
Nextern int32_t fs_mc_read_cd (uint32_t drive_num);
N
N/// \brief   Callback function used to read Write Protect (WP) pin state when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \return     1:write protected, 0:not write protected, or error
Nextern int32_t fs_mc_read_wp (uint32_t drive_num);
N
N/// \brief   Callback function used to control Slave Select signal when
N///          Memory Card is used in SPI mode.
N/// \param[in]  drive_num                Memory Card Drive number
N/// \param[in]  ss                       Slave select signal state
N/// \return     execution status
N///               - slave select signal state: 1:active, 0:inactive
N///               - -1: slave select signal control is not implemented
Nextern int32_t fs_mc_spi_control_ss (uint32_t drive_num, uint32_t ss);
N
N
N//  ==== I/O Control Interface Routines ====
N
N/// \brief Check if valid drive is specified and return its ID.
N/// \param[in]  drive                    a string specifying the \ref drive "memory or storage device".
N/// \return     drive ID or execution status
N///               - value >= 0: drive ID as an integer when specified drive exists and allows IOC access
N///               - value < 0: error occurred, -value is execution status as defined with \ref fsStatus
Nextern int32_t fs_ioc_get_id (const char *drive);
N
N/// \brief Lock drive and block media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_lock (int32_t drv_id);
N
N/// \brief Unlock drive and allow media access to the upper layer.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_unlock (int32_t drv_id);
N
N/// \brief Return IOC cache buffer information.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] cache_info               IOC Cache information.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidParameter = Input parameters are not valid.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
Nextern fsStatus fs_ioc_get_cache (int32_t drv_id, fsIOC_Cache *cache_info);
N
N/// \brief Read sector from media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_read_sector (int32_t drv_id, uint32_t sect, uint8_t *buf, uint32_t cnt);
N
N/// \brief Write sector to media.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  sect                     Sector number.
N/// \param[out] buf                      Data buffer.
N/// \param[in]  cnt                      Count of sectors.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Read sector failed.
Nextern fsStatus fs_ioc_write_sector (int32_t drv_id, uint32_t sect, const uint8_t *buf, uint32_t cnt);
N
N/// \brief Read media configuration info.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[out] info                     Media information structure.
N/// \return     execution status \ref fsStatus
N///               - fsOK               = Operation successful.
N///               - fsInvalidDrive     = Nonexistent drive id specified.
N///               - fsNoMedia          = Media not present.
N///               - fsAccessDenied     = IOC access not allowed for specified drive.
N///               - fsError            = Media information read failed.
Nextern fsStatus fs_ioc_read_info (int32_t drv_id, fsMediaInfo *info);
N
N/// \brief IOC device control access; control code is sent directly to device driver.
N/// \param[in]  drv_id                   Drive identifier obtained by \ref fs_ioc_get_id.
N/// \param[in]  code                     Device control code.
N/// \param[in,out] p                     Generic pointer.
N/// \return     execution status \ref fsStatus
Nextern fsStatus fs_ioc_device_ctrl (int32_t drv_id, fsDevCtrlCode code, void *p);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_FS_H */
L 43 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N#include "cmsis_os.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 1
N/* ----------------------------------------------------------------------
N * $Date:        5. February 2013
N * $Revision:    V1.02
N *
N * Project:      CMSIS-RTOS API
N * Title:        cmsis_os.h RTX header file
N *
N * Version 0.02
N *    Initial Proposal Phase
N * Version 0.03
N *    osKernelStart added, optional feature: main started as thread
N *    osSemaphores have standard behavior
N *    osTimerCreate does not start the timer, added osTimerStart
N *    osThreadPass is renamed to osThreadYield
N * Version 1.01
N *    Support for C++ interface
N *     - const attribute removed from the osXxxxDef_t typedef's
N *     - const attribute added to the osXxxxDef macros
N *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
N *    Added: osKernelInitialize
N * Version 1.02
N *    Control functions for short timeouts in microsecond resolution:
N *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
N *    Removed: osSignalGet 
N *----------------------------------------------------------------------------
N *
N * Copyright (c) 2013 ARM LIMITED
N * All rights reserved.
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *  - Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *  - Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *  - Neither the name of ARM  nor the names of its contributors may be used
N *    to endorse or promote products derived from this software without
N *    specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *---------------------------------------------------------------------------*/
N
N
N#ifndef _CMSIS_OS_H
N#define _CMSIS_OS_H
N
N#define osCMSIS           0x10002      ///< CMSIS-RTOS API version (main [31:16] .sub [15:0])
N
N#define osCMSIS_RTX     ((4<<16)|78)   ///< RTOS identification and version (main [31:16] .sub [15:0])
N
N#define osKernelSystemId "RTX V4.78"   ///< RTOS identification string
N
N
N#define osFeature_MainThread   1       ///< main can be thread
N#define osFeature_Pool         1       ///< Memory Pools available
N#define osFeature_MailQ        1       ///< Mail Queues available
N#define osFeature_MessageQ     1       ///< Message Queues available
N#define osFeature_Signals      16      ///< 16 Signal Flags available per thread
N#define osFeature_Semaphore    65535   ///< Maximum count for \ref osSemaphoreCreate function
N#define osFeature_Wait         0       ///< osWait not available
N#define osFeature_SysTick      1       ///< osKernelSysTick functions available
N
N#if defined (__CC_ARM)
X#if 1L
N#define os_InRegs __value_in_regs      // Compiler specific: force struct in registers
N#else
S#define os_InRegs
N#endif
N
N#include <stdint.h>
N#include <stddef.h>
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N// ==== Enumeration, structures, defines ====
N
N/// Priority used for thread control.
Ntypedef enum  {
N  osPriorityIdle          = -3,          ///< priority: idle (lowest)
N  osPriorityLow           = -2,          ///< priority: low
N  osPriorityBelowNormal   = -1,          ///< priority: below normal
N  osPriorityNormal        =  0,          ///< priority: normal (default)
N  osPriorityAboveNormal   = +1,          ///< priority: above normal
N  osPriorityHigh          = +2,          ///< priority: high
N  osPriorityRealtime      = +3,          ///< priority: realtime (highest)
N  osPriorityError         =  0x84        ///< system cannot determine priority or thread has illegal priority
N} osPriority;
N
N/// Timeout value.
N#define osWaitForever     0xFFFFFFFF     ///< wait forever timeout value
N
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum  {
N  osOK                    =     0,       ///< function completed; no error or event occurred.
N  osEventSignal           =  0x08,       ///< function completed; signal event occurred.
N  osEventMessage          =  0x10,       ///< function completed; message event occurred.
N  osEventMail             =  0x20,       ///< function completed; mail event occurred.
N  osEventTimeout          =  0x40,       ///< function completed; timeout occurred.
N  osErrorParameter        =  0x80,       ///< parameter error: a mandatory parameter was missing or specified an incorrect object.
N  osErrorResource         =  0x81,       ///< resource not available: a specified resource was not available.
N  osErrorTimeoutResource  =  0xC1,       ///< resource not available within given time: a specified resource was not available within the timeout period.
N  osErrorISR              =  0x82,       ///< not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osErrorISRRecursive     =  0x83,       ///< function called multiple times from ISR with same object.
N  osErrorPriority         =  0x84,       ///< system cannot determine priority or thread has illegal priority.
N  osErrorNoMemory         =  0x85,       ///< system is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorValue            =  0x86,       ///< value of a parameter is out of range.
N  osErrorOS               =  0xFF,       ///< unspecified RTOS error: run-time error but no other error message fits.
N  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osStatus;
N
N
N/// Timer type value for the timer definition.
Ntypedef enum  {
N  osTimerOnce             =     0,       ///< one-shot timer
N  osTimerPeriodic         =     1        ///< repeating timer
N} os_timer_type;
N
N/// Entry point of a thread.
Ntypedef void (*os_pthread) (void const *argument);
N
N/// Entry point of a timer call back function.
Ntypedef void (*os_ptimer) (void const *argument);
N
N// >>> the following data type definitions may shall adapted towards a specific RTOS
N
N/// Thread ID identifies the thread (pointer to a thread control block).
Ntypedef struct os_thread_cb *osThreadId;
N
N/// Timer ID identifies the timer (pointer to a timer control block).
Ntypedef struct os_timer_cb *osTimerId;
N
N/// Mutex ID identifies the mutex (pointer to a mutex control block).
Ntypedef struct os_mutex_cb *osMutexId;
N
N/// Semaphore ID identifies the semaphore (pointer to a semaphore control block).
Ntypedef struct os_semaphore_cb *osSemaphoreId;
N
N/// Pool ID identifies the memory pool (pointer to a memory pool control block).
Ntypedef struct os_pool_cb *osPoolId;
N
N/// Message ID identifies the message queue (pointer to a message queue control block).
Ntypedef struct os_messageQ_cb *osMessageQId;
N
N/// Mail ID identifies the mail queue (pointer to a mail queue control block).
Ntypedef struct os_mailQ_cb *osMailQId;
N
N
N/// Thread Definition structure contains startup information of a thread.
Ntypedef struct os_thread_def  {
N  os_pthread               pthread;    ///< start address of thread function
N  osPriority             tpriority;    ///< initial thread priority
N  uint32_t               instances;    ///< maximum number of instances of that thread function
N  uint32_t               stacksize;    ///< stack size requirements in bytes; 0 is default stack size
N} osThreadDef_t;
N
N/// Timer Definition structure contains timer parameters.
Ntypedef struct os_timer_def  {
N  os_ptimer                 ptimer;    ///< start address of a timer function
N  void                      *timer;    ///< pointer to internal data
N} osTimerDef_t;
N
N/// Mutex Definition structure contains setup information for a mutex.
Ntypedef struct os_mutex_def  {
N  void                      *mutex;    ///< pointer to internal data
N} osMutexDef_t;
N
N/// Semaphore Definition structure contains setup information for a semaphore.
Ntypedef struct os_semaphore_def  {
N  void                  *semaphore;    ///< pointer to internal data
N} osSemaphoreDef_t;
N
N/// Definition structure for memory block allocation.
Ntypedef struct os_pool_def  {
N  uint32_t                 pool_sz;    ///< number of items (elements) in the pool
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< pointer to memory for pool
N} osPoolDef_t;
N
N/// Definition structure for message queue.
Ntypedef struct os_messageQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  void                       *pool;    ///< memory array for messages
N} osMessageQDef_t;
N
N/// Definition structure for mail queue.
Ntypedef struct os_mailQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< memory array for mail
N} osMailQDef_t;
N
N/// Event structure contains detailed information about an event.
Ntypedef struct  {
N  osStatus                 status;     ///< status code: event or error information
N  union  {
N    uint32_t                    v;     ///< message as 32-bit value
N    void                       *p;     ///< message or mail as void pointer
N    int32_t               signals;     ///< signal flags
N  } value;                             ///< event value
N  union  {
N    osMailQId             mail_id;     ///< mail id obtained by \ref osMailCreate
N    osMessageQId       message_id;     ///< message id obtained by \ref osMessageCreate
N  } def;                               ///< event definition
N} osEvent;
N
N
N//  ==== Kernel Control Functions ====
N
N/// Initialize the RTOS Kernel for creating objects.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelInitialize (void);
N
N/// Start the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelStart (void);
N
N/// Check if the RTOS kernel is already started.
N/// \return 0 RTOS is not started, 1 RTOS is started.
Nint32_t osKernelRunning(void);
N
N#if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
X#if (1L  &&  (1 != 0))     
N
N/// \cond INTERNAL_VARIABLES
Nextern uint32_t const os_tickfreq;
Nextern uint16_t const os_tickus_i;
Nextern uint16_t const os_tickus_f;
N/// \endcond
N
N/// Get the RTOS kernel system timer counter.
N/// \return RTOS kernel system timer as 32-bit value 
Nuint32_t osKernelSysTick (void);
N
N/// The RTOS kernel system timer frequency in Hz.
N/// \note Reflects the system timer setting and is typically defined in a configuration file.
N#define osKernelSysTickFrequency os_tickfreq
N
N/// Convert a microseconds value to a RTOS kernel system timer value.
N/// \param         microsec     time value in microseconds.
N/// \return time value normalized to the \ref osKernelSysTickFrequency
N/*
N#define osKernelSysTickMicroSec(microsec) (((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)
N*/
N#define osKernelSysTickMicroSec(microsec) ((microsec * os_tickus_i) + ((microsec * os_tickus_f) >> 16))
N
N#endif    // System Timer available
N
N//  ==== Thread Management ====
N
N/// Create a Thread Definition with function, priority, and stack requirements.
N/// \param         name         name of the thread function.
N/// \param         priority     initial priority of the thread function.
N/// \param         instances    number of possible thread instances.
N/// \param         stacksz      stack size (in bytes) requirements for the thread function.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osThreadDef(name, priority, instances, stacksz)  \
Sextern const osThreadDef_t os_thread_def_##name
X#define osThreadDef(name, priority, instances, stacksz)  extern const osThreadDef_t os_thread_def_##name
N#else                            // define the object
N#define osThreadDef(name, priority, instances, stacksz)  \
Nconst osThreadDef_t os_thread_def_##name = \
N{ (name), (priority), (instances), (stacksz)  }
X#define osThreadDef(name, priority, instances, stacksz)  const osThreadDef_t os_thread_def_##name = { (name), (priority), (instances), (stacksz)  }
N#endif
N
N/// Access a Thread definition.
N/// \param         name          name of the thread definition object.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#define osThread(name)  \
N&os_thread_def_##name
X#define osThread(name)  &os_thread_def_##name
N
N/// Create a thread and add it to Active Threads and set it to state READY.
N/// \param[in]     thread_def    thread definition referenced with \ref osThread.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument);
N
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadGetId (void);
N
N/// Terminate execution of a thread and remove it from Active Threads.
N/// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadTerminate (osThreadId thread_id);
N
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadYield (void);
N
N/// Change priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadSetPriority (osThreadId thread_id, osPriority priority);
N
N/// Get current priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return current priority value of the thread function.
NosPriority osThreadGetPriority (osThreadId thread_id);
N
N
N//  ==== Generic Wait Functions ====
N
N/// Wait for Timeout (Time Delay).
N/// \param[in]     millisec      time delay value
N/// \return status code that indicates the execution status of the function.
NosStatus osDelay (uint32_t millisec);
N
N#if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available
X#if (1L  &&  (0 != 0))     
S
S/// Wait for Signal, Message, Mail, or Timeout.
S/// \param[in] millisec          timeout value or 0 in case of no time-out
S/// \return event that contains signal, message, or mail information or error code.
Sos_InRegs osEvent osWait (uint32_t millisec);
S
N#endif  // Generic Wait available
N
N
N//  ==== Timer Management Functions ====
N/// Define a Timer object.
N/// \param         name          name of the timer object.
N/// \param         function      name of the timer call back function.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osTimerDef(name, function)  \
Sextern const osTimerDef_t os_timer_def_##name
X#define osTimerDef(name, function)  extern const osTimerDef_t os_timer_def_##name
N#else                            // define the object
N#define osTimerDef(name, function)  \
Nuint32_t os_timer_cb_##name[6]; \
Nconst osTimerDef_t os_timer_def_##name = \
N{ (function), (os_timer_cb_##name) }
X#define osTimerDef(name, function)  uint32_t os_timer_cb_##name[6]; const osTimerDef_t os_timer_def_##name = { (function), (os_timer_cb_##name) }
N#endif
N
N/// Access a Timer definition.
N/// \param         name          name of the timer object.
N#define osTimer(name) \
N&os_timer_def_##name
X#define osTimer(name) &os_timer_def_##name
N
N/// Create a timer.
N/// \param[in]     timer_def     timer object referenced with \ref osTimer.
N/// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer call back function.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument);
N
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \param[in]     millisec      time delay value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStart (osTimerId timer_id, uint32_t millisec);
N
N/// Stop the timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStop (osTimerId timer_id);
N
N/// Delete a timer that was created by \ref osTimerCreate.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerDelete (osTimerId timer_id);
N
N
N//  ==== Signal Management ====
N
N/// Set the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that should be set.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
Nint32_t osSignalSet (osThreadId thread_id, int32_t signals);
N
N/// Clear the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that shall be cleared.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters or call from ISR.
Nint32_t osSignalClear (osThreadId thread_id, int32_t signals);
N
N/// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
N/// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return event flag information or error code.
Nos_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec);
X__value_in_regs osEvent osSignalWait (int32_t signals, uint32_t millisec);
N
N
N//  ==== Mutex Management ====
N
N/// Define a Mutex.
N/// \param         name          name of the mutex object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMutexDef(name)  \
Sextern const osMutexDef_t os_mutex_def_##name
X#define osMutexDef(name)  extern const osMutexDef_t os_mutex_def_##name
N#else                            // define the object
N#define osMutexDef(name)  \
Nuint32_t os_mutex_cb_##name[4] = { 0 }; \
Nconst osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
X#define osMutexDef(name)  uint32_t os_mutex_cb_##name[4] = { 0 }; const osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
N#endif
N
N/// Access a Mutex definition.
N/// \param         name          name of the mutex object.
N#define osMutex(name)  \
N&os_mutex_def_##name
X#define osMutex(name)  &os_mutex_def_##name
N
N/// Create and Initialize a Mutex object.
N/// \param[in]     mutex_def     mutex definition referenced with \ref osMutex.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId osMutexCreate (const osMutexDef_t *mutex_def);
N
N/// Wait until a Mutex becomes available.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexWait (osMutexId mutex_id, uint32_t millisec);
N
N/// Release a Mutex that was obtained by \ref osMutexWait.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexRelease (osMutexId mutex_id);
N
N/// Delete a Mutex that was created by \ref osMutexCreate.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexDelete (osMutexId mutex_id);
N
N
N//  ==== Semaphore Management Functions ====
N
N#if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))     // Semaphore available
X#if (1L  &&  (65535 != 0))     
N
N/// Define a Semaphore object.
N/// \param         name          name of the semaphore object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osSemaphoreDef(name)  \
Sextern const osSemaphoreDef_t os_semaphore_def_##name
X#define osSemaphoreDef(name)  extern const osSemaphoreDef_t os_semaphore_def_##name
N#else                            // define the object
N#define osSemaphoreDef(name)  \
Nuint32_t os_semaphore_cb_##name[2] = { 0 }; \
Nconst osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
X#define osSemaphoreDef(name)  uint32_t os_semaphore_cb_##name[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
N#endif
N
N/// Access a Semaphore definition.
N/// \param         name          name of the semaphore object.
N#define osSemaphore(name)  \
N&os_semaphore_def_##name
X#define osSemaphore(name)  &os_semaphore_def_##name
N
N/// Create and Initialize a Semaphore object used for managing resources.
N/// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore.
N/// \param[in]     count         number of available resources.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count);
N
N/// Wait until a Semaphore token becomes available.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return number of available tokens, or -1 in case of incorrect parameters.
Nint32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec);
N
N/// Release a Semaphore token.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreRelease (osSemaphoreId semaphore_id);
N
N/// Delete a Semaphore that was created by \ref osSemaphoreCreate.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreDelete (osSemaphoreId semaphore_id);
N
N#endif     // Semaphore available
N
N
N//  ==== Memory Pool Management Functions ====
N
N#if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0))  // Memory Pool Management available
X#if (1L  &&  (1 != 0))  
N
N/// \brief Define a Memory Pool.
N/// \param         name          name of the memory pool.
N/// \param         no            maximum number of blocks (objects) in the memory pool.
N/// \param         type          data type of a single block (object).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osPoolDef(name, no, type)   \
Sextern const osPoolDef_t os_pool_def_##name
X#define osPoolDef(name, no, type)   extern const osPoolDef_t os_pool_def_##name
N#else                            // define the object
N#define osPoolDef(name, no, type)   \
Nuint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; \
Nconst osPoolDef_t os_pool_def_##name = \
N{ (no), sizeof(type), (os_pool_m_##name) }
X#define osPoolDef(name, no, type)   uint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; const osPoolDef_t os_pool_def_##name = { (no), sizeof(type), (os_pool_m_##name) }
N#endif
N
N/// \brief Access a Memory Pool definition.
N/// \param         name          name of the memory pool
N#define osPool(name) \
N&os_pool_def_##name
X#define osPool(name) &os_pool_def_##name
N
N/// Create and Initialize a memory pool.
N/// \param[in]     pool_def      memory pool definition referenced with \ref osPool.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosPoolId osPoolCreate (const osPoolDef_t *pool_def);
N
N/// Allocate a memory block from a memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolAlloc (osPoolId pool_id);
N
N/// Allocate a memory block from a memory pool and set memory block to zero.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolCAlloc (osPoolId pool_id);
N
N/// Return an allocated memory block back to a specific memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \param[in]     block         address of the allocated memory block that is returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus osPoolFree (osPoolId pool_id, void *block);
N
N#endif   // Memory Pool Management available
N
N
N//  ==== Message Queue Management Functions ====
N
N#if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0))     // Message Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Message Queue Definition.
N/// \param         name          name of the queue.
N/// \param         queue_sz      maximum number of messages in the queue.
N/// \param         type          data type of a single message element (for debugger).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMessageQDef(name, queue_sz, type)   \
Sextern const osMessageQDef_t os_messageQ_def_##name
X#define osMessageQDef(name, queue_sz, type)   extern const osMessageQDef_t os_messageQ_def_##name
N#else                            // define the object
N#define osMessageQDef(name, queue_sz, type)   \
Nuint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; \
Nconst osMessageQDef_t os_messageQ_def_##name = \
N{ (queue_sz), (os_messageQ_q_##name) }
X#define osMessageQDef(name, queue_sz, type)   uint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; const osMessageQDef_t os_messageQ_def_##name = { (queue_sz), (os_messageQ_q_##name) }
N#endif
N
N/// \brief Access a Message Queue Definition.
N/// \param         name          name of the queue
N#define osMessageQ(name) \
N&os_messageQ_def_##name
X#define osMessageQ(name) &os_messageQ_def_##name
N
N/// Create and Initialize a Message Queue.
N/// \param[in]     queue_def     queue definition referenced with \ref osMessageQ.
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);
N
N/// Put a Message to a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     info          message information.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);
N
N/// Get a Message or Wait for a Message from a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out.
N/// \return event information that includes status code.
Nos_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
N
N#endif     // Message Queues available
N
N
N//  ==== Mail Queue Management Functions ====
N
N#if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))     // Mail Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Mail Queue Definition.
N/// \param         name          name of the queue
N/// \param         queue_sz      maximum number of messages in queue
N/// \param         type          data type of a single message element
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMailQDef(name, queue_sz, type) \
Sextern const osMailQDef_t os_mailQ_def_##name
X#define osMailQDef(name, queue_sz, type) extern const osMailQDef_t os_mailQ_def_##name
N#else                            // define the object
N#define osMailQDef(name, queue_sz, type) \
Nuint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; \
Nuint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; \
Nvoid *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; \
Nconst osMailQDef_t os_mailQ_def_##name =  \
N{ (queue_sz), sizeof(type), (os_mailQ_p_##name) }
X#define osMailQDef(name, queue_sz, type) uint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; uint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; void *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; const osMailQDef_t os_mailQ_def_##name =  { (queue_sz), sizeof(type), (os_mailQ_p_##name) }
N#endif
N
N/// \brief Access a Mail Queue Definition.
N/// \param         name          name of the queue
N#define osMailQ(name)  \
N&os_mailQ_def_##name
X#define osMailQ(name)  &os_mailQ_def_##name
N
N/// Create and Initialize mail queue.
N/// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return mail queue ID for reference by other functions or NULL in case of error.
NosMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id);
N
N/// Allocate a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Allocate a memory block from a mail and set memory block to zero.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailCAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Put a mail to a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailPut (osMailQId queue_id, void *mail);
N
N/// Get a mail from a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      timeout value or 0 in case of no time-out
N/// \return event that contains mail information or error code.
Nos_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
N
N/// Free a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailFree (osMailQId queue_id, void *mail);
N
N#endif  // Mail Queues available
N
N
N//  ==== RTX Extensions ====
N
N/// Suspend the RTX task scheduler.
N/// \return number of ticks, for how long the system can sleep or power-down.
Nuint32_t os_suspend (void);
N
N/// Resume the RTX task scheduler
N/// \param[in]     sleep_time    specifies how long the system was in sleep or power-down mode.
Nvoid os_resume (uint32_t sleep_time);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif  // _CMSIS_OS_H
L 44 "C:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include\rl_fs_lib.h" 2
N
N
N/* Device System Type attribute */
N#define FS_CUR                   0x01   /* Initial Current Drive attribute    */
N#define FS_EMB                   0x02   /* Embedded File System (F:)          */
N#define FS_FAT                   0x04   /* FAT File System      (M:,N:,R:,U:) */
N#define FS_IOC                   0x08   /* IO Control allowed   (M:,N:)       */
N
N/* Driver Init/Uninit Parameter Codes */
N#define DM_IO                       0   /* Init/Uninit IO peripherals         */
N#define DM_MEDIA                    1   /* Init/Uninit storage Media          */
N
N/* NAND Configuration macros */
N#define NAND_ROW_CYCLES(b,p)  ((b*p > 65536) ? 3 : 2)
N#define NAND_COL_CYCLES(s)    ((s   >   528) ? 2 : 1)
N#define NAND_BTT_SIZE(b)      ((b*3)/100)
N#define NAND_SEC_PAGE(p)      (p/512)
N#define NAND_SEC_BLOCK(b,p)   ((p/512)*b)
N#define _DS_(b)               (b-(b*3)/100-1)
N#define _EP_(p)               ((p/512)*128)
N#define NAND_TSN_SIZE(b,p)    ((_DS_(b)+_EP_(p)-1)/_EP_(p))
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/* Device driver mapping type */
Ntypedef struct {
N  void   *dcb;                          /* Device Control block               */
N  char    id[3];                        /* Drive Name Identification          */
N  uint8_t attr;                         /* File System attributes             */
N} const FS_DEV;
N
N/* RAM interface control block */
Ntypedef struct {
N  uint8_t *Base;                        /* RAM buffer base address            */
N  uint32_t Size;                        /* RAM buffer size                    */
N} RAM_DEV;
N
N/* Memory Card Device Control block (MCI) */
Ntypedef struct {
N  ARM_DRIVER_MCI       *Driver;         /* Registered MCI driver              */
N  ARM_MCI_SignalEvent_t Callback;       /* Driver Callback                    */
N  ARM_MCI_CAPABILITIES  Capabilities;   /* Driver Capabilities                */
N  uint8_t              *ExtCSD;         /* Pointer to 512 byte buffer         */
N  uint32_t              Property;       /* Card Properties                    */
N  uint32_t              SerialNumber;   /* Memory card serial number          */
N  uint32_t              SectorCount;    /* Device density in 512B sectors     */
N  uint16_t volatile     Event;          /* Driver event flags                 */
N  uint8_t  volatile     MediaStatus;    /* Media status                       */
N  uint8_t               Status;         /* Device status                      */
N  uint16_t              RCA;            /* Relative Card Address              */
N  uint8_t               Instance;       /* Memory Card Instance number        */
N} MC_MCI;
N
N/* Memory Card Device Control block (SPI) */
Ntypedef struct {
N  ARM_DRIVER_SPI       *Driver;         /* Registered SPI driver              */
N  ARM_SPI_SignalEvent_t Callback;       /* Driver Callback                    */
N  uint8_t              *ExtCSD;         /* Pointer to 512 byte buffer         */
N  uint32_t              Property;       /* Card Properties                    */
N  uint32_t              SerialNumber;   /* Memory card serial number          */
N  uint32_t              SectorCount;    /* Device density in 512B sectors     */
N  uint8_t volatile      Event;          /* Driver event flags                 */
N  uint8_t volatile      MediaStatus;    /* Media status                       */
N  uint8_t               Status;         /* Device status                      */
N  uint16_t              RCA;            /* Relative Card Address              */
N  uint8_t               Instance;       /* Memory Card Instance number        */
N} MC_SPI;
N
N/* NAND Page Layout configuration */
Ntypedef struct _NAND_PAGE_LAYOUT {
N  struct {
N    uint8_t  ofs_lsn;                   /* LSN position, where logical sector number (LSN) is placed. Usually, this is the first byte of Spare and has the value 0. LSN is a 32-bit value. */
N    uint8_t  ofs_dcm;                   /* Page Data corrupted marker. Usually, this byte is the 5-th byte of Spare and has the value 4. */
N    uint8_t  ofs_bbm;                   /* Bad Block marker position. Is usually placed as the 6-th byte of Spare and has the value 5. */
N    uint8_t  ofs_ecc;                   /* Position of the first byte of Error Correction Code (ECC). Is usually the 7-th byte of Spare and has the value 6. This value is used by flash translation layer only if ECC is encoded and decoded in software. */
N  } spare;                              /* Structure spare */
N  uint16_t spare_ofs;                   /* Spare area offset from beginning of the page. */
N  uint16_t spare_inc;                   /* Column increment till next spare. If page contains multiple sectors, then the first byte of the first spare area is determined by reading spare_ofs value. Location of the first byte of the second spare is (spare_inc + spare_ofs). */
N  uint16_t sector_inc;                  /* Column increment till next sector. If page contains multiple sectors, then the first sector always starts at the beginning of the page (byte zero). Second sector starts at sect_inc, third sector at (sect_inc + sect_inc) and so on. */
N} NAND_PAGE_LAYOUT;
N
N/* NAND Flash Device information */
Ntypedef struct _NAND_DEVICE {
N  NAND_PAGE_LAYOUT *page_layout;        /* Page Layout configuration          */
N  uint8_t           bus_width;          /* Device bus width (0=8bit, 1=16bit  */
N  uint8_t           device_number;      /* Device number (chip select)        */
N  uint16_t          page_size;          /* Page Size in bytes                 */
N  uint32_t          block_count;        /* Number of Blocks in Device         */
N  uint16_t          page_count;         /* Number of Pages per Block          */
N  uint16_t          block_sectors;      /* Number of Sectors per Block        */
N  uint8_t           page_sectors;       /* Number of Sectors per Page         */
N  uint8_t           row_cycles;         /* Number of Row address cycles       */
N  uint8_t           col_cycles;         /* Number of Column address cycles    */
N  uint8_t           sw_ecc;             /* value > 0: error correction code (ECC) encoding/decoding enabled in software: \n value = 0: Software ECC disabled \n value = 1: Hamming ECC algorithm enabled in software. */
N} NAND_DEVICE;
N
N/* NAND Driver Info */
Ntypedef struct _NAND_DRIVER_INFO {
N  ARM_NAND_SignalEvent_t hw_cb;         /* Hardware event handler (callback)  */
X  uint32_t hw_cb;          
N  ARM_DRIVER_NAND       *drv;           /* NAND driver                        */
X  uint32_t       *drv;            
N  ARM_NAND_CAPABILITIES  capabilities;  /* NAND driver capabilities           */
X  uint32_t  capabilities;   
N  uint8_t                init;          /* Initialization counter             */
N} NAND_HW_DRIVER;
N
N/* Signal NAND Media Driver event */
Ntypedef void (*NAND_Media_SignalEvent_t) (uint32_t dev_num, uint32_t event);
N
N/* NAND Media Driver Instance */
Ntypedef struct _NFTL_DRIVER_HANDLE {
N  NAND_Media_SignalEvent_t media_cb;    /* NAND Media event handler (callback)*/
N  NAND_HW_DRIVER          *hw;          /* Hardware driver handle             */
N  NAND_DEVICE const       *dev;         /* NAND Device description            */
N  uint16_t                 ecc;         /* ECC algorithm index and ECC flags  */
N  uint8_t volatile         event;       /* Event flags                        */
N  uint8_t                  status;      /* Device status byte                 */
N  uint32_t                 seq;         /* Sequence number                    */
N} NAND_MEDIA_HANDLE;
N
N/* NAND Media Interface Driver */
Ntypedef struct _NAND_MEDIA_DRIVER {
N  int32_t (*Initialize)     (NAND_MEDIA_HANDLE *h);
N  int32_t (*Uninitialize)   (NAND_MEDIA_HANDLE *h);
N  int32_t (*ResetDevice)    (NAND_MEDIA_HANDLE *h);
N  int32_t (*ReadID)         (NAND_MEDIA_HANDLE *h, uint8_t addr, uint8_t *buf, uint32_t len);
N  int32_t (*ReadParamPage)  (NAND_MEDIA_HANDLE *h, uint32_t col, uint8_t *buf, uint32_t len);
N  int32_t (*ReadPage)       (NAND_MEDIA_HANDLE *h, uint32_t row, uint32_t col, uint8_t *buf, uint32_t len);
N  int32_t (*WritePage)      (NAND_MEDIA_HANDLE *h, uint32_t row, uint32_t col, const uint8_t *buf, uint32_t len);
N  int32_t (*CopyPage)       (NAND_MEDIA_HANDLE *h, uint32_t row_src, uint32_t row_dst, uint32_t row_cnt);
N  int32_t (*EraseBlock)     (NAND_MEDIA_HANDLE *h, uint32_t row);
N  int32_t (*ReadStatus)     (NAND_MEDIA_HANDLE *h, uint8_t *stat);
N} const NAND_MEDIA_DRIVER;
N
N/* NAND FTL Block Index Cache */
Ntypedef struct {
N  uint16_t pbn;                         /* Physical block number              */
N  uint16_t lbn;                         /* Logical block number               */
N  uint8_t  typ;                         /* Type of block in cache             */
N  uint8_t  nextPg;                      /* Next page to be indexed            */
N  uint8_t  *pgIdx;                      /* Index buffer                       */
N} BLOCK_CACHE;
N
N/* NAND FTL Page Cache */
Ntypedef struct {
N  uint32_t row;                         /* Row address of the page in cache   */
N  uint8_t *buf;                         /* Cached page buffer                 */
N} PAGE_CACHE;
N
N/* NAND FTL Buffer Pointers Structure */
Ntypedef struct {
N  uint32_t CacheBS;                     /* Block slot for block caching       */
N  uint32_t CachePS;                     /* Page slot for page caching         */
N  uint16_t CachedBlocks;                /* Number of indexed blocks           */
N  uint16_t CachedPages;                 /* Number of cached pages             */
N  BLOCK_CACHE *Block;                   /* Block indexing cache info struct   */
N  PAGE_CACHE  *Page;                    /* Page data cache info structure     */
N} NAND_FTL_CACHE;
N
N/* NAND FTL Configuration structure */
Ntypedef struct {
N  /* Block Translation Table Space */
N  uint16_t BttStartBn;                  /* First Physical Block               */
N  uint16_t BttEndBn;                    /* Last Physical Block                */
N  /* Data Space */
N  uint16_t DataStartBn;                 /* First Physical Block               */
N  uint16_t DataEndBn;                   /* Last Physical Block                */
N  /* Buffer Sizes */  
N  uint16_t NumCacheBlocks;              /* Number of indexed data blocks      */
N  uint16_t NumCachePages;               /* Number of cached data pages        */
N  uint16_t TsnTableSize;                /* Translation table cache size       */
N  /* Page buffer & Caches */
N  uint8_t     *PgBuf;                   /* Page data buffer                   */
N  BLOCK_CACHE *BlockCache;              /* Block indexing cache info struct   */
N  uint8_t     *BlockCacheBuf;           /* Block indexing cache buffer        */
N  PAGE_CACHE  *PageCache;               /* Page data cache info structure     */
N  uint8_t     *PageCacheBuf;            /* Page data cache buffer             */
N  uint32_t    *TsnTable;                /* Translation table cache buffer     */
N} const NAND_FTL_CFG;
N
N/* NAND Device Control block */
Ntypedef struct {
N  NAND_MEDIA_HANDLE *Media;             /* NAND Media Driver Instance         */
N  NAND_FTL_CFG      *Cfg;               /* NAND FTL configuration structure   */
N  NAND_PAGE_LAYOUT   PgLay;             /* Page layout definition             */
N
N  uint8_t   PageSectors;                /* Number of sectors/page 1,4,8, ...  */
N  uint8_t   SPP;                        /* Number of sectors/page             */
N                                        /*  (2^n, n = SPP)                    */
N  uint8_t   PPB;                        /* Number of pages/block              */
N                                        /*  (2^n, n = PPB)                    */
N  uint8_t   SPB;                        /* Number of sectors/block            */
N                                        /*  (2^n, n = SPB)                    */
N  uint8_t   EPS;                        /* Entries/table sector               */
N                                        /*  (2^n, n = EPS)                    */
N  uint8_t   LastECC;                    /* ECC status after last page read    */
N  uint16_t  LastDBN;                    /* Last allocated phy. block          */
N                                        /*  in data area                      */
N  uint16_t  LastTBN;                    /* Last allocated phy. block          */
N                                        /*  in table area                     */
N  uint32_t  CurrLBN;                    /* Current logical block number       */
N  uint32_t  GcLBN;                      /* Current logical block number used  */
N                                        /*  by forced GC                      */
N  uint16_t  PbnQ[3];                    /* Empty block queue                  */
N  uint16_t  BadBlockCnt;                /* Bad Block Counter                  */
N  uint16_t  NumDataBlocks;              /* Number of data blocks reported to  */
N                                        /*  file system                       */
N  uint8_t   Status;                     /* FTL Status Flags                   */
N  volatile
N  uint8_t   Timeout;                    /* Timeout status                     */
N  uint8_t  *PgBuf;                      /* Page data buffer                   */
N  uint32_t *TsnTable;                   /* Translation table cache buffer     */
N  uint16_t  TsnTableSize;               /* Translation table cache size       */
N  NAND_FTL_CACHE Ca;                    /* FTL cache info structure           */
N} NAND_FTL_DEV;
N
N/* FAT Name Cache Configuration */
Ntypedef struct fat_nca_cfg {
N  uint8_t   MaxPathDepth;               /* Maximum path depth                 */
N  uint8_t   ControlBlockCnt;            /* Number of control blocks           */
N  uint32_t  NameMemPoolSize;            /* Name cache memory pool size        */
N  uint32_t *NameMemPool;                /* Name cache memory pool             */
N} const FAT_NCACHE_CFG;
N
N/* FAT Sector Caching structure */
Ntypedef struct fcache {
N  uint32_t sect;                        /* Cached FAT sector number           */
N  uint8_t  *buf;                        /* FAT sector cache buffer            */
N  uint8_t  dirty;                       /* FAT table content modified         */
N  uint8_t  cfat;                        /* Current FAT                        */
N} FCACHE;
N
N/* Data Sector Caching structure */
Ntypedef struct dcache {
N  uint32_t sect;                        /* Working Data sector number         */
N  uint32_t csect;                       /* Data Cache starting sector number  */
N  uint8_t  *buf;                        /* Working Data sector buffer         */
N  uint8_t  *cbuf;                       /* Data Cache sector buffer           */
N  uint8_t  nwr;                         /* Number of buffered write sectors   */
N  uint8_t  nrd;                         /* Number of cached read sectors      */
N} DCACHE;
N
N/* Name Caching structure */
Ntypedef struct _NCACHE {
N  uint8_t   max_path_depth;             /* Maximum path depth                 */
N  uint32_t  size;                       /* Name cache memory pool size        */
N  uint32_t *buf;                        /* Name cache memory pool             */
N} NCACHE;
N
N/* FAT Volume Information struct */
Ntypedef struct fatinfo {
N  uint32_t BootSector;                  /* Boot Sector Offset                 */
N  uint8_t  FatType;                     /* File System Fat type.              */
N  uint8_t  NumOfFat;                    /* Number of Fat tables               */
N  uint8_t  SecPerClus;                  /* Number of Sectors per Cluster      */
N  uint16_t FatSize;                     /* Number of Sectors per FAT table    */
N  uint16_t RsvdSecCnt;                  /* Number of Reserved Sectors         */
N  uint32_t DskSize;                     /* Disk Size Sector Count             */
N  uint32_t DataSecCnt;                  /* Number of Data Sectors             */
N  uint16_t RootEntCnt;                  /* Maximum Root Directory entries     */
N  uint16_t BytesPerSec;                 /* Sector Size in bytes               */
N  uint32_t DataClusCnt;                 /* Data Cluster Count                 */
N  uint32_t RootDirAddr;                 /* Root Dir First Sector              */
N  uint16_t RootSecCnt;                  /* Number of Sectors for Root dir     */
N  uint32_t ClusSize;                    /* Cluster Size in bytes              */
N  uint16_t EntsPerClus;                 /* Number of entries per cluster      */
N                                        /* Added fields for FAT32             */
N  uint16_t FAT32_ExtFlags;              /* FAT extended flags                 */
N  uint32_t FAT32_RootClus;              /* Root directory first cluster       */
N  uint16_t FAT32_FSInfo;                /* FSInfo structure sector number     */
N  uint16_t FAT32_BkBootSec;             /* Boot Record copy sector number     */
N} FATINFO;
N
N/* FAT File System driver */
Ntypedef struct {
N  uint32_t (*Init)        (uint32_t mode);
N  uint32_t (*UnInit)      (uint32_t mode);
N  uint32_t (*ReadSect)    (uint32_t sect, uint8_t *buf, uint32_t cnt);
N  uint32_t (*WriteSect)   (uint32_t sect, uint8_t *buf, uint32_t cnt);
N  uint32_t (*ReadInfo)    (fsMediaInfo *cfg);
N  fsStatus (*DeviceCtrl)  (fsDevCtrlCode code, void *p);
N} const FAT_DRV;
N
N/* File System Journal Control block */
Ntypedef struct fsjour {
N  FAT_DRV *drv;                         /* Memory device driver               */
N  uint8_t *buf;                         /* Journal buffer                     */
N  uint32_t FirstSect;                   /* First sector of journal            */
N  uint32_t JournSect;                   /* Number of sectors available        */
N  uint32_t TrId;                        /* Transaction identifier             */
N  uint32_t TrSect;                      /* Transaction sector                 */
N  uint8_t  State;                       /* Journal state                      */
N  uint8_t  Status;                      /* Journal status                     */
N} FSJOUR;
N
N/* FAT Volume Description */
Ntypedef struct _fsFAT_Volume {
N  FAT_DRV  *Drv;                        /* Registered FAT Device Driver       */
N  uint32_t  Status;                     /* Volume Status                      */
N  uint32_t *CaBuf;                      /* Cache Buffer (FAT + Data)          */
N  uint32_t  CaSize;                     /* Cache Buffer size                  */
N  uint16_t  RsvdS;                      /* Reserved sectors used by journal   */
N  FSJOUR   *fsj;                        /* File System Journal                */
N  FATINFO   cfg;                        /* FAT Volume configuration           */
N  FCACHE    fat;                        /* FAT table cache control            */
N  DCACHE    ca;                         /* Data cache control                 */
N  uint32_t  free_clus_cnt;              /* FAT32: Number of free clusters     */
N  uint32_t  free_clus;                  /* FAT32: First free cluster          */
N  uint32_t  cdir_clus;                  /* Current directory cluster          */
N  NCACHE   *ncache;                     /* Name cache memory                  */
N} fsFAT_Volume;
N
N/* FAT File Handle Description */
Ntypedef struct _fsFAT_Handle {
N  fsFAT_Volume *vol;                    /* FAT volume pointer                 */
N  uint16_t  flags;                      /* File status flags                  */
N  uint32_t  fsize;                      /* File size                          */
N  uint32_t  fcsz;                       /* Current file size                  */
N  uint32_t  fpos;                       /* File position pointer              */
N
N  uint32_t  short_ent_clus;             /* SFN: Short entry cluster number    */
N  uint16_t  short_ent_offs;             /* SFN: Short entry sector offset     */
N
N  uint32_t  first_clus;                 /* First data cluster                 */
N  uint32_t  current_clus;               /* Current data cluster               */
N  uint8_t   current_sect;               /* Current data sector                */
N} fsFAT_Handle;
N
N/* EFS Volume Description */
Ntypedef struct _fsEFS_Volume {
N  ARM_DRIVER_FLASH       *Drv;          /* Registered Device Driver           */
X  uint32_t       *Drv;           
N  ARM_FLASH_SECTOR       *DevSect;      /* Flash Sectors Array                */
X  uint32_t       *DevSect;       
N  ARM_FLASH_CAPABILITIES  Capab;        /* Flash driver capabilities          */
X  uint32_t  Capab;         
N  ARM_Flash_SignalEvent_t Callback;     /* Flash driver callback              */
X  uint32_t Callback;      
N  uint32_t volatile       Event;        /* Flash driver events                */
N  uint32_t                Status;       /* Volume Status                      */
N  uint32_t                InitVal;      /* Value for empty flash              */
N  uint32_t                NumSect;      /* Number of Flash Sectors            */
N  uint32_t                Size;         /* Device Size                        */
N  uint16_t                TopID;        /* Top used FileID                    */
N} fsEFS_Volume;
N
N/* EFS File Handle Description */
Ntypedef struct _fsEFS_Handle {
N  fsEFS_Volume *vi;                     /* Volume Information                 */
N  uint16_t  flags;                      /* File status flags                  */
N  uint32_t  fsize;                      /* File Size                          */
N  uint32_t  fpos;                       /* File Position Indicator            */
N
N  uint16_t  fileID;                     /* File Identification Number         */
N  uint16_t  fblock;                     /* Current Flash Block index          */
N  uint16_t  fidx;                       /* Current File Block index           */
N  uint16_t  nfidx;                      /* Next File Block index              */
N  uint32_t  fbot;                       /* Flash Block free space bottom      */
N  uint32_t  ftop;                       /* Flash Block free space top         */
N} fsEFS_Handle;
N
N/* File System Configuration function */
Nextern void     fs_config          (const char *drive);
N
N/* RAM drive interface functions */
Nextern uint32_t ram_Init           (uint32_t mode, RAM_DEV *ram);
Nextern uint32_t ram_UnInit         (uint32_t mode, RAM_DEV *ram);
Nextern uint32_t ram_ReadSector     (uint32_t sect, uint8_t *buf, uint32_t cnt, RAM_DEV *ram);
Nextern uint32_t ram_WriteSector    (uint32_t sect, uint8_t *buf, uint32_t cnt, RAM_DEV *ram);
Nextern uint32_t ram_ReadInfo       (fsMediaInfo *info, RAM_DEV *ram);
Nextern fsStatus ram_DevCtrl        (fsDevCtrlCode code, void *p, RAM_DEV *ram);
N
N/* Memory Card SPI mode interface functions */
Nextern uint32_t mc_spi_Init        (uint32_t mode, MC_SPI *mc);
Nextern uint32_t mc_spi_UnInit      (uint32_t mode, MC_SPI *mc);
Nextern uint32_t mc_spi_ReadSector  (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_SPI *mc);
Nextern uint32_t mc_spi_WriteSector (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_SPI *mc);
Nextern uint32_t mc_spi_ReadInfo    (fsMediaInfo *info, MC_SPI *mc);
Nextern fsStatus mc_spi_DevCtrl     (fsDevCtrlCode code, void *p, MC_SPI *mc);
Nextern void     mc_spi_DrvEvent    (uint32_t event, MC_SPI *mc);
N
N/* Memory Card Native mode interface functions */
Nextern uint32_t mc_mci_Init        (uint32_t mode, MC_MCI *mc);
Nextern uint32_t mc_mci_UnInit      (uint32_t mode, MC_MCI *mc);
Nextern uint32_t mc_mci_ReadSector  (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_MCI *mc);
Nextern uint32_t mc_mci_WriteSector (uint32_t sect, uint8_t *buf, uint32_t cnt, MC_MCI *mc);
Nextern uint32_t mc_mci_ReadInfo    (fsMediaInfo *info, MC_MCI *mc);
Nextern fsStatus mc_mci_DevCtrl     (fsDevCtrlCode code, void *p, MC_MCI *mc);
Nextern void     mc_mci_DrvEvent    (uint32_t event, MC_MCI *mc);
N
N/* NAND Flash Translation Layer interface functions */
Nextern uint32_t ftl_Init           (uint32_t mode, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_UnInit         (uint32_t mode, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_ReadSect       (uint32_t lsn, uint8_t *buf, uint32_t cnt, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_WriteSect      (uint32_t lsn, uint8_t *buf, uint32_t cnt, NAND_FTL_DEV *ftl);
Nextern uint32_t ftl_ReadInfo       (fsMediaInfo *info, NAND_FTL_DEV *ftl);
Nextern fsStatus ftl_DevCtrl        (fsDevCtrlCode code, void *p, NAND_FTL_DEV *ftl);
Nextern void     ftl_DrvEvent       (NAND_FTL_DEV *ftl);
N
N/* USB Mass Storage interface functions */
Nextern bool     FS_USBH_MSC_Initialize  (uint8_t instance, uint32_t mode);
Xextern _Bool     FS_USBH_MSC_Initialize  (uint8_t instance, uint32_t mode);
Nextern bool     FS_USBH_MSC_Uninitialize(uint8_t instance, uint32_t mode);
Xextern _Bool     FS_USBH_MSC_Uninitialize(uint8_t instance, uint32_t mode);
Nextern bool     FS_USBH_MSC_ReadSectors (uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Xextern _Bool     FS_USBH_MSC_ReadSectors (uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Nextern bool     FS_USBH_MSC_WriteSectors(uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Xextern _Bool     FS_USBH_MSC_WriteSectors(uint8_t instance, uint32_t sector_addr, uint32_t sector_num, uint8_t *buf);
Nextern bool     FS_USBH_MSC_ReadInfo    (uint8_t instance, fsMediaInfo *info);
Xextern _Bool     FS_USBH_MSC_ReadInfo    (uint8_t instance, fsMediaInfo *info);
Nextern fsStatus FS_USBH_MSC_DeviceCtrl  (uint8_t instance, fsDevCtrlCode code, void *p);
N
N/* File System Journal interface functions */
Nextern uint32_t fsj_init      (FSJOUR *fsj, FAT_DRV *drv);
Nextern uint32_t fsj_set_space (FSJOUR *fsj, uint32_t start_sect, uint32_t cnt);
Nextern uint32_t fsj_write     (FSJOUR *fsj, uint32_t sect, uint32_t rsec, uint8_t *buf);
N
N/* Embedded File System interface functions */
Nextern fsStatus efs_init      (fsEFS_Volume *vol);
Nextern fsStatus efs_uninit    (fsEFS_Volume *vol);
Nextern fsStatus efs_mount     (fsEFS_Volume *vol);
Nextern fsStatus efs_unmount   (fsEFS_Volume *vol);
Nextern fsStatus efs_open      (int32_t handle, const char *fn, int openmode);
Nextern fsStatus efs_close     (int32_t handle);
Nextern int32_t  efs_read      (int32_t handle, uint8_t *buf, uint32_t len);
Nextern int32_t  efs_write     (int32_t handle, const uint8_t *buf, uint32_t len);
Nextern fsStatus efs_flush     (int32_t handle);
Nextern int32_t  efs_flen      (int32_t handle);
Nextern fsStatus efs_seek      (int32_t handle, uint32_t pos);
N
N/* EFS Auxiliary */
Nextern fsStatus efs_create    (int32_t handle, const char *name);
Nextern fsStatus efs_find      (int32_t handle, const char *name);
N
N/* EFS Maintenance Routines */
Nextern fsStatus efs_delete    (int32_t handle);
Nextern fsStatus efs_ffind     (int32_t handle, fsFileInfo *info);
Nextern fsStatus efs_rename    (int32_t handle, const char *filename);
N
N/* EFS Utility Routines */
Nextern uint32_t efs_free      (fsEFS_Volume *vi);
Nextern fsStatus efs_format    (fsEFS_Volume *vi);
Nextern int32_t  efs_analyse   (fsEFS_Volume *vi);
Nextern fsStatus efs_check     (fsEFS_Volume *vi);
Nextern fsStatus efs_defrag    (fsEFS_Volume *vi);
N
N/* EFS Event Callback handler for driver events */
Nextern void     efs_DrvEvent  (uint32_t event, fsEFS_Volume *vol);
N
N/* FAT File System interface functions */
Nextern fsStatus fat_init      (fsFAT_Volume *vol);
Nextern fsStatus fat_uninit    (fsFAT_Volume *vol);
Nextern fsStatus fat_mount     (fsFAT_Volume *vol);
Nextern fsStatus fat_unmount   (fsFAT_Volume *vol);
Nextern fsStatus fat_open      (int32_t handle, const char *name, int openmode);
Nextern fsStatus fat_close     (int32_t handle);
Nextern int32_t  fat_read      (int32_t handle, uint8_t *buf, uint32_t len);
Nextern int32_t  fat_write     (int32_t handle, const uint8_t *buf, uint32_t len);
Nextern int32_t  fat_flush     (int32_t handle);
Nextern int32_t  fat_flen      (int32_t handle);
Nextern fsStatus fat_seek      (int32_t handle, uint32_t pos);
N
N/* FAT File Maintenance Routines */
Nextern fsStatus fat_delete_l  (const char *fn, fsFAT_Volume *vol);
Nextern fsStatus fat_delete    (const char *fn, const char *options, fsFAT_Volume *vol);
Nextern fsStatus fat_ffind     (const char *fn, fsFileInfo *info, fsFAT_Volume *vol);
Nextern fsStatus fat_rename    (const char *path, const char *newname, fsFAT_Volume *vol);
N
N/* FAT Directory Support Routines */
Nextern fsStatus fat_mkdir     (const char *path, fsFAT_Volume *vol);
Nextern fsStatus fat_rmdir     (const char *path, const char *options, fsFAT_Volume *vol);
Nextern fsStatus fat_chdir     (const char *path, fsFAT_Volume *vol);
Nextern fsStatus fat_pwd       (      char *path, uint32_t len, fsFAT_Volume *vol);
N
N/* FAT Utility Routines */
Nextern uint64_t fat_free      (fsFAT_Volume *vol);
Nextern fsStatus fat_format    (fsFAT_Volume *vol, const char *param);
N
N/* FAT Journal System Routines */
Nextern uint32_t fat_jour_init (fsFAT_Volume *vol);
Nextern uint32_t fat_jour_prep (fsFAT_Volume *vol);
N
N/* FileSystem Retarget Routines */
Nextern int      __sys_open    (const char *fname, int openmode);
Nextern int      __sys_close   (int handle);
Nextern int      __sys_read    (int handle, uint8_t *buf, uint32_t len);
Nextern int      __sys_write   (int handle, const uint8_t *buf, uint32_t len);
Nextern int      __sys_ensure  (int handle);
Nextern int      __sys_seek    (int handle, uint32_t pos);
Nextern long     __sys_flen    (int handle);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_FS_LIB_H */
L 45 "C:\Keil_v5\ARM\PACK\Keil\ARM_Compiler\1.0.0\Source\retarget_io.c" 2
N#endif
N 
N 
N#ifndef STDIN_ECHO
N#define STDIN_ECHO      0       /* STDIN: echo to STDOUT */
N#endif
N#ifndef STDOUT_CR_LF
N#define STDOUT_CR_LF    0       /* STDOUT: add CR for LF */
N#endif
N#ifndef STDERR_CR_LF
N#define STDERR_CR_LF    0       /* STDERR: add CR for LF */
N#endif
N 
N 
N#if (defined(RTE_Compiler_IO_TTY_ITM)    || \
N     defined(RTE_Compiler_IO_STDIN_ITM)  || \
N     defined(RTE_Compiler_IO_STDOUT_ITM) || \
N     defined(RTE_Compiler_IO_STDERR_ITM))
X#if (0L    ||      0L  ||      0L ||      0L)
S 
S/* ITM registers */
S#define ITM_PORT0_U8          (*((volatile uint8_t  *)0xE0000000))
S#define ITM_PORT0_U32         (*((volatile uint32_t *)0xE0000000))
S#define ITM_TER               (*((volatile uint32_t *)0xE0000E00))
S#define ITM_TCR               (*((volatile uint32_t *)0xE0000E80))
S 
S#define ITM_TCR_ITMENA_Msk    (1UL << 0)
S 
S/*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S#define ITM_RXBUFFER_EMPTY    0x5AA55AA5
S 
S/*!< Variable to receive characters. */
Svolatile int32_t ITM_RxBuffer = ITM_RXBUFFER_EMPTY;   
S 
S/** \brief  ITM Send Character
S 
S    The function transmits a character via the ITM channel 0, and
S    \li Just returns when no debugger is connected that has booked the output.
S    \li Is blocking when a debugger is connected, but the previous character
S        sent has not been transmitted.
S 
S    \param [in]     ch  Character to transmit.
S 
S    \returns            Character to transmit.
S */
Suint32_t ITM_SendChar (uint32_t ch) {
S  if ((ITM_TCR & ITM_TCR_ITMENA_Msk) && /* ITM enabled */
S      (ITM_TER & (1UL << 0)        )) { /* ITM Port #0 enabled */
S    while (ITM_PORT0_U32 == 0);
S    ITM_PORT0_U8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S 
S/** \brief  ITM Receive Character
S 
S    The function inputs a character via the external variable \ref ITM_RxBuffer.
S    This variable is monitored and altered by the debugger to provide input.
S 
S    \return             Received character.
S    \return         -1  No character pending.
S */
Sint32_t ITM_ReceiveChar (void) {
S  int32_t ch = -1;                      /* no character available */
S 
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;  /* ready for next character */
S  }
S 
S  return (ch);
S}
S 
N#endif  /* RTE_Compiler_IO_STDxxx_ITM */
N 
N 
N/**
N  Get a character from the stdio
N 
N  \return     The next character from the input, or -1 on read error.
N*/
N#if   defined(RTE_Compiler_IO_STDIN)
X#if   0L
S#if   defined(RTE_Compiler_IO_STDIN_User)
Sextern int stdin_getchar (void);
S#elif defined(RTE_Compiler_IO_STDIN_ITM)
Sstatic int stdin_getchar (void) {
S  int32_t ch;
S 
S  do {
S    ch = ITM_ReceiveChar();
S  } while (ch == -1);
S  return (ch);
S}
S#elif defined(RTE_Compiler_IO_STDIN_BKPT)
Sstatic int stdin_getchar (void) {
S  int32_t ch = -1;
S 
S  __breakpoint(0);
S  return (ch);
S}
S#endif
N#endif
N 
N 
N/**
N  Put a character to the stdout
N 
N  \param[in]   ch  Character to output
N  \return          The character written, or -1 on write error.
N*/
N#if   defined(RTE_Compiler_IO_STDOUT)
X#if   0L
S#if   defined(RTE_Compiler_IO_STDOUT_User)
Sextern int stdout_putchar (int ch);
S#elif defined(RTE_Compiler_IO_STDOUT_ITM)
Sstatic int stdout_putchar (int ch) {
S  return (ITM_SendChar(ch));
S}
S#elif defined(RTE_Compiler_IO_STDOUT_BKPT)
Sstatic int stdout_putchar (int ch) {
S  __breakpoint(0);
S  return (ch);
S}
S#endif
N#endif
N 
N 
N/**
N  Put a character to the stderr
N 
N  \param[in]   ch  Character to output
N  \return          The character written, or -1 on write error.
N*/
N#if   defined(RTE_Compiler_IO_STDERR)
X#if   0L
S#if   defined(RTE_Compiler_IO_STDERR_User)
Sextern int stderr_putchar (int ch);
S#elif defined(RTE_Compiler_IO_STDERR_ITM)
Sstatic int stderr_putchar (int ch) {
S  return (ITM_SendChar(ch));
S}
S#elif defined(RTE_Compiler_IO_STDERR_BKPT)
Sstatic int stderr_putchar (int ch) {
S  __breakpoint(0);
S  return (ch);
S}
S#endif
N#endif
N 
N 
N#ifdef __MICROLIB
S 
S 
S#ifdef RTE_Compiler_IO_STDIN
Sstatic int getchar_undo =  0;
Sstatic int getchar_ch   = -1;
S#endif
S 
S 
S/**
S   Writes the character specified by c (converted to an unsigned char) to
S   the output stream pointed to by stream, at the position indicated by the
S   asociated file position indicator (if defined), and advances the
S   indicator appropriately. If the file position indicator is not defined,
S   the character is appended to the output stream.
S 
S  \param[in] c       Character
S  \param[in] stream  Stream handle
S 
S  \return    The character written. If a write error occurs, the error
S             indicator is set and fputc returns EOF.
S*/
S__weak int fputc (int c, FILE * stream) {
S 
S#ifdef RTE_Compiler_IO_STDOUT
S  if (stream == &__stdout) {
S#if (STDOUT_CR_LF != 0)
S    if (c == '\n') stdout_putchar('\r');
S#endif
S    return (stdout_putchar(c));
S  }
S#endif
S 
S#ifdef RTE_Compiler_IO_STDERR
S  if (stream == &__stderr) {
S#if (STDERR_CR_LF != 0)
S    if (c == '\n') stderr_putchar('\r');
S#endif
S    return (stderr_putchar(c));
S  }
S#endif
S 
S  return (-1);
S}
S 
S 
S/**
S   Obtains the next character (if present) as an unsigned char converted to
S   an int, from the input stream pointed to by stream, and advances the
S   associated file position indicator (if defined).
S 
S  \param[in] stream  Stream handle
S 
S  \return    The next character from the input stream pointed to by stream.
S             If the stream is at end-of-file, the end-of-file indicator is
S             set and fgetc returns EOF. If a read error occurs, the error
S             indicator is set and fgetc returns EOF.
S*/
S__weak int fgetc (FILE * stream) {
S#ifdef RTE_Compiler_IO_STDIN
S  int ch;
S 
S  if (stream == &__stdin) {
S    if (getchar_undo) {
S      ch = getchar_ch;
S      getchar_ch = -1;
S      getchar_undo = 0;
S      return (ch);
S    }
S    ch = stdin_getchar();
S#if (STDIN_ECHO != 0)
S    stdout_putchar(ch);
S#endif
S    getchar_ch = ch;
S    return (ch);
S  }
S#endif
S 
S  return (-1);
S}
S 
S 
S/**
S   The function __backspace() is used by the scanf family of functions, and must
S   be re-implemented if you retarget the stdio arrangements at the fgetc() level.
S 
S  \param[in] stream  Stream handle
S 
S  \return    The value returned by __backspace() is either 0 (success) or EOF
S             (failure). It returns EOF only if used incorrectly, for example,
S             if no characters have been read from the stream. When used 
S             correctly, __backspace() must always return 0, because the scanf
S             family of functions do not check the error return.
S*/
S__weak int __backspace(FILE *stream) {
S 
S#ifdef RTE_Compiler_IO_STDIN
S  if (stream == &__stdin) {
S    if (getchar_ch != -1) {
S      getchar_undo = 1;
S      return (0);
S    }
S    return (-1);
S  }
S#endif
S 
S  return (-1);
S}
S 
S 
S/**
S  Called from assert() and prints a message on stderr and calls abort().
S 
S  \param[in] expr  assert expression that was not TRUE
S  \param[in] file  source file of the assertion
S  \param[in] line  source line of the assertion
S*/
S__weak void __aeabi_assert (const char *expr, const char *file, int line) {
S  char str[12], *p;
S 
S  fputs("*** assertion failed: ", stderr);
S  fputs(expr, stderr);
S  fputs(", file ", stderr);
S  fputs(file, stderr);
S  fputs(", line ", stderr);
S 
S  p = str + sizeof(str);
S  *--p = '\0';
S  *--p = '\n';
S  while (line > 0) {
S    *--p = '0' + (line % 10);
S    line /= 10;
S  }
S  fputs(p, stderr);
S 
S  abort();
S}
S 
S 
S__weak void abort(void) {
S  for (;;);
S}
S 
S 
N#else  /* __MICROLIB */
N 
N 
N#if (defined(RTE_Compiler_IO_STDIN)  || \
N     defined(RTE_Compiler_IO_STDOUT) || \
N     defined(RTE_Compiler_IO_STDERR) || \
N     defined(RTE_Compiler_IO_File))
X#if (0L  ||      0L ||      0L ||      1L)
N#define RETARGET_SYS
N 
N/* IO device file handles. */
N#define FH_STDIN    0x8001
N#define FH_STDOUT   0x8002
N#define FH_STDERR   0x8003
N// User defined ...
N 
N/* Standard IO device name defines. */
Nconst char __stdin_name[]  = ":STDIN";
Nconst char __stdout_name[] = ":STDOUT";
Nconst char __stderr_name[] = ":STDERR";
N 
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function opens a file.
N 
N  The _sys_open() function is required by fopen() and freopen(). These
N  functions in turn are required if any file input/output function is to
N  be used.
N  The openmode parameter is a bitmap whose bits mostly correspond directly to
N  the ISO mode specification. Target-dependent extensions are possible, but
N  freopen() must also be extended.
N 
N  \param[in] name     File name
N  \param[in] openmode Mode specification bitmap
N 
N  \return    The return value is 1 if an error occurs.
N*/
N#ifdef RETARGET_SYS
N__weak FILEHANDLE _sys_open (const char *name, int openmode) {
N 
N  if (name == NULL) {
X  if (name == 0) {
N    return (-1);
N  }
N 
N  if (name[0] == ':') {
N    if (strcmp(name, ":STDIN") == 0) {
N      return (FH_STDIN);
X      return (0x8001);
N    }
N    if (strcmp(name, ":STDOUT") == 0) {
N      return (FH_STDOUT);
X      return (0x8002);
N    }
N    if (strcmp(name, ":STDERR") == 0) {
N      return (FH_STDERR);
X      return (0x8003);
N    }
N    return (-1);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_open(name, openmode));
N#endif
N#else
S  return (-1);
N#endif
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function closes a file previously opened
N  with _sys_open().
N  
N  This function must be defined if any input/output function is to be used.
N 
N  \param[in] fh File handle
N 
N  \return    The return value is 0 if successful. A nonzero value indicates
N             an error.
N*/
N#ifdef RETARGET_SYS
N__weak int _sys_close (FILEHANDLE fh) {
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N      return (0);
N    case FH_STDOUT:
X    case 0x8002:
N      return (0);
N    case FH_STDERR:
X    case 0x8003:
N      return (0);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_close(fh));
N#endif
N#else
S  return (-1);
N#endif
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function writes the contents of a buffer to a file
N  previously opened with _sys_open().
N 
N  \note The mode parameter is here for historical reasons. It contains
N        nothing useful and must be ignored.
N 
N  \param[in] fh   File handle
N  \param[in] buf  Data buffer
N  \param[in] len  Data length
N  \param[in] mode Ignore this parameter
N 
N  \return    The return value is either:
N             - a positive number representing the number of characters not
N               written (so any nonzero return value denotes a failure of
N               some sort)
N             - a negative number indicating an error.
N*/
N#ifdef RETARGET_SYS
N__weak int _sys_write (FILEHANDLE fh, const uint8_t *buf, uint32_t len, int mode) {
N#if (defined(RTE_Compiler_IO_STDOUT) || defined(RTE_Compiler_IO_STDERR))
X#if (0L || 0L)
S  int ch;
N#endif
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N      return (-1);
N    case FH_STDOUT:
X    case 0x8002:
N#ifdef RTE_Compiler_IO_STDOUT
S      for (; len; len--) {
S        ch = *buf++;
S#if (STDOUT_CR_LF != 0)
S        if (ch == '\n') stdout_putchar('\r');
S#endif
S        stdout_putchar(ch);
S      }
N#endif
N      return (0);
N    case FH_STDERR:
X    case 0x8003:
N#ifdef RTE_Compiler_IO_STDERR
S      for (; len; len--) {
S        ch = *buf++;
S#if (STDERR_CR_LF != 0)
S        if (ch == '\n') stderr_putchar('\r');
S#endif
S        stderr_putchar(ch);
S      }
N#endif
N      return (0);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_write(fh, buf, len));
N#endif
N#else
S  return (-1);
N#endif
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function reads the contents of a file into a buffer.
N 
N  Reading up to and including the last byte of data does not turn on the EOF
N  indicator. The EOF indicator is only reached when an attempt is made to read
N  beyond the last byte of data. The target-independent code is capable of
N  handling:
N    - the EOF indicator being returned in the same read as the remaining bytes
N      of data that precede the EOF
N    - the EOF indicator being returned on its own after the remaining bytes of
N      data have been returned in a previous read.
N 
N  \note The mode parameter is here for historical reasons. It contains
N        nothing useful and must be ignored.
N 
N  \param[in] fh   File handle
N  \param[in] buf  Data buffer
N  \param[in] len  Data length
N  \param[in] mode Ignore this parameter
N 
N  \return     The return value is one of the following:
N              - The number of bytes not read (that is, len - result number of
N                bytes were read).
N              - An error indication.
N              - An EOF indicator. The EOF indication involves the setting of
N                0x80000000 in the normal result.
N*/
N#ifdef RETARGET_SYS
N__weak int _sys_read (FILEHANDLE fh, uint8_t *buf, uint32_t len, int mode) {
N#ifdef RTE_Compiler_IO_STDIN
S  int ch;
N#endif
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N#ifdef RTE_Compiler_IO_STDIN
S      ch = stdin_getchar();
S      if (ch < 0) {
S        return (len | 0x80000000);
S      }
S      *buf++ = (uint8_t)ch;
S#if (STDIN_ECHO != 0)
S      stdout_putchar(ch);
S#endif
S      len--;
S      return (len);
N#else
N      return (len | 0x80000000);
N#endif
N    case FH_STDOUT:
X    case 0x8002:
N      return (-1);
N    case FH_STDERR:
X    case 0x8003:
N      return (-1);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_read(fh, buf, len));
N#endif
N#else
S  return (-1);
N#endif
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function writes a character to the console. The
N  console might have been redirected. You can use this function as a last
N  resort error handling routine.
N  
N  The default implementation of this function uses semihosting.
N  You can redefine this function, or __raise(), even if there is no other
N  input/output. For example, it might write an error message to a log kept
N  in nonvolatile memory.
N 
N  \param[in] ch character to write
N*/
N#if   defined(RTE_Compiler_IO_TTY)
X#if   0L
S#if   defined(RTE_Compiler_IO_TTY_User)
Sextern void  ttywrch (int ch);
S__weak void _ttywrch (int ch) {
S  ttywrch(ch);
S}
S#elif defined(RTE_Compiler_IO_TTY_ITM)
S__weak void _ttywrch (int ch) {
S  ITM_SendChar(ch);
S}
S#elif defined(RTE_Compiler_IO_TTY_BKPT)
S__weak void _ttywrch (int ch) {
S  __breakpoint(0);
S}
S#endif
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function determines if a file handle identifies
N  a terminal.
N 
N  When a file is connected to a terminal device, this function is used to
N  provide unbuffered behavior by default (in the absence of a call to
N  set(v)buf) and to prohibit seeking.
N 
N  \param[in] fh File handle
N 
N  \return    The return value is one of the following values:
N             - 0:     There is no interactive device.
N             - 1:     There is an interactive device.
N             - other: An error occurred.
N*/
N#ifdef RETARGET_SYS
N__weak int _sys_istty (FILEHANDLE fh) {
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N      return (1);
N    case FH_STDOUT:
X    case 0x8002:
N      return (1);
N    case FH_STDERR:
X    case 0x8003:
N      return (1);
N  }
N 
N  return (0);
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function puts the file pointer at offset pos from
N  the beginning of the file.
N 
N  This function sets the current read or write position to the new location pos
N  relative to the start of the current file fh.
N 
N  \param[in] fh  File handle
N  \param[in] pos File pointer offset
N 
N  \return    The result is:
N             - non-negative if no error occurs
N             - negative if an error occurs
N*/
N#ifdef RETARGET_SYS
N__weak int _sys_seek (FILEHANDLE fh, long pos) {
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N      return (-1);
N    case FH_STDOUT:
X    case 0x8002:
N      return (-1);
N    case FH_STDERR:
X    case 0x8003:
N      return (-1);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_seek(fh, pos));
N#endif
N#else
S  return (-1);
N#endif
N}
N#endif
N 
N 
N/**
N  Defined in rt_sys.h, this function returns the current length of a file.
N 
N  This function is used by _sys_seek() to convert an offset relative to the
N  end of a file into an offset relative to the beginning of the file.
N  You do not have to define _sys_flen() if you do not intend to use fseek().
N  If you retarget at system _sys_*() level, you must supply _sys_flen(),
N  even if the underlying system directly supports seeking relative to the
N  end of a file.
N 
N  \param[in] fh File handle
N 
N  \return    This function returns the current length of the file fh,
N             or a negative error indicator.
N*/
N#ifdef RETARGET_SYS
N__weak long _sys_flen (FILEHANDLE fh) {
N 
N  switch (fh) {
N    case FH_STDIN:
X    case 0x8001:
N      return (0);
N    case FH_STDOUT:
X    case 0x8002:
N      return (0);
N    case FH_STDERR:
X    case 0x8003:
N      return (0);
N  }
N 
N#ifdef RTE_Compiler_IO_File
N#ifdef RTE_Compiler_IO_File_FS
N  return (__sys_flen(fh));
N#endif
N#else
S  return (0);
N#endif
N}
N#endif
N 
N 
N#endif  /* __MICROLIB */
