; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\rtx_conf_cm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\rtx_conf_cm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -ID:\Keil555\1986VE9X\card\RTE -ID:\Keil555\1986VE9X\card\RTE\Device\MDR1986BE93 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\CMSIS_Driver\MDR1986VE9X -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__RTX -D__UVISION_VERSION=516 -D_RTE_ -DUSE_MDR32F9Q3_Rev1 --signed_chars --omf_browse=.\objects\rtx_conf_cm.crf RTE\CMSIS\RTX_Conf_CM.c]
                          THUMB

                          AREA ||i.__user_perthread_libspace||, CODE, READONLY, ALIGN=2

                  __user_perthread_libspace PROC
;;;196    
;;;197    void *__user_perthread_libspace (void) {
000000  4807              LDR      r0,|L1.32|
000002  b510              PUSH     {r4,lr}
;;;198      /* Provide a separate libspace for each task. */
;;;199      uint32_t idx;
;;;200    
;;;201      idx = os_running ? runtask_id () : 0;
000004  7800              LDRB     r0,[r0,#0]  ; os_running
000006  b148              CBZ      r0,|L1.28|
000008  f7fffffe          BL       rt_tsk_self
00000c  b130              CBZ      r0,|L1.28|
;;;202      if (idx == 0) {
;;;203        /* RTX not running yet. */
;;;204        return (&__libspace_start);
;;;205      }
;;;206      return ((void *)&std_libspace[idx-1]);
00000e  4905              LDR      r1,|L1.36|
000010  eb000040          ADD      r0,r0,r0,LSL #1
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  3860              SUBS     r0,r0,#0x60
;;;207    }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  4802              LDR      r0,|L1.40|
00001e  bd10              POP      {r4,pc}
;;;208    
                          ENDP

                  |L1.32|
                          DCD      os_running
                  |L1.36|
                          DCD      ||.bss||+0xd68
                  |L1.40|
                          DCD      __libspace_start

                          AREA ||i._mutex_acquire||, CODE, READONLY, ALIGN=2

                  _mutex_acquire PROC
                  ||__tagsym$$used||
;;;225    
;;;226    __attribute__((used)) void _mutex_acquire (OS_ID *mutex) {
000000  4905              LDR      r1,|L2.24|
;;;227      /* Acquire a system mutex, lock stdlib resources. */
;;;228      if (os_running) {
000002  7809              LDRB     r1,[r1,#0]  ; os_running
000004  2900              CMP      r1,#0                 ;226
000006  d005              BEQ      |L2.20|
;;;229        /* RTX running, acquire a mutex. */
;;;230        mutex_wait (*mutex);
000008  6800              LDR      r0,[r0,#0]
00000a  f64f71ff          MOV      r1,#0xffff
00000e  f8dfc00c          LDR      r12,|L2.28|
000012  df00              SVC      #0x0
                  |L2.20|
;;;231      }
;;;232    }
000014  4770              BX       lr
;;;233    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      os_running
                  |L2.28|
                          DCD      rt_mut_wait

                          AREA ||i._mutex_initialize||, CODE, READONLY, ALIGN=2

                  _mutex_initialize PROC
;;;210    
;;;211    int _mutex_initialize (OS_ID *mutex) {
000000  4a08              LDR      r2,|L3.36|
000002  b510              PUSH     {r4,lr}
;;;212      /* Allocate and initialize a system mutex. */
;;;213    
;;;214      if (nr_mutex >= OS_MUTEXCNT) {
000004  6911              LDR      r1,[r2,#0x10]  ; nr_mutex
000006  4603              MOV      r3,r0                 ;211
000008  2908              CMP      r1,#8
00000a  d300              BCC      |L3.14|
                  |L3.12|
;;;215        /* If you are here, you need to increase the number OS_MUTEXCNT. */
;;;216        for (;;);
00000c  e7fe              B        |L3.12|
                  |L3.14|
;;;217      }
;;;218      *mutex = &std_libmutex[nr_mutex++];
00000e  4806              LDR      r0,|L3.40|
000010  eb001001          ADD      r0,r0,r1,LSL #4
000014  1c49              ADDS     r1,r1,#1
000016  6018              STR      r0,[r3,#0]
;;;219      mutex_init (*mutex);
000018  6111              STR      r1,[r2,#0x10]  ; nr_mutex
00001a  f7fffffe          BL       rt_mut_init
;;;220      return (1);
00001e  2001              MOVS     r0,#1
;;;221    }
000020  bd10              POP      {r4,pc}
;;;222    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.data||
                  |L3.40|
                          DCD      ||.bss||+0x1008

                          AREA ||i._mutex_release||, CODE, READONLY, ALIGN=2

                  _mutex_release PROC
                  |symbol_number.65|
;;;236    
;;;237    __attribute__((used)) void _mutex_release (OS_ID *mutex) {
000000  4904              LDR      r1,|L4.20|
;;;238      /* Release a system mutex, unlock stdlib resources. */
;;;239      if (os_running) {
000002  7809              LDRB     r1,[r1,#0]  ; os_running
000004  2900              CMP      r1,#0                 ;237
000006  d003              BEQ      |L4.16|
;;;240        /* RTX running, release a mutex. */
;;;241        mutex_rel (*mutex);
000008  6800              LDR      r0,[r0,#0]
00000a  f8dfc00c          LDR      r12,|L4.24|
00000e  df00              SVC      #0x0
                  |L4.16|
;;;242      }
;;;243    }
000010  4770              BX       lr
;;;244    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      os_running
                  |L4.24|
                          DCD      rt_mut_release

                          AREA ||i.os_error||, CODE, READONLY, ALIGN=1

                  os_error PROC
;;;280    /// \param[in]   error_code   actual error code that has been detected
;;;281    void os_error (uint32_t error_code) {
000000  2801              CMP      r0,#1
;;;282     
;;;283      /* HERE: include optional code to be executed on runtime error. */
;;;284      switch (error_code) {
000002  d006              BEQ      |L5.18|
000004  2802              CMP      r0,#2
000006  d005              BEQ      |L5.20|
000008  2803              CMP      r0,#3
00000a  d004              BEQ      |L5.22|
00000c  2804              CMP      r0,#4
00000e  d104              BNE      |L5.26|
000010  e002              B        |L5.24|
                  |L5.18|
;;;285        case OS_ERROR_STACK_OVF:
;;;286          /* Stack overflow detected for the currently running task. */
;;;287          /* Thread can be identified by calling svcThreadGetId().   */
;;;288          break;
000012  e002              B        |L5.26|
                  |L5.20|
;;;289        case OS_ERROR_FIFO_OVF:
;;;290          /* ISR FIFO Queue buffer overflow detected. */
;;;291          break;
000014  e001              B        |L5.26|
                  |L5.22|
;;;292        case OS_ERROR_MBX_OVF:
;;;293          /* Mailbox overflow detected. */
;;;294          break;
000016  e000              B        |L5.26|
                  |L5.24|
;;;295        case OS_ERROR_TIMER_OVF:
;;;296          /* User Timer Callback Queue overflow detected. */
;;;297          break;
000018  bf00              NOP      
                  |L5.26|
00001a  bf00              NOP                            ;288
;;;298      }
;;;299      for (;;);
00001c  bf00              NOP      
                  |L5.30|
00001e  e7fe              B        |L5.30|
;;;300    }
;;;301     
                          ENDP


                          AREA ||i.os_idle_demon||, CODE, READONLY, ALIGN=1

                  os_idle_demon PROC
;;;224    /// \brief The idle demon is running when no other thread is ready to run
;;;225    void os_idle_demon (void) {
000000  bf00              NOP      
                  |L6.2|
;;;226     
;;;227      for (;;) {
000002  e7fe              B        |L6.2|
;;;228        /* HERE: include optional user code to be executed when no thread runs.*/
;;;229      }
;;;230    }
;;;231     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mp_tcb
                          %        376
                  mp_stk
                          %        1552
                  os_stack_mem
                          %        1312
                  os_fifo
                          %        132
                  os_active_TCB
                          %        28
                  os_messageQ_q_osTimerMessageQ
                          %        32
                  std_libspace
                          %        672
                  std_libmutex
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_maxtaskrun
000000  0007              DCW      0x0007
000002  0000              DCB      0x00,0x00
                  os_stackinfo
                          DCD      0x01020100
                  os_rrobin
                          DCD      0x00010005
                  os_tickfreq
                          DCD      0x04c4b400
                  os_tickus_i
000010  0050              DCW      0x0050
                  os_tickus_f
000012  0000              DCW      0x0000
                  os_trv
                          DCD      0x0001387f
                  os_flags
000018  01000000          DCB      0x01,0x00,0x00,0x00
                  CMSIS_RTOS_API_Version
                  |symbol_number.24|
                          DCD      0x00010002
                  CMSIS_RTOS_RTX_Version
                  |symbol_number.25|
                          DCD      0x0004004e
                  os_clockrate
                  |symbol_number.26|
                          DCD      0x000003e8
                  os_timernum
                  |symbol_number.27|
                          DCD      0x00000000
                  mp_tcb_size
00002c  0178              DCW      0x0178
00002e  0000              DCB      0x00,0x00
                  mp_stk_size
                          DCD      0x00000610
                  os_stack_sz
                          DCD      0x00000520
                  os_fifo_size
000038  10000000          DCB      0x10,0x00,0x00,0x00
                  os_thread_def_osTimerThread
                          DCD      osTimerThread
000040  0002              DCW      0x0002
000042  0000              DCB      0x00,0x00
                          DCD      0x00000001
                          DCD      0x00000100
                  os_messageQ_def_osTimerMessageQ
                          DCD      0x00000004
                          DCD      os_messageQ_q_osTimerMessageQ
                  mp_tmr_size
000054  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  osThreadId_osTimerThread
                          DCD      0x00000000
                  osMessageQId_osTimerMessageQ
                          DCD      0x00000000
                  os_tmr
                          DCD      0x00000000
                  m_tmr
                          DCD      0x00000000
                  nr_mutex
                          DCD      0x00000000
                  os_thread_def_main
                          DCD      main
000018  0000              DCW      0x0000
00001a  0000              DCB      0x00,0x00
                          DCD      0x00000001
                          DCD      0x00000400

;*** Start embedded assembler ***

#line 1 "RTE\\CMSIS\\RTX_Conf_CM.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_platform_post_lib_init|
#line 268 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\RTOS\\RTX\\INC\\RTX_CM_lib.h"
|_platform_post_lib_init| PROC
#line 268


 IMPORT os_thread_def_main
 IMPORT osKernelInitialize
 IMPORT osKernelStart
 IMPORT osThreadCreate
 IMPORT exit

 ADD SP,#0x10
 BL osKernelInitialize
 LDR R0,=os_thread_def_main
 MOVS R1,#0
 BL osThreadCreate
 BL osKernelStart
 BL exit

 ALIGN
	ENDP

;*** End   embedded assembler ***
