; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\fs_config.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\fs_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -ID:\Keil555\1986VE9X\card\RTE -ID:\Keil555\1986VE9X\card\RTE\Device\MDR1986BE93 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Driver\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\RTOS\RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\MDK-Middleware\6.5.0\FileSystem\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\CMSIS_Driver\MDR1986VE9X -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__RTX -D__UVISION_VERSION=516 -D_RTE_ -DUSE_MDR32F9Q3_Rev1 --signed_chars --omf_browse=.\objects\fs_config.crf RTE\File_System\FS_Config.c]
                          THUMB

                          AREA ||i.$Sub$$fflush||, CODE, READONLY, ALIGN=1

                  ||$Sub$$fflush|| PROC
;;;1367   
;;;1368   _ARMABI int $Sub$$fflush(FILE *stream) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1369     int *fh;
;;;1370   
;;;1371     if ($Super$$fflush (stream) == 0) {
000004  f7fffffe          BL       ||$Super$$fflush||
000008  b108              CBZ      r0,|L1.14|
;;;1372       fh = (int *)stream;
;;;1373       /* File handle is at offset 5 */
;;;1374       return (__sys_ensure (fh[5]));
;;;1375     }
;;;1376     return (1);
00000a  2001              MOVS     r0,#1
;;;1377   }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  6960              LDR      r0,[r4,#0x14]         ;1374
000010  e8bd4010          POP      {r4,lr}               ;1374
000014  f7ffbffe          B.W      __sys_ensure
;;;1378   
                          ENDP


                          AREA ||i.MC0_SPI_SignalEvent||, CODE, READONLY, ALIGN=2

                  MC0_SPI_SignalEvent PROC
;;;404      #if (MC0_SPI == 1)
;;;405      static void MC0_SPI_SignalEvent (uint32_t event) {
000000  4901              LDR      r1,|L2.8|
;;;406        mc_spi_DrvEvent (event, &mc0_dev);
000002  f7ffbffe          B.W      mc_spi_DrvEvent
;;;407      }
;;;408      #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.efs_analyse||, CODE, READONLY, ALIGN=1

                  efs_analyse PROC
;;;1399    fsStatus efs_delete(int32_t h)                               { return (fsError); }
;;;1400    int32_t  efs_analyse(fsEFS_Volume *v)                        { return (0);       }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1401    fsStatus efs_check  (fsEFS_Volume *v)                        { return (fsError); }
                          ENDP


                          AREA ||i.efs_check||, CODE, READONLY, ALIGN=1

                  efs_check PROC
;;;1400    int32_t  efs_analyse(fsEFS_Volume *v)                        { return (0);       }
;;;1401    fsStatus efs_check  (fsEFS_Volume *v)                        { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1402    fsStatus efs_format (fsEFS_Volume *v)                        { return (fsError); }
                          ENDP


                          AREA ||i.efs_close||, CODE, READONLY, ALIGN=1

                  efs_close PROC
;;;1390    fsStatus efs_open  (int32_t h, const char *p, int a)         { return (fsError); }
;;;1391    fsStatus efs_close (int32_t h)                               { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1392    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a) { return (0);       }
                          ENDP


                          AREA ||i.efs_defrag||, CODE, READONLY, ALIGN=1

                  efs_defrag PROC
;;;1403    uint32_t efs_free   (fsEFS_Volume *v)                        { return (0);       }
;;;1404    fsStatus efs_defrag (fsEFS_Volume *v)                        { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1405   #endif /* EFS_USE */
                          ENDP


                          AREA ||i.efs_delete||, CODE, READONLY, ALIGN=1

                  efs_delete PROC
;;;1398    fsStatus efs_find  (int32_t h, const char *p)                { return (fsError); }
;;;1399    fsStatus efs_delete(int32_t h)                               { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1400    int32_t  efs_analyse(fsEFS_Volume *v)                        { return (0);       }
                          ENDP


                          AREA ||i.efs_ffind||, CODE, READONLY, ALIGN=1

                  efs_ffind PROC
;;;1396    fsStatus efs_seek  (int32_t h, uint32_t a)                   { return (fsError); }
;;;1397    fsStatus efs_ffind (int32_t h, fsFileInfo *i)                { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1398    fsStatus efs_find  (int32_t h, const char *p)                { return (fsError); }
                          ENDP


                          AREA ||i.efs_find||, CODE, READONLY, ALIGN=1

                  efs_find PROC
;;;1397    fsStatus efs_ffind (int32_t h, fsFileInfo *i)                { return (fsError); }
;;;1398    fsStatus efs_find  (int32_t h, const char *p)                { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1399    fsStatus efs_delete(int32_t h)                               { return (fsError); }
                          ENDP


                          AREA ||i.efs_flen||, CODE, READONLY, ALIGN=1

                  efs_flen PROC
;;;1394    fsStatus efs_flush (int32_t h)                               { return (fsError); }
;;;1395    int32_t  efs_flen  (int32_t h)                               { return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1396    fsStatus efs_seek  (int32_t h, uint32_t a)                   { return (fsError); }
                          ENDP


                          AREA ||i.efs_flush||, CODE, READONLY, ALIGN=1

                  efs_flush PROC
;;;1393    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a) { return (-1);      }
;;;1394    fsStatus efs_flush (int32_t h)                               { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1395    int32_t  efs_flen  (int32_t h)                               { return (-1);      }
                          ENDP


                          AREA ||i.efs_format||, CODE, READONLY, ALIGN=1

                  efs_format PROC
;;;1401    fsStatus efs_check  (fsEFS_Volume *v)                        { return (fsError); }
;;;1402    fsStatus efs_format (fsEFS_Volume *v)                        { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1403    uint32_t efs_free   (fsEFS_Volume *v)                        { return (0);       }
                          ENDP


                          AREA ||i.efs_free||, CODE, READONLY, ALIGN=1

                  efs_free PROC
;;;1402    fsStatus efs_format (fsEFS_Volume *v)                        { return (fsError); }
;;;1403    uint32_t efs_free   (fsEFS_Volume *v)                        { return (0);       }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1404    fsStatus efs_defrag (fsEFS_Volume *v)                        { return (fsError); }
                          ENDP


                          AREA ||i.efs_handle_get||, CODE, READONLY, ALIGN=1

                  efs_handle_get PROC
;;;1384    bool     efs_path_valid (const char *p)                      { return (false);   }
;;;1385    int32_t  efs_handle_get(fsEFS_Volume *v)                     { return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1386    fsStatus efs_init      (fsEFS_Volume *v)                     { return (fsError); }
                          ENDP


                          AREA ||i.efs_init||, CODE, READONLY, ALIGN=1

                  efs_init PROC
;;;1385    int32_t  efs_handle_get(fsEFS_Volume *v)                     { return (-1);      }
;;;1386    fsStatus efs_init      (fsEFS_Volume *v)                     { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1387    fsStatus efs_uninit    (fsEFS_Volume *v)                     { return (fsError); }
                          ENDP


                          AREA ||i.efs_mount||, CODE, READONLY, ALIGN=1

                  efs_mount PROC
;;;1387    fsStatus efs_uninit    (fsEFS_Volume *v)                     { return (fsError); }
;;;1388    fsStatus efs_mount     (fsEFS_Volume *v)                     { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1389    fsStatus efs_unmount   (fsEFS_Volume *v)                     { return (fsError); }
                          ENDP


                          AREA ||i.efs_open||, CODE, READONLY, ALIGN=1

                  efs_open PROC
;;;1389    fsStatus efs_unmount   (fsEFS_Volume *v)                     { return (fsError); }
;;;1390    fsStatus efs_open  (int32_t h, const char *p, int a)         { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1391    fsStatus efs_close (int32_t h)                               { return (fsError); }
                          ENDP


                          AREA ||i.efs_path_valid||, CODE, READONLY, ALIGN=1

                  efs_path_valid PROC
;;;1383   #if (EFS_USE == 0)
;;;1384    bool     efs_path_valid (const char *p)                      { return (false);   }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1385    int32_t  efs_handle_get(fsEFS_Volume *v)                     { return (-1);      }
                          ENDP


                          AREA ||i.efs_read||, CODE, READONLY, ALIGN=1

                  efs_read PROC
;;;1391    fsStatus efs_close (int32_t h)                               { return (fsError); }
;;;1392    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a) { return (0);       }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1393    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a) { return (-1);      }
                          ENDP


                          AREA ||i.efs_seek||, CODE, READONLY, ALIGN=1

                  efs_seek PROC
;;;1395    int32_t  efs_flen  (int32_t h)                               { return (-1);      }
;;;1396    fsStatus efs_seek  (int32_t h, uint32_t a)                   { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1397    fsStatus efs_ffind (int32_t h, fsFileInfo *i)                { return (fsError); }
                          ENDP


                          AREA ||i.efs_uninit||, CODE, READONLY, ALIGN=1

                  efs_uninit PROC
;;;1386    fsStatus efs_init      (fsEFS_Volume *v)                     { return (fsError); }
;;;1387    fsStatus efs_uninit    (fsEFS_Volume *v)                     { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1388    fsStatus efs_mount     (fsEFS_Volume *v)                     { return (fsError); }
                          ENDP


                          AREA ||i.efs_unmount||, CODE, READONLY, ALIGN=1

                  efs_unmount PROC
;;;1388    fsStatus efs_mount     (fsEFS_Volume *v)                     { return (fsError); }
;;;1389    fsStatus efs_unmount   (fsEFS_Volume *v)                     { return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1390    fsStatus efs_open  (int32_t h, const char *p, int a)         { return (fsError); }
                          ENDP


                          AREA ||i.efs_write||, CODE, READONLY, ALIGN=1

                  efs_write PROC
;;;1392    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a) { return (0);       }
;;;1393    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a) { return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1394    fsStatus efs_flush (int32_t h)                               { return (fsError); }
                          ENDP


                          AREA ||i.elink_cmd||, CODE, READONLY, ALIGN=1

                  elink_cmd PROC
;;;1448     uint32_t   elink_flush     (const char *p)                     { return (1);    }
;;;1449     uint32_t   elink_cmd       (uint32_t i, uint32_t j)            { return (0);    }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1450     uint32_t   elink_insert    (void *p, uint32_t i)               { return (1);    }
                          ENDP


                          AREA ||i.elink_delete||, CODE, READONLY, ALIGN=1

                  elink_delete PROC
;;;1450     uint32_t   elink_insert    (void *p, uint32_t i)               { return (1);    }
;;;1451     uint32_t   elink_delete    (void *p, uint32_t i)               { return (0);    }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1452     uint32_t   elink_scan      (uint32_t i, void **pp, uint32_t j) { return (1);    }
                          ENDP


                          AREA ||i.elink_flush||, CODE, READONLY, ALIGN=1

                  elink_flush PROC
;;;1447     uint32_t   elink_init_path (const char *p, bool b)             { return (0xFF); }
;;;1448     uint32_t   elink_flush     (const char *p)                     { return (1);    }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1449     uint32_t   elink_cmd       (uint32_t i, uint32_t j)            { return (0);    }
                          ENDP


                          AREA ||i.elink_init||, CODE, READONLY, ALIGN=1

                  elink_init PROC
;;;1445   #if (NCACHE_USE == 0)
;;;1446     uint32_t   elink_init      (void)                              { return (1);    }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1447     uint32_t   elink_init_path (const char *p, bool b)             { return (0xFF); }
                          ENDP


                          AREA ||i.elink_init_path||, CODE, READONLY, ALIGN=1

                  elink_init_path PROC
;;;1446     uint32_t   elink_init      (void)                              { return (1);    }
;;;1447     uint32_t   elink_init_path (const char *p, bool b)             { return (0xFF); }
000000  20ff              MOVS     r0,#0xff
000002  4770              BX       lr
;;;1448     uint32_t   elink_flush     (const char *p)                     { return (1);    }
                          ENDP


                          AREA ||i.elink_insert||, CODE, READONLY, ALIGN=1

                  elink_insert PROC
;;;1449     uint32_t   elink_cmd       (uint32_t i, uint32_t j)            { return (0);    }
;;;1450     uint32_t   elink_insert    (void *p, uint32_t i)               { return (1);    }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1451     uint32_t   elink_delete    (void *p, uint32_t i)               { return (0);    }
                          ENDP


                          AREA ||i.elink_scan||, CODE, READONLY, ALIGN=1

                  elink_scan PROC
;;;1451     uint32_t   elink_delete    (void *p, uint32_t i)               { return (0);    }
;;;1452     uint32_t   elink_scan      (uint32_t i, void **pp, uint32_t j) { return (1);    }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1453   #endif
                          ENDP


                          AREA ||i.fdelete||, CODE, READONLY, ALIGN=1

                  fdelete PROC
;;;1347   /* Use new fdelete() function */
;;;1348   fsStatus fdelete (const char *path, const char *options) {
000000  f7ffbffe          B.W      _fdelete
;;;1349     return (_fdelete (path, options));
;;;1350   }
;;;1351   #endif
                          ENDP


                          AREA ||i.fs_config||, CODE, READONLY, ALIGN=2

                  fs_config PROC
;;;1292    *----------------------------------------------------------------------------*/
;;;1293   void fs_config (const char *drive) {
000000  7801              LDRB     r1,[r0,#0]
;;;1294     switch (drive[0]) {
000002  294d              CMP      r1,#0x4d
000004  d002              BEQ      |L32.12|
;;;1295   #if (NOR0_ENABLE || NOR1_ENABLE)
;;;1296       case 'F':
;;;1297         fs_config_flash (drive[1]);
;;;1298         break;
;;;1299   #endif
;;;1300   
;;;1301   #if (MC0_ENABLE || MC1_ENABLE)
;;;1302       case 'M':
;;;1303         fs_config_mc (drive[1]);
;;;1304         break;
;;;1305   #endif
;;;1306   
;;;1307   #if (NAND0_ENABLE || NAND1_ENABLE)
;;;1308       case 'N':
;;;1309         fs_config_nand (drive[1]);
;;;1310         break;
;;;1311   #endif
;;;1312   
;;;1313   #if (RAM0_ENABLE)
;;;1314       case 'R':
;;;1315         fs_config_ram (drive[1]);
;;;1316         break;
;;;1317   #endif
;;;1318   
;;;1319   #if (USB0_ENABLE || USB1_ENABLE)
;;;1320       case 'U':
;;;1321         fs_config_usb (drive[1]);
;;;1322         break;
;;;1323   #endif
;;;1324       default:
;;;1325         STREAM_LIST_LOCK;
000006  480f              LDR      r0,|L32.68|
000008  6800              LDR      r0,[r0,#0]  ; _stream_list_lock
                  |L32.10|
;;;1326         break;
;;;1327     }
;;;1328   }
00000a  4770              BX       lr
                  |L32.12|
00000c  7840              LDRB     r0,[r0,#1]            ;1303
00000e  2830              CMP      r0,#0x30              ;1303
000010  d1fb              BNE      |L32.10|
000012  480e              LDR      r0,|L32.76|
000014  490c              LDR      r1,|L32.72|
000016  2300              MOVS     r3,#0                 ;1303
000018  6001              STR      r1,[r0,#0]            ;1303  ; mc0_vol
00001a  f10002b8          ADD      r2,r0,#0xb8           ;1303
00001e  2108              MOVS     r1,#8                 ;1303
000020  6783              STR      r3,[r0,#0x78]         ;1303  ; mc0_vol
000022  e9c02102          STRD     r2,r1,[r0,#8]         ;1303
000026  f100017c          ADD      r1,r0,#0x7c           ;1303
00002a  778b              STRB     r3,[r1,#0x1e]         ;1303
00002c  608a              STR      r2,[r1,#8]            ;1303  ; mc0_dev
00002e  4a08              LDR      r2,|L32.80|
000030  600a              STR      r2,[r1,#0]            ;1303  ; mc0_dev
000032  4a08              LDR      r2,|L32.84|
000034  604a              STR      r2,[r1,#4]            ;1303  ; mc0_dev
000036  3120              ADDS     r1,r1,#0x20           ;1303
000038  4a07              LDR      r2,|L32.88|
00003a  604a              STR      r2,[r1,#4]            ;1303  ; mc0_fsj
00003c  6141              STR      r1,[r0,#0x14]         ;1303  ; mc0_vol
00003e  2140              MOVS     r1,#0x40              ;1303
000040  8201              STRH     r1,[r0,#0x10]         ;1303
000042  4770              BX       lr
;;;1329   
                          ENDP

                  |L32.68|
                          DCD      _stream_list_lock
                  |L32.72|
                          DCD      ||.constdata||+0xc
                  |L32.76|
                          DCD      ||.bss||+0xa0
                  |L32.80|
                          DCD      Driver_SPI0
                  |L32.84|
                          DCD      MC0_SPI_SignalEvent
                  |L32.88|
                          DCD      ||.bss||+0x1558

                          AREA ||i.mc0_DevCtrl||, CODE, READONLY, ALIGN=2

                  mc0_DevCtrl PROC
;;;383      }
;;;384      static fsStatus mc0_DevCtrl (fsDevCtrlCode code, void *p) {
000000  4a01              LDR      r2,|L33.8|
;;;385        return (MC0_DEVCTRL (code, p));
000002  f7ffbffe          B.W      mc_spi_DevCtrl
;;;386      }
;;;387    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.mc0_Init||, CODE, READONLY, ALIGN=2

                  mc0_Init PROC
;;;368      /* MC0 wrapper functions */
;;;369      static uint32_t mc0_Init (uint32_t mode) {
000000  4901              LDR      r1,|L34.8|
;;;370        return (MC0_INIT (mode));
000002  f7ffbffe          B.W      mc_spi_Init
;;;371      }
;;;372      static uint32_t mc0_UnInit (uint32_t mode) {
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.mc0_RdInfo||, CODE, READONLY, ALIGN=2

                  mc0_RdInfo PROC
;;;380      }
;;;381      static uint32_t mc0_RdInfo (fsMediaInfo *info) {
000000  4901              LDR      r1,|L35.8|
;;;382        return (MC0_RDINFO (info));
000002  f7ffbffe          B.W      mc_spi_ReadInfo
;;;383      }
;;;384      static fsStatus mc0_DevCtrl (fsDevCtrlCode code, void *p) {
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.mc0_RdSect||, CODE, READONLY, ALIGN=2

                  mc0_RdSect PROC
;;;374      }
;;;375      static uint32_t mc0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
000000  4b01              LDR      r3,|L36.8|
;;;376        return (MC0_RDSEC (sect, buf, cnt));
000002  f7ffbffe          B.W      mc_spi_ReadSector
;;;377      }
;;;378      static uint32_t mc0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.mc0_UnInit||, CODE, READONLY, ALIGN=2

                  mc0_UnInit PROC
;;;371      }
;;;372      static uint32_t mc0_UnInit (uint32_t mode) {
000000  4901              LDR      r1,|L37.8|
;;;373        return (MC0_UNINIT (mode));
000002  f7ffbffe          B.W      mc_spi_UnInit
;;;374      }
;;;375      static uint32_t mc0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      ||.bss||+0x11c

                          AREA ||i.mc0_WrSect||, CODE, READONLY, ALIGN=2

                  mc0_WrSect PROC
;;;377      }
;;;378      static uint32_t mc0_WrSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
000000  4b01              LDR      r3,|L38.8|
;;;379        return (MC0_WRSEC (sect, buf, cnt));
000002  f7ffbffe          B.W      mc_spi_WriteSector
;;;380      }
;;;381      static uint32_t mc0_RdInfo (fsMediaInfo *info) {
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      ||.bss||+0x11c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  fs_fat_fh
                          %        160
                  mc0_vol
                          %        124
                  mc0_dev
                          %        32
                  mc0_fsj
                          %        28
                  mc0_cache
                          %        5632

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  fs_fat_fh_cnt
000000  04                DCB      0x04
                  fs_efs_fh_cnt
000001  00                DCB      0x00
                  _NDRV
000002  0100              DCB      0x01,0x00
                  fs_efs_timeout_erase_chip
000004  012c              DCW      0x012c
                  fs_efs_timeout_erase_sector
000006  05                DCB      0x05
                  fs_efs_timeout_write
000007  01                DCB      0x01
                  fs_efs_timeout_read
000008  01000000          DCB      0x01,0x00,0x00,0x00
                  mc0_drv
                          DCD      mc0_Init
                          DCD      mc0_UnInit
                          DCD      mc0_RdSect
                          DCD      mc0_WrSect
                          DCD      mc0_RdInfo
                          DCD      mc0_DevCtrl
                  fs_DevPool
                          DCD      mc0_vol
000028  4d30000d          DCB      0x4d,0x30,0x00,0x0d

                          AREA ||.data||, DATA, ALIGN=2

                  fs_efs_fh
                          DCD      0x00000000
